<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://img.econow.cn/2018/1545104669394.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://img.econow.cn/2018/1545104669394.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"econow.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Medivh&#39;s castle">
<meta property="og:url" content="https://econow.cn/index.html">
<meta property="og:site_name" content="Medivh&#39;s castle">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="medivh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://econow.cn/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Medivh's castle</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?21ded952ca9fc25e2b0630494a17ec7f"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Medivh's castle</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">数据蜘蛛工作室</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a href="/search" rel="section"><i class="fa fa-search fa-fw"></i>搜索</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">medivh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E5%85%B3%E4%BA%8E%E6%B7%B7%E5%90%88%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%E7%9A%84%E8%AE%BE%E6%83%B3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%85%B3%E4%BA%8E%E6%B7%B7%E5%90%88%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%E7%9A%84%E8%AE%BE%E6%83%B3.html" class="post-title-link" itemprop="url">关于混合部署方案的设想</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">云原生</span></a>
        </span>
    </span>

  
    <span id="/%E5%85%B3%E4%BA%8E%E6%B7%B7%E5%90%88%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%E7%9A%84%E8%AE%BE%E6%83%B3.html" class="post-meta-item leancloud_visitors" data-flag-title="关于混合部署方案的设想" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="理论依据"><a href="#理论依据" class="headerlink" title="理论依据"></a>理论依据</h2><p>在时效性上来区分任务，常规的任务一般分为在线任务和离线任务。其中在线任务消耗的资源相对较少，但是要求相应时间较短，比如web服务；而离线任务则对时效性要求不高，但是任务量大，需要的资源更多。因此把两种项目混合部署在一起就叫做混合部署。</p>
<p>大多数进程可以分为I&#x2F;O密集型和CPU密集型。I&#x2F;O密集型程序将大多数时间都花在了I&#x2F;O操作而不是运算上，而CPU密集型程序正好相反，将大多数时间花在了运算上，而很少产生I&#x2F;O操作。选出一个I&#x2F;O密集型和CPU密集型程序的良好组合，对于长期调度器是非常重要的。否则，假如所有的程序都是CPU密集型的，那么I&#x2F;O队列将会几乎永远都是空的，这样就会导致一些设备从来没被使用过，系统资源分配就是不均衡的。显然，性能极佳的系统必然是CPU密集型和I&#x2F;O密集型程序的组合。在现代操作系统中，这被用来保证实时进程能获得足够的CPU时间来完成任务。但我们的当前绝大部分项目并不能做到资源的和谐组合——cpu使用率远低于内存使用率。这样的特点也方便混合部署的时候只需要考虑内存的瓶颈即可。</p>
<h2 id="资源使用率现状"><a href="#资源使用率现状" class="headerlink" title="资源使用率现状"></a>资源使用率现状</h2><p>通俗来讲，我们希望使用提高资源使用率的同时降低成本。任务类型的分类是提高资源利用率的理论依据，只不过迫于现实，实践过程中会有些偏差。<br>当前的现状，大部分CPU平均使用率长期在30%以内徘徊，极大的浪费资源。<br><img src="https://img.econow.cn/medivh/1630553329133.png"  /></p>
<p>而对于内存调整的空间较为有限，个别实例有操作空间。<br><img src="https://img.econow.cn/medivh/1630553335430.png"  /></p>
<p>当前的实例用途类型基本分为三类：</p>
<ul>
<li>大数据集群<ul>
<li>夜间使用率高，白天使用率低</li>
<li>CPU和内存需求较高</li>
</ul>
</li>
<li>微服务<ul>
<li>白天使用率微高，夜间极低</li>
<li>CPU使用率较低，内存使用率微高</li>
</ul>
</li>
<li>中间件<ul>
<li>波动较小<br>自2021年起始，累计增加了约8~10个微服务项目，关停1台主机但并没有增加新的实例主机。单纯的微服务集群内存使用率峰值只增加了不到5个百分点。这些数字说明了一些可能的现象：</li>
</ul>
</li>
<li>业务量有降低</li>
<li>代码性能更好<br>当前保有实例45台，每年的开支大约在32万，是不是有可能降低10%~15%？</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>现有ECS基本可以分为2种类型的实例，离线型和在线型。其中离线型的实例配置较高，常规配置为16核32G，近期保有量为3~5台。因此之后一段时间可以将部分微服务部署在相应的节点。</p>
<h3 id="规划节点"><a href="#规划节点" class="headerlink" title="规划节点"></a>规划节点</h3><p>节点角色</p>
<ul>
<li>003~005 轻量级节点</li>
<li>006~007 常规级节点</li>
<li></li>
</ul>
<h4 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h4><p>轻量级的实例部署了多种大数据相关的服务，因此只可部署少量的微服务，避免极端情况下微服务和大数据服务资源的抢夺。常规级的节点可以部署更多pod。。同时，两类服务共存会带来一些潜在的问题：</p>
<ol>
<li>极端调度；</li>
<li>抢夺资源；</li>
<li>网络关系.</li>
</ol>
<p>以上三个问题中最重要的是第一个问题，第一个问题处理好后，第二个问题就会很好处理。而第三个则是永远无法避免的，能做的只能是选择网络依赖最小的微服务。因此，重点解决调度的问题。</p>
<ol>
<li>节点选择。在默认情况下，pod的调度是由scheduler-crontroller根据节点资源和有限制来自动完成的。但是在目前的情况下我们希望微服务部署在某些节点和少量部署在另一部分节点上。对于指定节点部署可以使用NodeSelector设定的标签来选择节点，原理是给node设置标签，scheduler就会把pod调度到具有该标签的node上。</li>
<li>资源限制。每个pod都会有cpu和memory的limits限制，因此再加上pod的数量限制，就可以避免服务间的资源抢夺了。设置–max-pods较为简单，修改各node kubelet启动参数即可，较容易实现。</li>
<li>均匀调度。每个微服务默认期望部署在至少两个节点，常规实例和大数据实例。对于这个问题需要用节点亲和性和pod亲和性来处理。节点亲和性指定了将pod调度到节点的权重或其他规则。pod亲和性基于已经在节点上运行的pod的标签来约束pod可以调度到的节点，而不是基于节点的标签。但是这这两种方式不适合当前版本的kubernetes，只能在高版本的集群上使用。<br>综上所述，潜在问题可以大部分通过参数调整达到期望的状态，基本满足正常使用。如果期望达到更好的状态，则必须升级kubernetes集群。</li>
</ol>
<h3 id="部署节点"><a href="#部署节点" class="headerlink" title="部署节点"></a>部署节点</h3><h4 id="部署kubelete-client"><a href="#部署kubelete-client" class="headerlink" title="部署kubelete client"></a>部署kubelete client</h4><p>常规部署，无特殊处理，修改<code>--max-pods</code>。</p>
<h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><ul>
<li>需注意大数据集群和业务服务的网络互通，重点在安全组的配置</li>
</ul>
<h4 id="预期目标"><a href="#预期目标" class="headerlink" title="预期目标"></a>预期目标</h4><p>目前保有143个pod，加上部分服务的编排处理，预计全部的pod会到达160个。通过混合部署，预计能释放20~30个pod的资源潜力，约至少32G内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当年内预期目标ECS部分的开支控制在30万内，去年约31万。当前阶段通过资源混部来实现资源的错位运用可以提高一些资源利用率。接下来通过pod的资源利用率监控可以更合理的进行资源限制，释放过剩资源。之后kubernetes的版本升级之后带来的亲和性功能和hpa、vpa、ca则会带来更多的想象空间。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%AE%A1%E6%89%B9%E8%A7%84%E8%8C%83.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%AE%A1%E6%89%B9%E8%A7%84%E8%8C%83.html" class="post-title-link" itemprop="url">数据库操作审批规范</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%9A%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">业务</span></a>
        </span>
    </span>

  
    <span id="/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%AE%A1%E6%89%B9%E8%A7%84%E8%8C%83.html" class="post-meta-item leancloud_visitors" data-flag-title="数据库操作审批规范" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h2><p>为规范生产环境数据库管理和操作，提高审核执行效率，特制定本规范。</p>
<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>本规范中所定义的数据管理内容，指生产环境中的数据库（公司内部项目以及外部项目中的数据库），且包括并不限于 MySQL、Redis、Hive 等。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>普通数据：<ul>
<li>表结构、常规非涉密字段等数据</li>
</ul>
</li>
<li>涉密数据：<ul>
<li>用户信息，包括并不限于手机号、姓名、地址、IP、IMEI 等</li>
<li>公司运行数据，包括并不限于业务订单等</li>
</ul>
</li>
</ul>
<h2 id="操作等级"><a href="#操作等级" class="headerlink" title="操作等级"></a>操作等级</h2><table>
<thead>
<tr>
<th>等级</th>
<th>审核</th>
<th>审核对象</th>
<th>适用类型</th>
<th>数量</th>
<th>是否涉密</th>
<th>可靠性级别</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>否</td>
<td>自行审核</td>
<td>查询表结构、数量、非涉密数据</td>
<td>&lt;1000</td>
<td>否</td>
<td>普通</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>是</td>
<td>项目组长</td>
<td>修改表结构或字段、插入数据，查询大量数据</td>
<td>&lt;5000</td>
<td>否</td>
<td>普通&#x2F;重要</td>
<td>评估后如果影响大，抄送给相关业务线人员，以及技术总监</td>
</tr>
<tr>
<td>2</td>
<td>是</td>
<td>项目组长</td>
<td>查询涉密数据</td>
<td>&lt;100</td>
<td>是</td>
<td>普通</td>
<td>抄送技术总监</td>
</tr>
<tr>
<td>3</td>
<td>是</td>
<td>技术总监</td>
<td>删除表、数据等</td>
<td></td>
<td>否</td>
<td>重要</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>是</td>
<td>技术总监</td>
<td>查询涉密数据</td>
<td>&gt;100</td>
<td>是</td>
<td>普通</td>
<td></td>
</tr>
</tbody></table>
<h2 id="操作规则"><a href="#操作规则" class="headerlink" title="操作规则"></a>操作规则</h2><ul>
<li>所有操作必须通过邮件来传递，运维人员不接受邮件以外的请求;</li>
<li>所有操作必须在主题中表明操作等级，通过操作等级来区分是否需要审核或者其他;</li>
<li>运维人员只接受项目组长或技术总监审核结果，不接受开发者操作请求（可弹性）;</li>
<li>严禁 drop 或者 delete 表操作。如有特殊情况，项目组长在邮件内容中说明操作理由；</li>
<li>SQL 语法错误，不予执行；</li>
<li>SQL 需按照标准语法，必须使用分号结尾,且插入语句不得包含数据库名称。</li>
</ul>
<h3 id="示例如下："><a href="#示例如下：" class="headerlink" title="示例如下："></a>示例如下：</h3><h4 id="开发人员希望查询-A-表的表结构，"><a href="#开发人员希望查询-A-表的表结构，" class="headerlink" title="开发人员希望查询 A 表的表结构，"></a>开发人员希望查询 A 表的表结构，</h4><p>1.邮件需要填写以下内容：</p>
<ul>
<li><p>邮件主题 等级 0+简要目的说明</p>
</li>
<li><p>收件人 项目组长</p>
</li>
<li><p>抄送 运维人员</p>
</li>
<li><p>邮件内容<br> * 查询 SQL</p>
<p>2.项目组长审核</p>
<p>3.上述流程完成，运维人员收到项目组长同意的结果后执行上述查询请求。</p>
</li>
</ul>
<h4 id="开发人员查询用户数据且大于-100-条："><a href="#开发人员查询用户数据且大于-100-条：" class="headerlink" title="开发人员查询用户数据且大于 100 条："></a>开发人员查询用户数据且大于 100 条：</h4><p>1.开发人员发起请求</p>
<ul>
<li><p>邮件主题 等级 4+简要目的说明</p>
</li>
<li><p>收件人 项目组长</p>
</li>
<li><p>抄送 运维人员</p>
</li>
<li><p>邮件内容<br> _ 查询原因<br>_ 查询 SQL</p>
<p>2.项目组长审核</p>
</li>
<li><p>如果审核通过，项目组长发送邮件给技术总监请求审核；</p>
</li>
<li><p>如果未通过，开发者调整 SQL 或取消查询</p>
<p>3.技术总监收到项目组长邮件申请请求</p>
</li>
<li><p>审核结果回复给项目组长</p>
<p>4.上述流程完成，运维人员收到技术总监同意的结果后执行上述查询请求。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E5%B0%8F%E7%86%8A%E5%8A%A0%E6%B9%BF%E5%99%A8%E7%9A%84%E5%A4%8D%E6%B4%BB.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%B0%8F%E7%86%8A%E5%8A%A0%E6%B9%BF%E5%99%A8%E7%9A%84%E5%A4%8D%E6%B4%BB.html" class="post-title-link" itemprop="url">小熊加湿器的复活</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%90%E8%B6%A3/" itemprop="url" rel="index"><span itemprop="name">乐趣</span></a>
        </span>
    </span>

  
    <span id="/%E5%B0%8F%E7%86%8A%E5%8A%A0%E6%B9%BF%E5%99%A8%E7%9A%84%E5%A4%8D%E6%B4%BB.html" class="post-meta-item leancloud_visitors" data-flag-title="小熊加湿器的复活" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>上周空气有点干燥，打算把加湿器拿出来用上，但是它不出雾了！<br>明明上个月的时候还用过呢，咋就不行了呢？</p>
</blockquote>
<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p><strong>推测</strong><br>根据以往和查阅资料得出的经验：</p>
<ol>
<li>缺水</li>
<li>有雾气但是出不来，风扇故障</li>
<li>无雾，像喷泉，雾化片存留过多水碱或者雾化片故障</li>
</ol>
<blockquote>
<p>大部分情况都是由于雾化片的缘故，极少数是因为电路板或者其他组件的问题</p>
</blockquote>
<p><strong>原理</strong><br>基本原理主要由两部分组成：</p>
<ul>
<li>陶瓷振荡器通电振荡，产生水雾</li>
<li>风扇转动，送出水雾</li>
</ul>
<p><strong>排查</strong><br>根据当前的现象进行逐一排除：</p>
<ol>
<li>出水正常，不缺水，无效</li>
<li>用醋和食盐混合后擦拭雾化片，依然像喷泉一样，无效</li>
</ol>
<p>最终经过各方面检查，判断雾化片故障。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>推测是雾化片的问题后，查询京东订单，发现之前买的时候只有60多，而现在90多，这个反差！真恶心！</p>
<p>买一个雾化片吧，也就十块钱左右，总比再花90块钱强，咨询一下客服看看需要多大尺寸的。经过一系列咨询，客服的意思是集成的，无法更换零部件，总之就是坏了就买新的吧。再花90块钱，我不同意，那就自己拆下来量一下尺寸吧。</p>
<p>想象中的雾化片是这个样子的，基本都是在10块钱左右。</p>
<p><img src="https://img.econow.cn/medivh/1638155846311.png" alt="1638155846311.png"></p>
<ol>
<li><p>拆开底座。拿掉胶垫，就能看到螺丝，拧下来，这个螺丝的洞很深，螺丝刀需要长一点。而且需要注意的是小熊加湿器的螺丝在底部的四个缓冲垫下面藏着的。最开始的时候没找到螺丝，怎么也打不开底座。</p>
</li>
<li><p>拆卸雾化片。实际上小熊的雾化片真是集成的，螺丝都快拧坏了也没拆下来。雾化片的集成板上有很多连接线和卡扣，可以直接拆下来，不用担心还原的问题。因为每种卡扣基本都是独立的颜色，按照颜色插就可以了。</p>
<p> <img src="https://img.econow.cn/medivh/1638155925408.png" alt="1638155925408.png"></p>
<p> 这个是反面，基本和我的这一款一致</p>
<p> <img src="https://img.econow.cn/medivh/1638155962363.png" alt="1638155962363.png"></p>
<p> 另外一块是电源板，应该没有什么问题。<br> <img src="https://img.econow.cn/medivh/1638156032131.png" alt="1638156032131.png"></p>
<p> 最后是我拆下来的废弃的雾化片集成板，暂时先留着就当个纪念吧，虽然知道以后也不会用得到。</p>
<p> <img src="https://img.econow.cn/medivh/1638156097228.png" alt="1638156097228.png"></p>
</li>
<li><p>把所有的零件都插回去，注意雾化片集成板的方向一定要插对，否则是无法正常装上底座的</p>
</li>
<li><p>加水，通电。最开始的十几秒内并没有出现很多雾，当时一度担心不是雾化片的原因，可能是水温低吧，很快大股水雾就出来了。完美！</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多东西都要先了解一下原理，如果有的话。其次，如果能了解到更多的前因后果，那就更好了。<br>在很多场景下下会遇到维修成本的问题，如果可以接受那么久去做，就算没做好也当学习的经验了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5.html" class="post-title-link" itemprop="url">关于协程的认知</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span id="/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5.html" class="post-meta-item leancloud_visitors" data-flag-title="关于协程的认知" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在执行IO密集型任务的时候，程序经常会因为等待IO而阻塞。比如平时使用的requests库来进行请求接口，如果响应过慢，程序会一直等待响应，最后导致抓取数据的效率低下。为了解决这一问题，来研究一下异步协程加速的方法。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>阻塞。阻塞状态是指程序未得到所需计算资源被挂起的状态。程序在等待某操作期间，自身无法继续干别的事。常见的阻塞形式：网络I&#x2F;O阻塞、磁盘IO&#x2F;阻塞、用户输入阻塞等。</li>
<li>非阻塞。程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事，则成该程序在该操作上非阻塞的。 非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时和效率低下，因此我们才要把它变味非阻塞的。</li>
<li>同步。不同的程序为了完成某个任务，在执行过程中需要依靠某种同喜方式协调一致，称这些程序单元是同步执行的，比如商品库存。</li>
<li>异步。为了完成某个任务，不同程序之间过程无需通信协调，也能完成任务的方式，不相关的程序单元之间是可以异步的。比如爬虫网页。</li>
<li>多进程。就是利用CPU多核的优势，在同一时间并行的执行多个任务，可以极大的提高效率。</li>
<li>协程，Coroutine，又称微线程，是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复之前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，即局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态。协程本质上是个单线程，相对于多进程来说，无需线程的上下文切换的开销，无需原子操作锁定及同步的开销。可以使用的场景，比如在网络爬虫的场景，发出一个请求之后，需要等待一定的实际才能得到响应。但是在等待过程中，程序可以做一些其他的事情，等到响应后再切回来继续处理，这样可以充分利用CPU和其他资源，也就是协程的优势所在。</li>
</ul>
<h3 id="执行顺序的对比"><a href="#执行顺序的对比" class="headerlink" title="执行顺序的对比"></a>执行顺序的对比</h3><p><img src="https://img.econow.cn/medivh/1658742421514.png" alt="1658742421514.png"><br><img src="https://img.econow.cn/medivh/1658742437775.png" alt="1658742437775.png"></p>
<h2 id="协程的用法"><a href="#协程的用法" class="headerlink" title="协程的用法"></a>协程的用法</h2><p>协程相关的概念:  </p>
<ul>
<li>event_loop 事件循环，相当于一个无限循环，可以把一些函数注册到这个事件循环上，当满足条件时，就会调用对应的处理方法。</li>
<li>coroutine 协程，在 Python 中常指代为协程对象类型，可以将协程对象注册到事件循环中，会被事件循环调用。使用 async 关键字来定义一个方法，在调用时不会立即被执行，而是先放回一个协程对象。</li>
<li>task 任务，是对协程对象的进一步封装，包含了任务的所有状态。</li>
<li>future 代表将来执行或没有执行任务的任务的结果，和task没有本质的区别。</li>
</ul>
<h3 id="定义协程"><a href="#定义协程" class="headerlink" title="定义协程"></a>定义协程</h3><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_number</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine = get_number(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">Coroutine</span>: &lt;coroutine <span class="built_in">object</span> get_number at <span class="number">0x10e049f40</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Number: <span class="number">1</span></span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure>

<p>执行过程的分析：</p>
<ol>
<li>引入 asyncio ，这样才可以使用 async 和 await；</li>
<li>然后使用async定义一个方法，方法接收一个数字的参数，该方法执行后会打印数字；</li>
<li>随后调用这个方法，但是并没有执行，而是返回一个coroutine 协程对象；</li>
<li>之后我们使用get_event_loop方法创建一个事件循环loop，并调用了loop对象的run_until_complate方法将协程注册到事件循环loop中，然后启动；</li>
<li>最后看到了输出结果。</li>
</ol>
<p>可见，async 定义的方法机会变成一个无法直接运行的coroutine对象，必须注册到事件循环中才可以执行。上文中提到的task，是对coroutine对象的进一步封装，比coroutine对象多了允许状态，比如running、fiished等，可以通过这些状态来获取协程对象的执行情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_number</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine = get_number(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="type">Coroutine</span>: &lt;coroutine <span class="built_in">object</span> get_number at <span class="number">0x10e38df40</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_number() running at /Users/medivh/tools/test_async.py:<span class="number">45</span>&gt;&gt;</span><br><span class="line">Number: <span class="number">1</span></span><br><span class="line">Task: &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_number() done, defined at /Users/medivh/tools/test_async.py:<span class="number">45</span>&gt; result=<span class="number">1</span>&gt;</span><br><span class="line">After calling loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里定义loop对象后，接着调用了create_task方法将coroutine对象转化为了task对象，随后的输出发现是pending状态。接着将task对象添加到事件循环中得到执行，随后再输出，就变成了finished。并且同时result变成了1，也就是get_number方法的返回结果。</p>
<p>另外，还有一种定义task对象的方式，直接通过asyncio的ensure_future()方法，返回的也是task对象，就不需要借助loop来定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_number</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine = get_number(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    task = asyncio.ensure_future(coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="type">Coroutine</span>: &lt;coroutine <span class="built_in">object</span> get_number at <span class="number">0x10c19ff40</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_number() running at /Users/medivh/tools/test_async.py:<span class="number">48</span>&gt;&gt;</span><br><span class="line">Number: <span class="number">1</span></span><br><span class="line">Task: &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_number() done, defined at /Users/medivh/tools/test_async.py:<span class="number">48</span>&gt; result=<span class="number">1</span>&gt;</span><br><span class="line">After calling loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h3><p>可以给某个task搬到回调方法，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>():</span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Status:&#x27;</span>, task.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine_obj = get_status()</span><br><span class="line">    task = asyncio.ensure_future(coroutine_obj)  <span class="comment"># 定义task</span></span><br><span class="line">    task.add_done_callback(callback)    <span class="comment"># 将callback() 传递给封装好的task对象</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Task: &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;request() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt; cb=[callback() at /Users/medivh/tools/test_async.py:<span class="number">75</span>]&gt;</span><br><span class="line">Status: <span class="number">200</span></span><br><span class="line">Task: &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;request() done, defined at /Users/medivh/tools/test_async.py:<span class="number">69</span>&gt; result=<span class="number">200</span>&gt;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ol>
<li>调用add_done_callback方法，将callback方法传递给封装好的task对象；</li>
<li>task执行完毕后调用callback方法；</li>
<li>task对象同时作为参数传递给callback方法，调用task对象的result方法就可以获取返回结果。</li>
</ol>
<p>其实，不用回方法，直接在task运行完毕后也可以直接调用result方法获取结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>():</span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine_obj = get_status()</span><br><span class="line">    task = asyncio.ensure_future(coroutine_obj)  <span class="comment"># 定义task</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task Result:&#x27;</span>, task.result())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Task: &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_status() running at /Users/medivh/tools/test_async.py:<span class="number">69</span>&gt;&gt;</span><br><span class="line">Task: &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_status() done, defined at /Users/medivh/tools/test_async.py:<span class="number">69</span>&gt; result=<span class="number">200</span>&gt;</span><br><span class="line">Task Result: <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h3 id="多任务协程"><a href="#多任务协程" class="headerlink" title="多任务协程"></a>多任务协程</h3><p>对于想执行多次请求的方案，可以定义一个task列表，然后使用asyncio的wait方法即可执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>():</span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tasks = [asyncio.ensure_future(get_status()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Tasks: &quot;</span>, tasks)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Task Result:&quot;</span>, task.result())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Tasks:  [&lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending name=<span class="string">&#x27;Task-2&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending name=<span class="string">&#x27;Task-3&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending name=<span class="string">&#x27;Task-4&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending name=<span class="string">&#x27;Task-5&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;]</span><br><span class="line">Task Result: <span class="number">200</span></span><br><span class="line">Task Result: <span class="number">200</span></span><br><span class="line">Task Result: <span class="number">200</span></span><br><span class="line">Task Result: <span class="number">200</span></span><br><span class="line">Task Result: <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ol>
<li>for循环创建5个task，组成list；</li>
<li>把list首先传给asyncio的wait方法，然后注册到事件循环中；</li>
<li>发起5个任务；</li>
<li>输出任务结果。</li>
</ol>
<h3 id="协程实现"><a href="#协程实现" class="headerlink" title="协程实现"></a>协程实现</h3><p>前面的代码都是以网络请求为例，都是耗时的等待的操作，因为在请求网页后需要等待页面响应并返回结果。耗时的等待操作一般都是IO操作，比如文件读写、网络请求等，而协程对于处理这种操作具有很大优势。往往可以在需要等待的时候，程序可以暂时挂起，转而执行其他的操作，从而避免等待一个程序而耗费过多的时间，达到充分利用资源的目的。</p>
<p>代码示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/welcome&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url,time.time()))</span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(get_status()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818769.805218</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818770.0085208</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818770.101907</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818770.1906009</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818770.262319</span></span><br><span class="line">Cost time: <span class="number">0.5311617851257324</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>事实上和正常的请求耗时相差不大，几乎是依次执行的。其实出现这种情况是因为要实现异步处理，必须得有挂起的操作，当一个任务需要等待IO结果的时候，可以挂起当前任务，转而去执行其他任务。</p>
<p>接下来了解一下await的用法，使用await可以将耗时等待的操作挂起，让出控制权。当协程执行的时候遇到await，事件循环就会将本协程挂起，转而执行其他的协程，知道其他的协程挂起或执行完毕。然后，将代码改造一下。</p>
<blockquote>
<p>如果直接改造上文代码，会出现以下提示<code>Class &#39;int&#39; does not define &#39;__await__&#39;, so the &#39;await&#39; operator cannot be used on its instances </code>。这是因为await后必须符合以下对象：</p>
<ul>
<li>一个原生coroutine对象</li>
<li>一个有types.coroutine（）修饰的生成器，这个生成器可以返回coroutine对象</li>
<li>一个包含await方法的对象返回的一个迭代器</li>
</ul>
</blockquote>
<p>接下来进行一次尝试，用async把请求的方法改造成coroutine对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">return</span> requests.get(url).status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_result</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/welcome&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url, time.time()))</span><br><span class="line">    status = <span class="keyword">await</span> get_status(url)</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(get_result()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>)]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658819455.563387</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658819455.612329</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658819455.662548</span></span><br><span class="line">Cost time: <span class="number">3.005825996398926</span></span><br></pre></td></tr></table></figure>

<p>输出的结果证明这种方式不可行，并没有达到真正的异步。这里使用一个支持异步请求的库——aiohttp，利用它和asyncio配合可以方便的实现异步请求操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pip install apiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>(<span class="params">url</span>):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = <span class="keyword">await</span> session.get(url)</span><br><span class="line">    result = <span class="keyword">await</span> response.text()</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_result</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/api/afk/pod?current=1&amp;pageSize=100&#x27;</span></span><br><span class="line">    status = <span class="keyword">await</span> get_status(url)</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(get_result()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Cost time: <span class="number">1.1510028839111328</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请求耗时直接缩短到1秒左右。</p>
<ol>
<li>使用await，后面跟get方法，在执行10个协程的时候，遇到了await，就会将当前协程挂起，转而执行其他协程，直到其他协程也挂起或执行完毕，再进行下一个协程的执行；</li>
<li>开始运行的时候，事件循环会运行第一个task，第一个task执行遇到await跟着的get方法后，被挂起。但这个get方法第一步的执行是非阻塞的，挂起后立刻被环行，创建了ClientSession对象，接着遇到第二个await，调用了session.get()请求方法，然后就被挂起。由于请求耗时较久，所以一直没有被唤醒；</li>
<li>事件循环会寻找当前为被挂起的协程继续执行，于是转而执行第二个task。之后，依次执行了第10个task的session.get()方法后，全部的task被挂起。</li>
<li>所有task处于挂起状态，等待响应。1秒后，所有请求几乎同时有了响应，然后这10个task都被唤醒继续执行，输出请求结果。</li>
</ol>
<p>接下来尝试不同量级的task，输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">Cost time: 1.0380501747131348</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line">Cost time: 1.143162727355957</span><br><span class="line"></span><br><span class="line"><span class="comment"># 50</span></span><br><span class="line">Cost time: 3.379934787750244</span><br><span class="line"></span><br><span class="line"><span class="comment"># 100</span></span><br><span class="line">Cost time: 5.655962705612183</span><br><span class="line"></span><br><span class="line"><span class="comment"># 200 </span></span><br><span class="line">Cost time: 9.78205680847168</span><br><span class="line"></span><br><span class="line"><span class="comment"># 300</span></span><br><span class="line">Cost time: 9.797142028808594</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后的运行时间基本都在10秒内，200个task开始就会出现502情况，当然这个完全在于后端服务的问题。但是100个task以内的时候，时间都是很接近的。</p>
<h3 id="和单进程、多进程对比"><a href="#和单进程、多进程对比" class="headerlink" title="和单进程、多进程对比"></a>和单进程、多进程对比</h3><p>单进程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/api/afk/pod?current=1&amp;pageSize=100&#x27;</span></span><br><span class="line">    result = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        get_page()</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Cost time: <span class="number">106.35312700271606</span></span><br></pre></td></tr></table></figure>

<p>多进程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">_</span>):</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/api/afk/pod?current=1&amp;pageSize=100&#x27;</span></span><br><span class="line">    result = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">8</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(get_page, <span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Cost time: <span class="number">16.823662996292114</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>8核CPU执行时间为16.8秒，远大于协程的5.6秒。</p>
<p>多线程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/api/afk/pod?current=1&amp;pageSize=100&#x27;</span></span><br><span class="line">    result = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">        t = threading.Thread(target=get_page)</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">Cost time: <span class="number">10.563114881515503</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多线程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cost time: 1.160654067993164</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>前面讲了那么多，是不是有些内容值得思考一下呢？现在回过头来再总结一下。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象，进程是资源分配的最小单位。<br>那么为什么会有进程这个事物呢？主要目的是为了合理压榨CPU性能和分配运行的时间片。在计算机系统中，其计算核心是CPU，负责所有计算相关的工作和资源。单个CPU一次只能运行一个任务。如果一个进程运行着就完全占用一个CPU，是非常不合理的。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>有了多进程，为什么还要线程？原因如下：</p>
<ol>
<li>进程直接的信息难以共享，父子进程并未共享内存，需要进程间通信，性能开销大</li>
<li>创建进程的性能开销较大。</li>
</ol>
<p>进程由多个线程组成，一个进程可以由多个线程的执行单元组成。每个线程都在运行进程的上下文中，共享着同样的代码和全局数据。多个线程比多进程之间更容易共享数据，在上下文切换中一般比进程更高效，原因如下： </p>
<ol>
<li>线程间能够快速、方便共享数据</li>
<li>创建线程的速度比创建进程快10倍以上</li>
</ol>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是用户态的线程。协程的优势：</p>
<ol>
<li>节省CPU。避免系统内核级的线程频繁切换，造成CPU的浪费。协程是用户态的线程，用户可以自行控制协程的创建和销毁，极大程度上避免了系统级线程上下文切换造成的资源浪费。</li>
<li>节约内存。64位的Linux系统中，一个线程需要分配8MB栈内存和64MB堆内存。系统内存的制约导致无法开启更多线程的并发。而协程只需要KB级别，可以轻松达到几十万。</li>
<li>稳定性。线程之间通过内存来共享数据，这就会导致一个问题，比如一个线程出错时，进程中的所有线程都会跟着崩溃。</li>
<li>开发效率。开发过程中，可以方便的把一些耗时的IO操作异步化，比如些写文件、耗时IO请求等。</li>
</ol>
<p>总之，协程的本质是用户态下的线程.</p>
<p>用一个形象的例子：</p>
<ul>
<li>进程就像一家餐馆，餐馆有多个服务员，每个餐桌是要完成的任务。单进程，对应一家餐馆；</li>
<li>多进程，增加了N家餐馆，接待的客人多了，成本也上去了；</li>
<li>多线程。一家餐馆，来一桌客人安排一个服务员；</li>
<li>协程。一家餐馆只安排一个服务员，A点菜，就去B服务，A点完了就再回到A这。B还没点完就去C那，依次类推，直到所有人都吃上饭。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E5%A4%9A%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Kubernetes%E7%BD%91%E7%BB%9C%E6%89%93%E9%80%9A%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%A4%9A%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Kubernetes%E7%BD%91%E7%BB%9C%E6%89%93%E9%80%9A%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6.html" class="post-title-link" itemprop="url">多环境下的Kubernetes网络打通方案研究</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">云原生</span></a>
        </span>
    </span>

  
    <span id="/%E5%A4%9A%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Kubernetes%E7%BD%91%E7%BB%9C%E6%89%93%E9%80%9A%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6.html" class="post-meta-item leancloud_visitors" data-flag-title="多环境下的Kubernetes网络打通方案研究" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文中的Kubernetes集群统称为集群。</p>
</blockquote>
<p>现实的工作环境中，我们可能会在开发环境使用Kubernetes，也会在测试和开发环境使用Kubernetes。而一般来说，大部分人不会直接去连接或访问生产环境的集群，但是对于开发环境就不一样了。很多开发人员需要经常访问开发环境，而不是在本地起一堆依赖的服务。而且真的只有这么一个问题吗？</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>整理了若干常见的问题：</p>
<ol>
<li>开发人员本地服务访问开发环境</li>
<li>新集群和旧集群的网络互通，或者迁移</li>
<li>域名访问</li>
</ol>
<p>因此，我们需要解决以上问题，才能更安心的使用Kubernetes。</p>
<h2 id="网络互通"><a href="#网络互通" class="headerlink" title="网络互通"></a>网络互通</h2><p>首先来解决最主要的问题，如何实现不同网络环境下的互通问题？</p>
<p>众所周知，集群暴露服务的方式有以下几种：</p>
<ol>
<li>NodePort 每个服务维护一个端口，服务越多端口越多</li>
<li>LoadBalancer 在nodePort的基础上使用公有云的负载均衡器</li>
<li>ClusterIP 每个service有一个虚拟IP</li>
<li>Ingress 一个服务暴露多个service的服务，本质是一种路由转发机制</li>
</ol>
<h3 id="场景一、注册中心eureka的应用"><a href="#场景一、注册中心eureka的应用" class="headerlink" title="场景一、注册中心eureka的应用"></a>场景一、注册中心eureka的应用</h3><p>首先eureka可以使用StatefulSet的方式，实现一个集群的部署。以下文件可以直接使用：</p>
<ul>
<li>服务配置文件 <a target="_blank" rel="noopener" href="https://img.econow.cn/k8s/eureka/eureka-svc-np.yaml">https://img.econow.cn/k8s/eureka/eureka-svc-np.yaml</a></li>
<li>StatefulSet 文件 <a target="_blank" rel="noopener" href="https://img.econow.cn/k8s/eureka/eureka-sts.yaml">https://img.econow.cn/k8s/eureka/eureka-sts.yaml</a></li>
<li>Service 文件 <a target="_blank" rel="noopener" href="https://img.econow.cn/k8s/eureka/eureka-svc-np.yaml">https://img.econow.cn/k8s/eureka/eureka-svc-np.yaml</a></li>
</ul>
<h4 id="1-办公网访问应用"><a href="#1-办公网访问应用" class="headerlink" title="1. 办公网访问应用"></a>1. 办公网访问应用</h4><p>开发人员本地访问的时候可以使用NodePort的方式访问，也可以使用Ingress的方式访问。</p>
<p><img src="https://img.econow.cn/medivh/1651052056989.png" alt="1651052056989.png"></p>
<p>如图所示，创建了两个Python的应用，并注册到eureka。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time:2022/04/27</span></span><br><span class="line"><span class="string">@file:test_eureka.py</span></span><br><span class="line"><span class="string">@author:medivh</span></span><br><span class="line"><span class="string">@IDE:PyCharm </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> py_eureka_client.eureka_client <span class="keyword">as</span> eureka_client</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setEureka</span>():</span><br><span class="line">    eureka_client.init(eureka_server=<span class="string">&quot;http://192.168.1.217:31331/eureka&quot;</span>,</span><br><span class="line">                       app_name=<span class="string">&quot;flask_server-2&quot;</span>,</span><br><span class="line">                       <span class="comment"># 当前组件的主机名，可选参数，如果不填写会自动计算一个，如果服务和 eureka 服务器部署在同一台机器，请必须填写，否则会计算出 127.0.0.1</span></span><br><span class="line">                       instance_host=<span class="string">&#x27;10.1.3.141&#x27;</span>,</span><br><span class="line">                       instance_port=<span class="number">5001</span>,</span><br><span class="line">                       <span class="comment"># 调用其他服务时的高可用策略，可选，默认为随机</span></span><br><span class="line">                       ha_strategy=eureka_client.HA_STRATEGY_RANDOM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setEureka()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/info&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_info</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello Info!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>, threaded=<span class="literal">True</span>, port=<span class="number">5001</span>, host=<span class="string">&quot;0.0.0.0&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外一个测试脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time:2022/04/27</span></span><br><span class="line"><span class="string">@file:test_eureka-service.py</span></span><br><span class="line"><span class="string">@author:medivh</span></span><br><span class="line"><span class="string">@IDE:PyCharm </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> py_eureka_client.eureka_client <span class="keyword">as</span> eureka_client</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">eureka_client.init(eureka_server=<span class="string">&quot;http://192.168.1.109:31331/eureka&quot;</span>, app_name=<span class="string">&#x27;do_service&#x27;</span>, instance_host=<span class="string">&quot;10.1.3.141&quot;</span>,</span><br><span class="line">                   instance_port=<span class="number">5011</span>)</span><br><span class="line"><span class="comment"># get请求的调用</span></span><br><span class="line">res = eureka_client.do_service(<span class="string">&quot;flask_server-2&quot;</span>, <span class="string">&quot;/info&quot;</span>,</span><br><span class="line">                               <span class="comment"># 返回类型，默认为 `string`，可以传入 `json`，如果传入值是 `json`，那么该方法会返回一个 `dict` 对象</span></span><br><span class="line">                               return_type=<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">res = eureka_client.do_service(<span class="string">&quot;O2O-SERVICE&quot;</span>, <span class="string">&quot;/env-path/actuator/info&quot;</span>,</span><br><span class="line">                               <span class="comment"># 返回类型，默认为 `string`，可以传入 `json`，如果传入值是 `json`，那么该方法会返回一个 `dict` 对象</span></span><br><span class="line">                               return_type=<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment">## post请求的调用</span></span><br><span class="line"><span class="comment"># d = &#123;&#x27;a&#x27;: 1&#125;</span></span><br><span class="line"><span class="comment"># res = eureka_client.do_service(&#x27;helloindex&#x27;, &#x27;/user&#x27;, return_type=&#x27;string&#x27;, method=&#x27;POST&#x27;, data=json.dumps(d))</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line">res = eureka_client.do_service(<span class="string">&quot;O2O-SERVICE&quot;</span>, <span class="string">&quot;/env-path/actuator/info&quot;</span>,</span><br><span class="line">                               <span class="comment"># 返回类型，默认为 `string`，可以传入 `json`，如果传入值是 `json`，那么该方法会返回一个 `dict` 对象</span></span><br><span class="line">                               return_type=<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<p>调用测试结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">python test_eureka-service.py</span><br><span class="line">Hello Info!</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/medivh/github/box/test_eureka-service.py&quot;</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    res = eureka_client.do_service(<span class="string">&quot;O2O-SERVICE&quot;</span>, <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  File <span class="string">&quot;/Users/medivh/github/box/venv/lib/python3.8/site-packages/py_eureka_client/eureka_client.py&quot;</span>, line 1736, <span class="keyword">in</span> do_service</span><br><span class="line">    <span class="built_in">return</span> cli.do_service(app_name=app_name, service=service, return_type=return_type,</span><br><span class="line">  File <span class="string">&quot;/Users/medivh/github/box/venv/lib/python3.8/site-packages/py_eureka_client/eureka_client.py&quot;</span>, line 1467, <span class="keyword">in</span> do_service</span><br><span class="line">    <span class="built_in">return</span> self.walk_nodes(app_name, service, prefer_ip, prefer_https, walk_using_urllib)</span><br><span class="line">  File <span class="string">&quot;/Users/medivh/github/box/venv/lib/python3.8/site-packages/py_eureka_client/eureka_client.py&quot;</span>, line 1415, <span class="keyword">in</span> walk_nodes</span><br><span class="line">    raise http_client.URLError(<span class="string">&quot;Try all up instances in registry, but all fail&quot;</span>)</span><br><span class="line">urllib.error.URLError: &lt;urlopen error Try all up instances <span class="keyword">in</span> registry, but all fail&gt;</span><br><span class="line">[2022-04-27 17:32:39]-[eureka_client]-[line:1409] -WARNING: <span class="keyword">do</span> service / <span class="keyword">in</span> node [o2o-service-287077292-hj7q7:o2o-service:8080] error, use next node. Error: &lt;urlopen error timed out&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候说明注册中心是可以正常使用的，但是如果调用集群的服务就无法访问了，毕竟不在一个网段，也没有合适的路由。接下来就去解决这个问题。</p>
<h4 id="2-办公网访问集群Pod-Service"><a href="#2-办公网访问集群Pod-Service" class="headerlink" title="2.办公网访问集群Pod&#x2F;Service"></a>2.办公网访问集群Pod&#x2F;Service</h4><p>在网关和路由器上添加路由，把属于集群的Pod和Service的子网IP全部转发给其中某个node，这样访问Pod IP和Service IP，网络包会到达某个node，而集群内的node中，CNI会与这些目的地址互通。</p>
<p>网段：</p>
<table>
<thead>
<tr>
<th>网段名称</th>
<th>网段范围</th>
</tr>
</thead>
<tbody><tr>
<td>办公网段</td>
<td>10.1.3.0&#x2F;24</td>
</tr>
<tr>
<td>Pod地址池</td>
<td>10.200.0.0&#x2F;16</td>
</tr>
<tr>
<td>Svc地址池</td>
<td>10.96.0.0&#x2F;12</td>
</tr>
</tbody></table>
<p>如果不记得当时设置的网段是多少，可以用以下方式查询：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ kubectl get cm kubeadm-config -n kube-system -o yaml | grep -i podsub</span><br><span class="line">      podSubnet: 10.200.0.0/16</span><br><span class="line">~ kubectl get cm kubeadm-config -n kube-system -o yaml | grep -i servicesub</span><br><span class="line">      serviceSubnet: 10.96.0.0/12</span><br></pre></td></tr></table></figure>

<h5 id="steps-1"><a href="#steps-1" class="headerlink" title="steps 1"></a>steps 1</h5><p>选择集群中的一个节点进行路由转发，可以使用一台配置不高的节点，打上污点不允许调度占用资源。本文中使用的是master节点。</p>
<ol>
<li>设置污点 <code>kubectl taint nodes k8s-master forward=k8s-node5:NoSchedule</code></li>
<li>开启路由转发 <code>echo &quot;net.ipv4.ip_forward = 1&quot;  &gt;&gt; /etc/sysctl.conf</code></li>
<li>查看是否生效 <code>sysctl -p</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启转发</span></span><br><span class="line">~ vim /etc/sysctl.d/k8s.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">~ sysctl -p</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在k8s-master上设置snat</span></span><br><span class="line">~ iptables -t nat -A POSTROUTING -s 10.200.0.0/16  -d 10.1.3.0/24   -j MASQUERADE</span><br><span class="line">~ iptables -t nat -A POSTROUTING -s 10.96.0.0/12 -d 110.1.3.0/24   -j MASQUERADE</span><br><span class="line"> </span><br><span class="line"><span class="comment"># (可选)查看设置的snat</span></span><br><span class="line">~ iptables -t nat -L -n --line-numbers | grep -A 10 <span class="string">&quot;Chain POSTROUTING&quot;</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination        </span><br><span class="line">1    ......</span><br><span class="line">2    ......</span><br><span class="line">3    ......</span><br><span class="line">4    MASQUERADE  all  --  10.1.3.0/24          10.200.0.0/16</span><br><span class="line">5    MASQUERADE  all  --  10.1.3.0/24          10.96.0.0/12</span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选)如配置失误可删除已设置的snat条目</span></span><br><span class="line">~ iptables -t nat -D POSTROUTING 4</span><br></pre></td></tr></table></figure>

<h5 id="setps-2"><a href="#setps-2" class="headerlink" title="setps 2"></a>setps 2</h5><p>在办公网的出口路由上设置静态路由，将集群的Pod和Service网段，路由到master节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在路由器上需要做的配置：</span></span><br><span class="line">ip route add -net  10.200.0.0/16 gw 192.168.1.109</span><br><span class="line">ip route add -net  10.96.0.0/12 gw 192.168.1.109</span><br></pre></td></tr></table></figure>

<p><img src="https://img.econow.cn/medivh/1651115644098.png" alt="1651115644098.png"></p>
<h5 id="setps-3"><a href="#setps-3" class="headerlink" title="setps 3"></a>setps 3</h5><p>这个时候在办公网主机上<code>ping</code> 集群中的Pod或者service的IP，理论上就是通的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pod </span></span><br><span class="line">➜  ~ traceroute 10.200.96.148</span><br><span class="line">traceroute to 10.200.96.148 (10.200.96.148), 64 hops max, 52 byte packets</span><br><span class="line"> 1  10.1.3.1 (10.1.3.1)  2.781 ms  2.422 ms  2.388 ms</span><br><span class="line"> 2  bogon (192.168.1.109)  2.723 ms  3.352 ms  3.647 ms</span><br><span class="line"> 3  bogon (10.200.96.128)  3.724 ms  3.485 ms  3.417 ms</span><br><span class="line"> 4  10.200.96.148 (10.200.96.148)  3.551 ms  3.440 ms  3.390 ms</span><br><span class="line"></span><br><span class="line"> <span class="comment"># service </span></span><br><span class="line"></span><br><span class="line"> ➜  ~ traceroute 10.96.230.195</span><br><span class="line">traceroute to 10.96.230.195 (10.96.230.195), 64 hops max, 52 byte packets</span><br><span class="line"> 1  10.1.3.1 (10.1.3.1)  5.698 ms  2.482 ms  2.375 ms</span><br><span class="line"> 2  10.96.230.195 (10.96.230.195)  2.774 ms  2.807 ms  2.834 ms</span><br></pre></td></tr></table></figure>

<h5 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h5><p>如果以上操作都执行了，但是还是不通，请检查以下项目：</p>
<ol>
<li>转发是否开启</li>
<li>iptables的规则是否正确</li>
<li>iptables规则是否有<code> MASQUERADE  all  --  192.168.1.0/24       0.0.0.0/0</code> 这么一条</li>
</ol>
<p>至此，解决了开发人员无法在办公网访问集群环境的IP问题。</p>
<h2 id="跨集群访问"><a href="#跨集群访问" class="headerlink" title="跨集群访问"></a>跨集群访问</h2><p>如果我们有多个集群，这个时候如果实现网络打通呢，比如新旧集群迁移的时候？</p>
<h3 id="以IP形式访问"><a href="#以IP形式访问" class="headerlink" title="以IP形式访问"></a>以IP形式访问</h3><p>其实我们依然可以采用之前的方案，添加静态路由。</p>
<p>网段：</p>
<table>
<thead>
<tr>
<th>网段名称</th>
<th>网段范围</th>
</tr>
</thead>
<tbody><tr>
<td>办公网段</td>
<td>10.1.3.0&#x2F;24</td>
</tr>
<tr>
<td>集群A Pod地址池</td>
<td>10.200.0.0&#x2F;16</td>
</tr>
<tr>
<td>集群A Svc地址池</td>
<td>10.96.0.0&#x2F;12</td>
</tr>
<tr>
<td>集群B Pod地址池</td>
<td>10.100.0.0&#x2F;16</td>
</tr>
<tr>
<td>集群B Svc地址池</td>
<td>10.254.0.0&#x2F;16</td>
</tr>
</tbody></table>
<p>主要实现逻辑是每个集群选择一个节点，开启路由转发，实现办公网段可以访问集群中的IP。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">~ iptables -t nat -A POSTROUTING -s 10.1.3.0/24 -d 10.254.0.0/16 -j MASQUERADE -w</span><br><span class="line">~ iptables -t nat -A POSTROUTING -s 10.1.3.0/24 -d 10.100.0.0/16 -j MASQUERADE -w</span><br><span class="line">~ iptables -t nat -L -n --line-numbers | grep -A 10 <span class="string">&quot;Chain POSTROUTING&quot;</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">1    MASQUERADE  all  --  10.100.72.0/24       0.0.0.0/0</span><br><span class="line">2    KUBE-POSTROUTING  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */</span><br><span class="line">3    MASQUERADE  all  --  10.1.3.0/24          10.254.0.0/16</span><br><span class="line">4    MASQUERADE  all  --  10.1.3.0/24          10.100.0.0/16</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">1    RETURN     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">~ iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -d 0.0.0.0/0  -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 办公网</span></span><br><span class="line">➜  ~ traceroute 10.100.5.7</span><br><span class="line">traceroute to 10.100.5.7 (10.100.5.7), 64 hops max, 52 byte packets</span><br><span class="line"> 1  bogon (10.1.3.1)  2.699 ms  2.201 ms  2.140 ms</span><br><span class="line"> 2  *.demo.yourdomain.com (192.168.1.243)  2.213 ms  7.957 ms  7.389 ms</span><br><span class="line"> 3  bogon (10.100.5.0)  2.902 ms  4.637 ms  2.616 ms</span><br><span class="line"> 4  bogon (10.100.5.7)  4.109 ms  3.944 ms  2.782 ms</span><br><span class="line"></span><br><span class="line"> <span class="comment"># A集群到B集群</span></span><br><span class="line">~ tracepath 10.100.5.7</span><br><span class="line"> 1?: [LOCALHOST]                                         pmtu 1500</span><br><span class="line"> 1:  gateway                                               0.365ms</span><br><span class="line"> 1:  gateway                                               2.044ms</span><br><span class="line"> 2:  192.168.1.243                                         0.767ms</span><br><span class="line"> 3:  192.168.1.243                                         0.848ms pmtu 1450</span><br><span class="line"> 3:  10.100.5.0                                            1.536ms</span><br><span class="line"> 4:  10.100.5.7                                            1.382ms reached</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>办公网通过注册中心调用</p>
<p><img src="https://img.econow.cn/medivh/1651117439545.png" alt="1651117439545.png"></p>
<h3 id="以域名形式访问Service"><a href="#以域名形式访问Service" class="headerlink" title="以域名形式访问Service"></a>以域名形式访问Service</h3><p>实现了办公网和集群的网络互通后，就可以实现自由访问Pod和Service了。但是由于Pod IP会经常变化，Service IP也不是很容易记住，所以希望通过内网DNS的形式访问<code>*.cluser.local</code>时自动解析相应的IP。</p>
<h4 id="steps-1-获取coredns的IP"><a href="#steps-1-获取coredns的IP" class="headerlink" title="steps 1. 获取coredns的IP"></a>steps 1. 获取coredns的IP</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ kubectl get svc -n kube-system -l k8s-app=kube-dns</span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   34d</span><br></pre></td></tr></table></figure>

<h4 id="steps-2-部署DNS服务dnsmasq"><a href="#steps-2-部署DNS服务dnsmasq" class="headerlink" title="steps 2. 部署DNS服务dnsmasq"></a>steps 2. 部署DNS服务dnsmasq</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install dnsmasq</span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;dnsmasq.conf：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolv-file=/etc/resolv.dnsmasq.conf   <span class="comment">#指定上游dns服务器</span></span><br><span class="line">strict-order   <span class="comment">#严格按照resolv-file文件中的顺序进行从上到下解析，直到成功为止</span></span><br><span class="line">server=/cluster.local/10.96.0.10  <span class="comment">#指定以cluster.local为后缀的域名，使用coredns的地址解析,这里可以不配直接把coredns配置在/etc/resolv.dnsmasq.conf 里面。</span></span><br><span class="line">listen-address=192.168.1.109   <span class="comment">#指定本地IP地址</span></span><br><span class="line">addn-hosts=/etc/dnsmasq.hosts   <span class="comment">#自定义dns记录文件</span></span><br><span class="line">conf-dir=/etc/dnsmasq.d    <span class="comment">#所有的解析记录都会存在此目录下</span></span><br></pre></td></tr></table></figure>

<p>修改resolv.dnsmasq.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameserver 61.139.2.69</span><br><span class="line">nameserver 202.106.0.20</span><br><span class="line">nameserver 192.168.1.109</span><br></pre></td></tr></table></figure>

<p>开机并启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> dnsmasq &amp;&amp; systemctl start dnsmasq</span><br></pre></td></tr></table></figure>

<h4 id="steps-3-验证"><a href="#steps-3-验证" class="headerlink" title="steps 3. 验证"></a>steps 3. 验证</h4><p>在其他机器上测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">~ traceroute eureka.default.svc.cluster.local</span><br><span class="line">traceroute to eureka.default.svc.cluster.local (10.200.229.155), 30 hops max, 60 byte packets</span><br><span class="line"> 1  192.168.1.1 (192.168.1.1)  0.151 ms  0.145 ms  0.137 ms</span><br><span class="line"> 2  new.eureka.com (192.168.1.109)  0.622 ms  0.595 ms *</span><br><span class="line"> 3  bogon (10.200.229.128)  1.311 ms  1.972 ms  2.019 ms</span><br><span class="line"> 4  bogon (10.200.229.155)  2.075 ms  2.743 ms  2.741 ms</span><br><span class="line"></span><br><span class="line">curl -I eureka.default.svc.cluster.local:8761</span><br><span class="line">HTTP/1.1 200</span><br><span class="line">X-Application-Context: DiscoveryServer:8761</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Language: en-US</span><br><span class="line">Content-Length: 7451</span><br><span class="line">Date: Thu, 28 Apr 2022 05:47:08 GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后来在其他的服务器上测试可以正常访问，在Mac下能使用nslookup解析，但是无法访问，也无法路由跟踪，以后再解决。</p>
<p>后来发现如果是Mac的话，直接在网络设置-高级-DNS，添加dns地址并拖到上面即可实现访问。只是奇怪的是手动修改<code>/etc/resolv.conf</code> 并没有实现访问，这种界面的形式反而可以，总之，解决了问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E5%85%B3%E4%BA%8E%E5%AF%B9Flask%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E8%AE%B0%E5%BD%95.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%85%B3%E4%BA%8E%E5%AF%B9Flask%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E8%AE%B0%E5%BD%95.html" class="post-title-link" itemprop="url">Flask 学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span id="/%E5%85%B3%E4%BA%8E%E5%AF%B9Flask%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E8%AE%B0%E5%BD%95.html" class="post-meta-item leancloud_visitors" data-flag-title="Flask 学习" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>常用的架构有以下两种方式：</p>
<ul>
<li>功能式</li>
<li>分布式</li>
</ul>
<h3 id="功能式"><a href="#功能式" class="headerlink" title="功能式"></a>功能式</h3><p>简单来讲就是以功能来归类文件，比如静态文件放一个目录，模块文件放一个目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yourapp/</span><br><span class="line">    __init__.py</span><br><span class="line">    static/</span><br><span class="line">    templates/</span><br><span class="line">        home/</span><br><span class="line">        control_panel/</span><br><span class="line">        admin/</span><br><span class="line">    views/</span><br><span class="line">        __init__.py</span><br><span class="line">        home.py</span><br><span class="line">        control_panel.py</span><br><span class="line">        admin.py</span><br><span class="line">    models.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了 <code>yourapp/views/__init__.py</code>，在<code>yourapp/views/</code>文件夹中的每一个.py文件都是一个蓝图。在<code>yourapp/__init__.py</code> 中，我们将加载这些蓝图并在我们的Flask()对象中注册它们。</p>
<p>特点：</p>
<ul>
<li>分类明确，很明显就知道去哪找哪种文件；</li>
<li>适合小型项目；</li>
<li>各功能之间联系紧密；</li>
</ul>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>按照每一部分所属的蓝图来组织你的应用。比如A功能的静态文件、模块、视图都放在A的这一个大的目录下。就像一个国家有N个诸侯，每个诸侯管理自己的地盘，互不打扰。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yourapp/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    home/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    control_panel/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    models.py</span><br></pre></td></tr></table></figure>

<p>在像上面列举的分区式结构，每一个yourapp&#x2F;之下的文件夹都是一个独立的蓝图。所有的蓝图通过顶级的__init__.py注册到Flask()中。</p>
<p>特点：</p>
<ul>
<li>应用较为独立，仅共享配置和模型等等；</li>
<li>更为灵活</li>
</ul>
<p>综上所述一般绝大部分的项目就用功能式的架构就会满足需要了。</p>
<h2 id="如何使用蓝图重构一个项目"><a href="#如何使用蓝图重构一个项目" class="headerlink" title="如何使用蓝图重构一个项目"></a>如何使用蓝图重构一个项目</h2><p>Step 1：分区式还是功能式？<br>这个应用由关联较小的各部分构成。模板和静态文件不太可能在蓝图间共享，所以我们将使用分区式结构。<br>Step 2：分而治之<br>注意 在你对你的应用大刀阔斧之前，把一切提交到版本控制。你不会接受对任何有用的东西的意外删除。</p>
<p>接下来我们将继续前进，为我们的新应用创建目录树。从为每一个蓝图创建一个目录开始吧。然后整体复制views.py，static&#x2F;和templates&#x2F;到每一个蓝图文件夹。接着你可以从顶级目录删除掉它们了。</p>
<p>Step 3：大扫除<br>现在我们可以到每一个蓝图中，移除无关的视图，静态文件和模板。你在这一阶段的处境很大程度上取决于一开始你是怎么组织你的应用的。</p>
<p>最终结果应该是：每个蓝图有一个views.py包括了蓝图里的所有视图，没有两个蓝图对同一个路由定义了视图；每一个templates&#x2F;文件夹应该只包括该蓝图所需的模板；每一个static&#x2F;文件夹应该只包括该蓝图所需的静态文件。</p>
<p>注意 趁此机会消除所有不必要的import。很容易忽略掉他们的存在，但他们会拥塞你的代码，甚至拖慢你的应用。</p>
<p>Step 4：蓝图<br>在这一部分我们把文件夹转换成蓝图。关键在于__init__.py文件。作为开始，让我们看一下API蓝图的定义。</p>
<p>Step 5：大功告成<br>现在我们的应用已经比只有单个臃肿的views.py的时候更加模块化了。</p>
<p>总结:</p>
<ul>
<li>一个蓝图包括了可以作为独立应用的视图，模板，静态文件和其他插件。</li>
<li>蓝图是组织你的应用的好办法。</li>
<li>在分区式架构下，每个蓝图对应你的应用的一个部分。</li>
<li>在功能式架构下，每个蓝图就只是视图的集合。所有的模板和静态文件都放在一块。</li>
<li>要使用蓝图，你需要定义它，并在应用中用Flask.register_blueprint()注册它。</li>
<li>你可以给一个蓝图中的所有路由定义一个动态URL前缀。</li>
<li>你也可以给蓝图中的所有路由定义一个动态子域名。</li>
<li>仅需五步走，你可以用蓝图重构一个应用。</li>
</ul>
<h2 id="一些有意思的事情"><a href="#一些有意思的事情" class="headerlink" title="一些有意思的事情"></a>一些有意思的事情</h2><h3 id="json和jsonify的差异"><a href="#json和jsonify的差异" class="headerlink" title="json和jsonify的差异"></a>json和jsonify的差异</h3><p>字符串转json对象，使用json.loads()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 字符串转json，注意（key与value必须是双引号）</span></span><br><span class="line">str1 = <span class="string">&#x27;&#123;&quot;a&quot;:1, &quot;b&quot;:&quot;2&quot;&#125;&#x27;</span></span><br><span class="line">j1 = json.loads(str1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(j1), j1)  <span class="comment"># &lt;class &#x27;dict&#x27;&gt; &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;2&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="string">&#x27;[&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:&quot;2&quot;&#125;]&#x27;</span></span><br><span class="line">j2 = json.loads(str2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(j2), j2)  <span class="comment"># &lt;class &#x27;list&#x27;&gt; [&#123;&#x27;a&#x27;: 1&#125;, &#123;&#x27;a&#x27;: &#x27;2&#x27;&#125;]</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> j2:</span><br><span class="line">    <span class="built_in">print</span>(obj[<span class="string">&quot;a&quot;</span>])  <span class="comment"># 1  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可见通过json的loads方法可将标准json字符串转成字典对象或字典集合</span></span><br><span class="line"><span class="comment"># 下面是嵌套组合的字符串也可以通过loads方法转换</span></span><br><span class="line">f = <span class="string">&#x27;&#123;&quot;a&quot;:1, &quot;b&quot;: [&#123;&quot;b_1&quot;: &quot;b1&quot;&#125;, &#123;&quot;b_1&quot;: &quot;b1&quot;&#125;]&#125;&#x27;</span></span><br><span class="line">l = json.loads(f)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(l), l)  <span class="comment"># &lt;class &#x27;dict&#x27;&gt; &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: [&#123;&#x27;b_1&#x27;: &#x27;b1&#x27;&#125;, &#123;&#x27;b_1&#x27;: &#x27;b1&#x27;&#125;]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(l[<span class="string">&quot;b&quot;</span>], <span class="built_in">type</span>(l[<span class="string">&quot;b&quot;</span>]))  <span class="comment"># [&#123;&#x27;b_1&#x27;: &#x27;b1&#x27;&#125;, &#123;&#x27;b_1&#x27;: &#x27;b1&#x27;&#125;] &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt; &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;2&#x27;</span>&#125;]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt; &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: [&#123;<span class="string">&#x27;b_1&#x27;</span>: <span class="string">&#x27;b1&#x27;</span>&#125;, &#123;<span class="string">&#x27;b_1&#x27;</span>: <span class="string">&#x27;b1&#x27;</span>&#125;]&#125;</span><br><span class="line">[&#123;<span class="string">&#x27;b_1&#x27;</span>: <span class="string">&#x27;b1&#x27;</span>&#125;, &#123;<span class="string">&#x27;b_1&#x27;</span>: <span class="string">&#x27;b1&#x27;</span>&#125;] &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>json对象转字符串，使用json.dumps()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">obj = &#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">objStr = json.dumps(obj)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(objStr), objStr)  <span class="comment"># &lt;class &#x27;str&#x27;&gt; &#123;&quot;a&quot;: 1, &quot;b&quot;: &quot;2&quot;&#125;</span></span><br><span class="line">arr = [</span><br><span class="line">    &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line">arrStr = json.dumps(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(arrStr), arrStr)  <span class="comment"># &lt;class &#x27;str&#x27;&gt; [&#123;&quot;a&quot;: 1&#125;, &#123;&quot;a&quot;: &quot;2&quot;&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt; &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt; [&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;, &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>通过jsonify()将dict转为json字符串</p>
<p>简单，快速是Flask自带的模块jsonify。 功能类似于<code>json.dumps()</code>，但是会把返回的<code>Content-Type从text/html</code>转换成带json特征的 <code>application/json</code>。</p>
<p><img src="https://img.econow.cn/medivh/1659598907405.png" alt="1659598907405.png"></p>
<p>总结：</p>
<ul>
<li>json.loads() 把 json 字符串 转成 python 数据类型</li>
<li>json.load(python数据类型,文件句柄) 把 json 文件 转成 python 数据类型</li>
<li>json.dumps() 把 python 数据类型 转成 json 字符串</li>
<li>json.dump(文件句柄) 把 python 数据类型 写入到 json 文件中</li>
</ul>
<p>个人倾向在flask项目中使用jsonify()，简捷。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%20(%E4%BA%8C).html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%20(%E4%BA%8C).html" class="post-title-link" itemprop="url">深入理解StatefulSet（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">云原生</span></a>
        </span>
    </span>

  
    <span id="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%20(%E4%BA%8C).html" class="post-meta-item leancloud_visitors" data-flag-title="深入理解StatefulSet（二）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了 StatefulSet 的基础原理，但是只使用了应用之一的拓扑状态。这一篇将会介绍使用存储状态。</p>
<h3 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h3><p>应用的多个实例分别绑定了不同的存储数据。典型例子就是一个数据库应用的多个存储实例。StatefulSet 的核心功能就是通过某种方式记录这些状态，然后在Pod被重新创建时，能够为新Pod恢复这些状态。比较典型之一，Redis的主从架构。</p>
<h3 id="知识点解析"><a href="#知识点解析" class="headerlink" title="知识点解析"></a>知识点解析</h3><h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><p><img src="https://img.econow.cn/medivh/1649409054685.png" alt="1649409054685.png"></p>
<p>当我们启动多个redis实例的时候，他们相互之间就可以通过slaveof 命令形成主库和从库关系，之后会按照三个阶段完成数据的第一次同步。</p>
<ol>
<li>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立连接，并告诉主库即将建立连接，主库确认回复后，主从库间就可以开始同步了。</li>
<li>在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照RDB。</li>
<li>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成RDB文件发送后，就会把此时replocation buffer中修改操作发送给从库，从库再执行这些操作。这样一来，主从库就实现同步了。</li>
</ol>
<p>之后的同步如果不出现意外，都会采用增量的方式进行同步。</p>
<p>此外，有一些其他注意事项：</p>
<ul>
<li>为避免数据混乱，从节点是默认不允许写的</li>
<li>首次连接需要同步全量 RDB ，此后执行基于长连接的命令传播</li>
<li>建议使用 主-从-从 的级联架构，减轻每一个从节点连进来主节点都要进行一次生成RDB和传输RDB的压力</li>
<li>从节点断连后，如短时间内重新连入，则只需要进行增量更新。如未同步的数据过多 （repl_backlog_buffer中未同步的数据已被覆盖），则需要进行一次全量同步</li>
</ul>
<p>综上所述，Redis主从架构的基本原理在于同步和保持可用性的持久化。</p>
<h4 id="PV-PVC"><a href="#PV-PVC" class="headerlink" title="PV&#x2F;PVC"></a>PV&#x2F;PVC</h4><p>PV (PersistentVolume）是设置的存储，群集的一部分，也是一种资源。场景的PV有很多种，比如NAS、NFS和ceph等等。</p>
<p>PVC 是用户的存储请求，和Pod类似。Pod消耗节点资源，PVC消耗PV资源。并且可以设置请求特定的大小和模式。其主要作用是确保相关Pod正在使用的PVC不会从系统中删除。因为如果被移除的话会导致数据丢失。</p>
<p>PV访问模式:</p>
<ol>
<li>ReadWriteOnce——该卷可以被单个节点以读&#x2F;写模式挂载</li>
<li>ReadOnlyMany——该卷可以被多个节点以只读模式挂载</li>
<li>ReadWriteMany——该卷可以被多个节点以读&#x2F;写模式挂载</li>
</ol>
<p>在命令行中，访问模式缩写为：</p>
<ul>
<li>RWO - ReadWriteOnce</li>
<li>ROX - ReadOnlyMany</li>
<li>RWX - ReadWriteMany</li>
</ul>
<p>PVC回收策略：</p>
<ol>
<li>Retain（保留）——手动回收</li>
<li>Recycle（回收）——基本擦除（ rm -rf &#x2F;thevolume&#x2F;* ）</li>
<li>Delete（删除）——关联的存储资产（例如 AWS EBS、GCE PD、Azure Disk 和 OpenStack Cinder 卷）</li>
</ol>
<p>将被删除当前，只有 NFS 和 HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk 和 Cinder 卷支持删除策略。</p>
<p>PVC的状态：</p>
<ol>
<li>Available（可用）——一块空闲资源还没有被任何声明绑定</li>
<li>Bound（已绑定）——卷已经被声明绑定</li>
<li>Released（已释放）——声明被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）——该卷的自动回收失败</li>
</ol>
<p>使用PVC时需要注意，在每个node节点上都需要安装nfs-utis，不然会报错，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  Warning  FailedMount  54s (x8 over 117s)  kubelet            MountVolume.SetUp failed <span class="keyword">for</span> volume <span class="string">&quot;redis01&quot;</span> : mount failed: <span class="built_in">exit</span> status 32</span><br><span class="line">Mounting <span class="built_in">command</span>: mount</span><br><span class="line">Mounting arguments: -t nfs 192.168.1.10:/Public/redis-master /var/lib/kubelet/pods/0645dd81-4bba-4fd5-bf08-ffeb72367254/volumes/kubernetes.io~nfs/redis01</span><br><span class="line">Output: mount: wrong fs <span class="built_in">type</span>, bad option, bad superblock on 192.168.1.10:/Public/redis-master,</span><br><span class="line">       missing codepage or helper program, or other error</span><br><span class="line">       (<span class="keyword">for</span> several filesystems (e.g. nfs, cifs) you might</span><br><span class="line">       need a /sbin/mount.&lt;<span class="built_in">type</span>&gt; helper program)</span><br><span class="line"></span><br><span class="line">       In some cases useful info is found <span class="keyword">in</span> syslog - try</span><br><span class="line">       dmesg | <span class="built_in">tail</span> or so.</span><br></pre></td></tr></table></figure>

<h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><h4 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: redis01 <span class="comment"># PV名字</span></span><br><span class="line">spec:</span><br><span class="line">  storageClassName: redis <span class="comment">#卷的名字</span></span><br><span class="line">  persistentVolumeReclaimPolicy: Retain <span class="comment">#回收模式</span></span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce <span class="comment"># 访问模式</span></span><br><span class="line">  nfs:</span><br><span class="line">    path: /Public/redis-master <span class="comment"># NFS目录</span></span><br><span class="line">    server: 192.168.1.10 <span class="comment"># nfs 信息</span></span><br><span class="line">----</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: redis02</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: redis</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  nfs:</span><br><span class="line">    path: /Public/redis2</span><br><span class="line">    server: 192.168.1.10</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: redis03</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: redis</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  nfs:</span><br><span class="line">    path: /Public/redis3</span><br><span class="line">    server: 192.168.1.10</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@uat-master ~]# kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                               STORAGECLASS   REASON   AGE</span><br><span class="line">redis01   1Gi        RWO            Retain           Bound    default/redis-data-redis-master-0   redis                   60m</span><br><span class="line">redis02   1Gi        RWO            Retain           Bound    default/redis-data-redis-slave-0    redis                   60m</span><br><span class="line">redis03   1Gi        RWO            Retain           Bound    default/redis-data-redis-slave-1    redis                   60m</span><br></pre></td></tr></table></figure>

<h4 id="redis配置文件"><a href="#redis配置文件" class="headerlink" title="redis配置文件"></a>redis配置文件</h4><p>redis-cm.yaml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-config</span><br><span class="line">data:</span><br><span class="line">  master.conf: |</span><br><span class="line">        port 6379</span><br><span class="line">  slave.conf: |</span><br><span class="line">    port 6379</span><br><span class="line">    slaveof redis-master-0.redis-master 6379</span><br></pre></td></tr></table></figure>

<p>redis-master-sts.yaml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: redis-master</span><br><span class="line">  serviceName: redis-master</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: redis-master</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: redis</span><br><span class="line">          image: redis</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">            - sh</span><br><span class="line">          args:</span><br><span class="line">            - -c</span><br><span class="line">            - redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 6379</span><br><span class="line">              name: masterport</span><br><span class="line">              protocol: TCP</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /usr/local/etc/redis</span><br><span class="line">              name: conf</span><br><span class="line">            - name: redis-data</span><br><span class="line">              mountPath: /data</span><br><span class="line">      volumes:</span><br><span class="line">        - name: conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: redis-config</span><br><span class="line">            items:</span><br><span class="line">              - key: master.conf</span><br><span class="line">                path: redis.conf</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: redis-data</span><br><span class="line">    spec: <span class="comment"># 必须满足下面两个，pod才会绑定到pv上面</span></span><br><span class="line">      accessModes: [ <span class="string">&quot;ReadWriteOnce&quot;</span> ] <span class="comment">#读取模式</span></span><br><span class="line">      storageClassName: <span class="string">&quot;redis&quot;</span> <span class="comment"># 绑定pv名字为redis</span></span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure>

<p>redis-slave-sts.yaml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-slave</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: redis-slave</span><br><span class="line">  serviceName: redis-slave</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: redis-slave</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: redis</span><br><span class="line">          image: redis</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">            - sh</span><br><span class="line">          args:</span><br><span class="line">            - -c</span><br><span class="line">            - redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 6379</span><br><span class="line">              name: redis-slave</span><br><span class="line">              protocol: TCP</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /usr/local/etc/redis</span><br><span class="line">              name: conf</span><br><span class="line">            - name: redis-data</span><br><span class="line">              mountPath: /data</span><br><span class="line">      volumes:</span><br><span class="line">        - name: conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: redis-config</span><br><span class="line">            items:</span><br><span class="line">              - key: slave.conf</span><br><span class="line">                path: redis.conf</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: redis-data</span><br><span class="line">    spec: <span class="comment"># 必须满足下面两个，pod才会绑定到pv上面</span></span><br><span class="line">      accessModes: [ <span class="string">&quot;ReadWriteOnce&quot;</span> ] <span class="comment"># 读取模式</span></span><br><span class="line">      storageClassName: <span class="string">&quot;redis&quot;</span> <span class="comment"># 绑定pv名字为redis</span></span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure>

<p>master-head.yaml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: redis-master</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">    - port: 6379</span><br><span class="line">      targetPort: 6379</span><br><span class="line">      name: redis</span><br></pre></td></tr></table></figure>

<p>slave-head.yaml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-slave</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 6379</span><br><span class="line">      targetPort: 6379</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: redis-slave</span><br><span class="line">  clusterIP: None</span><br></pre></td></tr></table></figure>

<p>上述编排文件都apply后，检查：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@uat-master ~]<span class="comment"># kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                               STORAGECLASS   REASON   AGE</span><br><span class="line">redis01   1Gi        RWO            Retain           Bound    default/redis-data-redis-master-0   redis                   72m</span><br><span class="line">redis02   1Gi        RWO            Retain           Bound    default/redis-data-redis-slave-0    redis                   72m</span><br><span class="line">redis03   1Gi        RWO            Retain           Bound    default/redis-data-redis-slave-1    redis                   72m</span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl get pvc</span></span><br><span class="line">NAME                        STATUS   VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">redis-data-redis-master-0   Bound    redis01   1Gi        RWO            redis          54m</span><br><span class="line">redis-data-redis-slave-0    Bound    redis02   1Gi        RWO            redis          51m</span><br><span class="line">redis-data-redis-slave-1    Bound    redis03   1Gi        RWO            redis          40m</span><br></pre></td></tr></table></figure>

<p>登录master pod</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@uat-master ~]<span class="comment"># kubectl exec -it po/redis-master-0 -- bash</span></span><br><span class="line">root@redis-master-0:/data<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 196 Apr  8 09:01 dump.rdb</span><br><span class="line">root@redis-master-0:/data<span class="comment"># pwd</span></span><br><span class="line">/data</span><br><span class="line">root@redis-master-0:/data<span class="comment"># df -h</span></span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">overlay                             46G   15G   31G  33% /</span><br><span class="line">tmpfs                               64M     0   64M   0% /dev</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">192.168.1.10:/Public/redis-master  1.3T  505G  816G  39% /data</span><br><span class="line">/dev/mapper/centos-root             46G   15G   31G  33% /etc/hosts</span><br><span class="line">shm                                 64M     0   64M   0% /dev/shm</span><br><span class="line">tmpfs                              2.0G   12K  2.0G   1% /run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /proc/acpi</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /proc/scsi</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /sys/firmware</span><br><span class="line">root@redis-master-0:/data<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 196 Apr  8 09:01 dump.rdb</span><br><span class="line">root@redis-master-0:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=10.200.96.163,port=6379,state=online,offset=3668,lag=1</span><br><span class="line">slave1:ip=10.200.96.159,port=6379,state=online,offset=3668,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:33c2abd3e8ee089411772f5b64790d9463400872</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:3668</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:3668</span><br><span class="line">127.0.0.1:6379&gt; info Keyspace</span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=2,expires=0,avg_ttl=0</span><br></pre></td></tr></table></figure>

<p>在显示信息中看到了slave节点的信息，而且生成了rdb文件。之后检查nfs上也存在对应的文件，无论是master pod还是slave pod对应的目录。</p>
<p>解析DNS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># nslookup redis-slave.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      redis-slave.default.svc.cluster.local</span><br><span class="line">Address 1: 10.200.128.144 redis-slave-0.redis-slave.default.svc.cluster.local</span><br><span class="line">Address 2: 10.200.96.162 redis-slave-1.redis-slave.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">/ <span class="comment"># nslookup redis-master.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      redis-master.default.svc.cluster.local</span><br><span class="line">Address 1: 10.200.128.143 redis-master-0.redis-master.default.svc.cluster.local</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>稳定的持久化存储，Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li>
<li>稳定的网络标识符，Pod重新调度后PodName和HostName不变</li>
<li>有序部署和扩展</li>
<li>有序收缩</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%EF%BC%88%E4%B8%80%EF%BC%89.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%EF%BC%88%E4%B8%80%EF%BC%89.html" class="post-title-link" itemprop="url">深入理解StatefulSet（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">云原生</span></a>
        </span>
    </span>

  
    <span id="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%EF%BC%88%E4%B8%80%EF%BC%89.html" class="post-meta-item leancloud_visitors" data-flag-title="深入理解StatefulSet（一）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先聊一下Deployment，一个应用的所有Pod是完全一样的。它们相互之间没有顺序，也无所谓运行在哪台宿主机上，需要的时候就创建，不需要的时候就可以中止任意一个Pod。</p>
<p>有些分布式应用，在多个实例之间存有依赖关系，比如主从、主备关系。还有些数据库存储类应用，在本地磁盘会存放一些数据，而实例一旦被杀掉，即使重建出来，实例和数据之间的对应关系都已经丢失。</p>
<p>所以实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，被称为有状态应用（Stateful Appication）。</p>
<h3 id="Statefulset"><a href="#Statefulset" class="headerlink" title="Statefulset"></a>Statefulset</h3><p>StatefulSet 将应用状态抽象为两种情况：</p>
<ol>
<li>拓扑状态。意味着应用之间的多个实例之间不是对等关系。这些应用必须按照某些顺序启动，并且新创建的Pod，必须和原来的网络标识一样，这样原来的访问者才能使用同样的方法，访问到这个新的Pod。</li>
<li>存储状态。这种情况意味着，应用的多个实例分别绑定了不同的存储数据。典型例子就是一个数据库应用的多个存储实例。</li>
</ol>
<p>StatefulSet 的核心功能就是通过某种方式记录这些状态，然后在Pod被重新创建时，能够为新Pod恢复这些状态。</p>
<p>StatefulSet中每个Pod的DNS格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local</span><br></pre></td></tr></table></figure>

<ul>
<li>serviceName 为Headless Service name</li>
<li>0…N-1 为Pod的序号，从0开始</li>
<li>statefulSetName 为StatefulSet name</li>
<li>namespace 为服务所在的namespace</li>
<li>cluster.local为Cluster Domain</li>
</ul>
<p>图解</p>
<p><img src="https://img.econow.cn/medivh/1649399502095.png" alt="1649399502095.png"></p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p><img src="https://img.econow.cn/medivh/1649399564902.png" alt="1649399564902.png"></p>
<h4 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h4><p><img src="https://img.econow.cn/medivh/1649399581462.png" alt="1649399581462.png"></p>
<h4 id="持久卷的创建和删除"><a href="#持久卷的创建和删除" class="headerlink" title="持久卷的创建和删除"></a>持久卷的创建和删除</h4><p><img src="https://img.econow.cn/medivh/1649399652857.png" alt="1649399652857.png"></p>
<ol>
<li>增加副本时，会创建对应的pvc；</li>
<li>减少副本时，从高索引值的Pod名开始删除Pod，但是PVC不会被删除，需要手动释放；</li>
<li>当先收缩再扩容时，重建后的Pod实例会绑定到对应序号的PVC上。</li>
</ol>
<h3 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h3><p>首先聊一下Service是如何被访问的呢？</p>
<ol>
<li>以service的VIP模式。比如访问10.0.23.1 这个service的IP地址时，10.0.23.1就是一个VIP，会把请求转发到该service所代理的某一个Pod上。</li>
<li>以service的DNS方式。比如访问“my-svc.my-namspace.svc.cluster.local”这条DNS记录，就可以访问到名为my-svc的service所搭理的某一个Pod。</li>
</ol>
<p>针对于第二种方式，具体还可以分为两种处理方法：</p>
<ol>
<li>Normal Service。访问“my-svc.my-namspace.svc.cluster.local” 解析到的，正是my-svc这个service的VIP，后面的流程和VIP的方式一致</li>
<li>Headless Service。访问“my-svc.my-namspace.svc.cluster.local”解析到的，直接就是my-svc代理的某一个Pod的IP地址。这里的区别在于<strong>Headless Service 不需要分配一个VIP，而是直接以DNS记录的方式解析出被代理POD的IP地址。</strong></li>
</ol>
<p>比如<code>eureka-0.register-server.test.svc.cluster.local</code>。</p>
<p>标签规则：</p>
<ol>
<li>spec.containers.name 容器的名字，如何配置基本无影响</li>
<li>template.metadata.labels 设定的label，注意和selector保持一致。并且该标签需要和headless 中的selector，以及nodePort中的selector保持一致。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>创建一个service</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    name: web</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br></pre></td></tr></table></figure>

<p>再创建一个StatefulSet</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.14.2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br></pre></td></tr></table></figure>

<h4 id="部署eureka集群"><a href="#部署eureka集群" class="headerlink" title="部署eureka集群"></a>部署eureka集群</h4><p>eureka集群部署的主要难点在于如何指定 <code>eureka.client.service-url.defaultZone</code>的值？</p>
<p>对于上述问题可以通过headless机制，不给cluster分配IP，而是通过域名访问服务来解决。在application.yaml文件中使用环境变量，传值给eueka。</p>
<blockquote>
<p>每个eureka会注册到另外的eureka上，也就是eureka.client.serviceUrl.dafaultZone；<br>通过StatefulSet，可以知道每个eureka的name；<br>通过Headless，可以访问到每个eureka；<br>所以eureka.client.serviceUrl.defaultZone的值就是<code>http://eureka-0.eureka:8000/eureka/,http://eureka-1.eureka:8000/eureka/,http://eureka-2.eureka:8000/eureka/</code></p>
</blockquote>
<p>由于三个pod在同一个命名空间内，因此可以省略.namespace.svc.cluster.local。</p>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>application.yaml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name:  DiscoveryServer</span><br><span class="line">info:</span><br><span class="line">  version: <span class="variable">$project</span>.version$</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: <span class="variable">$&#123;POD_HOST_NAME&#125;</span>  <span class="comment">#设置eureka hostname</span></span><br><span class="line">    prefer-ip-address: <span class="literal">false</span> <span class="comment"># 使用服务名注册到eureka server</span></span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">true</span>  <span class="comment">#表示是否将自己注册在EurekaServer上，默认为true</span></span><br><span class="line">    fetch-registry: <span class="literal">true</span>  <span class="comment">#表示表示是否从EurekaServer获取注册信息，默认为true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: <span class="variable">$&#123;EUREKA_INSTANCE_LIST&#125;</span> <span class="comment">#这里在部署的时候会使用环境变量替换</span></span><br><span class="line">joy:</span><br><span class="line">    logback:</span><br><span class="line">      path: logs/EUREKA_INSTANCE_HOSTNAME</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是hostname要使用pod的主机名，否则会出现unavailable-replicas。此外还有其他可能：</p>
<ol>
<li>eureka.instance.preferIpAddress &#x3D; false</li>
<li>defaultZone 后面的eureka注册中心的地址要写成域名；</li>
<li>eureka.client.register-with-eureka的值要写为true</li>
<li>eureka.client.fetch-registry的值要写为true</li>
<li>eureka集群中多个eureka服务的spring.application.name的值要一致</li>
<li>eureka.instance.prefer-ip-address的值必须设置为false</li>
</ol>
<p>service.yaml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: eureka</span><br><span class="line">  labels:</span><br><span class="line">    service: eureka</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8761</span><br><span class="line">      targetPort: 8761</span><br><span class="line">      name: eureka</span><br><span class="line">  selector:</span><br><span class="line">    app: eureka</span><br></pre></td></tr></table></figure>

<p>StatefulSet.yaml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: eureka</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;eureka&quot;</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: eureka-pod</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: eureka-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - <span class="built_in">env</span>:</span><br><span class="line">        name: eureka</span><br><span class="line">        image: 192.168.1.232:5000/k8s/eureka:statefull</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">          - name: APP_NAME</span><br><span class="line">            value: <span class="string">&quot;eureka&quot;</span> <span class="comment"># statefulSet name</span></span><br><span class="line">          - name: POD_NAME</span><br><span class="line">            valueFrom:</span><br><span class="line">              fieldRef:</span><br><span class="line">                fieldPath: metadata.name</span><br><span class="line">          - name: POD_HOST_NAME</span><br><span class="line">            value: <span class="string">&quot;<span class="subst">$(POD_NAME)</span>.<span class="subst">$(APP_NAME)</span>.default.svc.cluster.local&quot;</span></span><br><span class="line">          - name: EUREKA_INSTANCE_LIST</span><br><span class="line">            value: <span class="string">&quot;http://eureka-0.<span class="subst">$(APP_NAME)</span>.default.svc.cluster.local:8761/eureka/,http://eureka-1.<span class="subst">$(APP_NAME)</span>.default.svc.cluster.local:8761/eureka/,http://eureka-2.<span class="subst">$(APP_NAME)</span>.default.svc.cluster.local:8761/eureka/&quot;</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8761</span><br><span class="line">        livenessProbe:</span><br><span class="line">          failureThreshold: 10</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /health</span><br><span class="line">            port: 8761</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          periodSeconds: 60</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          timeoutSeconds: 2</span><br><span class="line">        readinessProbe:</span><br><span class="line">          failureThreshold: 1</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /health</span><br><span class="line">            port: 8761</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 10</span><br><span class="line">          periodSeconds: 3</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          timeoutSeconds: 2</span><br></pre></td></tr></table></figure>

<p>传递三个变量：</p>
<ol>
<li>APP_NAME 取值于metadata.name</li>
<li>POD_NAME 取值于metadata.name</li>
<li>POD_HOST_NAME 拼接单个Pod的主机名</li>
<li>EUREKA_INSTANCE_LIST 由Pod的域名拼接组成</li>
</ol>
<p>创建完成后会出现三个带序号的Pod和statfulSet，这个时候请求<code>eureka.default.svc.cluster.local</code>就可以使用服务了。但是如果想在集群外访问，可以使用nodeport的方式暴露。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: eureka-node-port</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 31331</span><br><span class="line">    targetPort: 8761</span><br><span class="line">    nodePort: 31331</span><br><span class="line">  selector:</span><br><span class="line">    app: eureka-pod</span><br></pre></td></tr></table></figure>

<p><img src="https://img.econow.cn/medivh/1649398888400.png" alt="1649398888400.png"></p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="headless-service和普通service的区别"><a href="#headless-service和普通service的区别" class="headerlink" title="headless service和普通service的区别"></a>headless service和普通service的区别</h3><ul>
<li>headless 不分配clusterIP，配置<code>clusterIP: None</code></li>
<li>headless service可以通过解析service的DNS，返回所有Pod的地址和DNS</li>
<li>普通service，只能通过解析service的DNS返回service的CLusterIP</li>
</ul>
<h3 id="statefulSet和Deployment的区别"><a href="#statefulSet和Deployment的区别" class="headerlink" title="statefulSet和Deployment的区别"></a>statefulSet和Deployment的区别</h3><ul>
<li>statefulSet 的Pod有DNS地址，通过解析Pod的DNS可以返回Pod的IP</li>
<li>Deployment下的Pod没有DNS</li>
</ul>
<h3 id="普通service解析"><a href="#普通service解析" class="headerlink" title="普通service解析"></a>普通service解析</h3><p>Service的ClusterIP原理：<br>一个service可以对应一组endpoints，client访问ClusterIP，通过iptables或ipvs转发到real server。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取svc,clusterIP为10.105.146.146</span></span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)           AGE</span><br><span class="line">eureka-node-port   NodePort    10.105.146.146   &lt;none&gt;        31331:31331/TCP   8m7s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看svc详情</span></span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl describe svc eureka-node-port</span></span><br><span class="line">Name:                     eureka-node-port</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   &lt;none&gt;</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 app=eureka</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP Families:              &lt;none&gt;</span><br><span class="line">IP:                       10.105.146.146</span><br><span class="line">IPs:                      10.105.146.146</span><br><span class="line">Port:                     &lt;<span class="built_in">unset</span>&gt;  31331/TCP</span><br><span class="line">TargetPort:               8761/TCP</span><br><span class="line">NodePort:                 &lt;<span class="built_in">unset</span>&gt;  31331/TCP</span><br><span class="line">Endpoints:                10.200.128.133:8761,10.200.128.134:8761,10.200.128.137:8761</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试解析</span></span><br><span class="line"></span><br><span class="line">/ <span class="comment"># nslookup eureka-node-port.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      eureka-node-port.default.svc.cluster.local</span><br><span class="line">Address 1: 10.105.146.146 eureka-node-port.default.svc.cluster.local</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上所述，DNS查询时只会返回service的clusterIP，具体client访问的是哪个real server，由iptabels或者ipvs决定。</p>
<h3 id="headless-service解析"><a href="#headless-service解析" class="headerlink" title="headless service解析"></a>headless service解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取svc</span></span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)           AGE</span><br><span class="line">eureka             ClusterIP   None             &lt;none&gt;        8761/TCP          27m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情</span></span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl describe svc eureka</span></span><br><span class="line">Name:              eureka</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            service=eureka</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=eureka</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Families:       &lt;none&gt;</span><br><span class="line">IP:                None</span><br><span class="line">IPs:               None</span><br><span class="line">Port:              eureka  8761/TCP</span><br><span class="line">TargetPort:        8761/TCP</span><br><span class="line">Endpoints:         10.200.128.133:8761,10.200.128.134:8761,10.200.128.137:8761</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试解析</span></span><br><span class="line">/ <span class="comment"># nslookup eureka.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      eureka.default.svc.cluster.local</span><br><span class="line">Address 1: 10.200.128.134 eureka-1.eureka.default.svc.cluster.local</span><br><span class="line">Address 2: 10.200.128.133 eureka-0.eureka.default.svc.cluster.local</span><br><span class="line">Address 3: 10.200.128.137 eureka-2.eureka.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析单独pod的DNS记录</span></span><br><span class="line"></span><br><span class="line">/ <span class="comment"># nslookup eureka-2.eureka.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      eureka-2.eureka.default.svc.cluster.local</span><br><span class="line">Address 1: 10.200.128.137 10-200-128-137.eureka-node-port.default.svc.cluster.local</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上所述，DNS查询会返回所有的endpoint，通过解析Pod的DNS记录，也能返回Pod的IP。</p>
<h3 id="headless-service使用场景"><a href="#headless-service使用场景" class="headerlink" title="headless service使用场景"></a>headless service使用场景</h3><ul>
<li>自助选择权，client可以自己决定使用哪个real server，可以通过DNS来获取real server信息。</li>
<li>headless service关联的每个pod，都会有对应的DNS域名，这样Pod直接可以互相访问。这样对于一些集训类型的应用就可以解决身份是吧的问题了。</li>
</ul>
<h3 id="为什么要用headless-statefulSet部署有状态应用"><a href="#为什么要用headless-statefulSet部署有状态应用" class="headerlink" title="为什么要用headless+statefulSet部署有状态应用"></a>为什么要用headless+statefulSet部署有状态应用</h3><ol>
<li>headless service会为关联的Pod分配一个域 <code>&lt;service name&gt;.$&lt;namespace name&gt;.svc.cluster.local</code></li>
<li>statefulSet 会为关联的Pod保持一个不变的Pod Name <code>$(statefulSet name)-$(pod序号)</code></li>
<li>statefulSet会为关联的Pod分配一个dnsName <code>$&lt;Pod Name&gt;.$&lt;service name&gt;.$&lt;namespace name&gt;.svc.cluster.local</code></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E5%9F%BA%E4%BA%8Eregistry%E7%9A%84Harbor%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%9F%BA%E4%BA%8Eregistry%E7%9A%84Harbor%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2.html" class="post-title-link" itemprop="url">基于registry的Harbor镜像仓库部署</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">云原生</span></a>
        </span>
    </span>

  
    <span id="/%E5%9F%BA%E4%BA%8Eregistry%E7%9A%84Harbor%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2.html" class="post-meta-item leancloud_visitors" data-flag-title="基于registry的Harbor镜像仓库部署" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Harbor 是 Vmwar 公司开源的 企业级的 Docker Registry 管理项目 它主要 提供 Dcoker Registry 管理UI，可基于角色访问控制, AD&#x2F;LDAP 集成，日志审核等功能，完全的支持中文。 Harbor 的所有组件都在 Dcoker 中部署，所以 Harbor 可使用 Docker Compose 快速部署。</p>
</blockquote>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Harbor，是一个英文单词，意思是港湾，港湾是干什么的呢，就是停放货物的，而货物呢，是装在集装箱中的，说到集装箱，就不得不提到Docker容器，因为docker容器的技术正是借鉴了集装箱的原理。所以，Harbor正是一个用于存储Docker镜像的企业级Registry服务。</p>
<p>Registry是Dcoker官方的一个私有仓库镜像，可以将本地的镜像打标签进行标记然后push到以Registry起的容器的私有仓库中。企业可以根据自己的需求，使用Dokcerfile生成自己的镜像，并推到私有仓库中，这样可以大大提高拉取镜像的效率。</p>
<h3 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h3><p>Harbor和Registry都是Docker的镜像仓库，但是Harbor作为更多企业的选择，是因为相比较于Regisrty来说，它具有很多的优势。</p>
<ul>
<li>1.提供分层传输机制，优化网络传输<br>Docker镜像是是分层的，而如果每次传输都使用全量文件(所以用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定传输的对象。</li>
<li>2.提供WEB界面，优化用户体验<br>只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界面可以支持登陆、搜索功能，包括区分公有、私有镜像。</li>
<li>3.支持水平扩展集群<br>当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。</li>
<li>4.良好的安全机制<br>企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。</li>
<li>5.Harbor提供了基于角色的访问控制机制，并通过项目来对镜像进行组织和访问权限的控制。kubernetes中通过namespace来对资源进行隔离，在企业级应用场景中，通过将两者进行结合可以有效将kubernetes使用的镜像资源进行管理和访问控制，增强镜像使用的安全性。尤其是在多租户场景下，可以通过租户、namespace和项目相结合的方式来实现对多租户镜像资源的管理和访问控制。</li>
</ul>
<h3 id="2、核心组件"><a href="#2、核心组件" class="headerlink" title="2、核心组件"></a>2、核心组件</h3><ul>
<li>Proxy：他是一个nginx的前端代理，代理Harbor的registry,UI, token等服务。</li>
<li>db：负责储存用户权限、审计日志、Dockerimage分组信息等数据。</li>
<li>UI：提供图形化界面，帮助用户管理registry上的镜像, 并对用户进行授权。</li>
<li>jobsevice：jobsevice是负责镜像复制工作的，他和registry通信，从一个registry pull镜像然后push到另一个registry，并记录job_log。</li>
<li>Adminserver：是系统的配置管理中心附带检查存储用量，ui和jobserver启动时候回需要加载adminserver的配置。</li>
<li>Registry：镜像仓库，负责存储镜像文件。</li>
<li>Log：为了帮助监控Harbor运行，负责收集其他组件的log，供日后进行分析。</li>
</ul>
<h2 id="二、安装部署"><a href="#二、安装部署" class="headerlink" title="二、安装部署"></a>二、安装部署</h2><h3 id="1、环境要求"><a href="#1、环境要求" class="headerlink" title="1、环境要求"></a>1、环境要求</h3><h4 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h4><table>
<thead>
<tr>
<th>Resource</th>
<th>Capacity</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>minimal 2 CPU</td>
<td>4 CPU is preferred</td>
</tr>
<tr>
<td>Mem</td>
<td>minimal 4GB</td>
<td>8GB is preferred</td>
</tr>
<tr>
<td>Disk</td>
<td>minimal 40GB</td>
<td>160GB is preferred</td>
</tr>
</tbody></table>
<h4 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h4><table>
<thead>
<tr>
<th>Software</th>
<th>Version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Python</td>
<td>version 2.7 or higher</td>
<td>Note that you may have to install Python on Linux distributions (Gentoo, Arch) that do not come with a Python interpreter installed by default</td>
</tr>
<tr>
<td>Docker engine</td>
<td>version 1.10 or higher</td>
<td>For installation instructions, please refer to: <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/">https://docs.docker.com/engine/installation/</a></td>
</tr>
<tr>
<td>Docker Compose</td>
<td>version 1.6.0 or higher</td>
<td>For installation instructions, please refer to: <a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></td>
</tr>
<tr>
<td>Openssl</td>
<td>latest is preferred</td>
<td>Generate certificate and keys for Harbor</td>
</tr>
</tbody></table>
<h4 id="Network-ports"><a href="#Network-ports" class="headerlink" title="Network ports"></a>Network ports</h4><table>
<thead>
<tr>
<th>Port</th>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>443</td>
<td>HTTPS</td>
<td>Harbor portal and core API will accept requests on this port for https protocol</td>
</tr>
<tr>
<td>4443</td>
<td>HTTPS</td>
<td>Connections to the Docker Content Trust service for Harbor, only needed when Notary is enabled</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>Harbor portal and core API will accept requests on this port for http protocol</td>
</tr>
</tbody></table>
<h4 id="Docker-相关"><a href="#Docker-相关" class="headerlink" title="Docker 相关"></a>Docker 相关</h4><p>安装docker-compose</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install python-pip</span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>

<h3 id="2、安装方式"><a href="#2、安装方式" class="headerlink" title="2、安装方式"></a>2、安装方式</h3><h4 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h4><p>该方式从Docker hub下载Harbor相关镜像，安装包较小。</p>
<h4 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h4><ul>
<li>正常安装版 <a target="_blank" rel="noopener" href="https://img.econow.cn/harbor-offline-installer-v1.2.2.tgz">https://img.econow.cn/harbor-offline-installer-v1.2.2.tgz</a> 推荐使用此方式靠谱。</li>
<li>github下载最新版 <a target="_blank" rel="noopener" href="https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.5.tgz">Harbor offline installer</a></li>
</ul>
<h3 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src</span><br><span class="line">wget https://img.econow.cn/harbor-offline-installer-v1.2.2.tgz](https://img.econow.cn/harbor-offline-installer-v1.2.2.tgz</span><br><span class="line">tar -zxvf  harbor-offline-installer-v1.2.2.tgz -C /opt/harbor</span><br></pre></td></tr></table></figure>

<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>vim harbor.cfg</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Configuration file of Harbor</span></span><br><span class="line"><span class="comment"># hostname 设置访问地址，支持IP，域名，主机名，禁止设置127.0.0.1</span></span><br><span class="line"><span class="comment"># 必须修改！！！</span></span><br><span class="line">hostname = 内网ip</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 访问协议，可设置 http,https</span></span><br><span class="line">ui_url_protocol = http</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 邮件通知, 配置邮件通知。</span></span><br><span class="line">email_server = smtp.mydomain.com</span><br><span class="line">email_server_port = 25</span><br><span class="line">email_username = sample_admin@mydomain.com</span><br><span class="line">email_password = abc</span><br><span class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># harbor WEB UI登陆使用的密码</span></span><br><span class="line">harbor_admin_password = Harbor12345</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 认证方式，这里支持多种认证方式，默认是 db_auth ，既mysql数据库存储认证。</span></span><br><span class="line"><span class="comment"># 这里还支持 ldap 以及 本地文件存储方式。</span></span><br><span class="line">auth_mode = db_auth</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql root 账户的 密码</span></span><br><span class="line">db_password = root123</span><br><span class="line"><span class="comment"># 默认密码应该是root，反正root123的时候我登不进去</span></span><br><span class="line">self_registration = on</span><br><span class="line">use_compressed_js = on</span><br><span class="line">max_job_workers = 3</span><br><span class="line">verify_remote_cert = on</span><br><span class="line">customize_crt = on</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 一些显示的设置.</span></span><br><span class="line">crt_country = CN</span><br><span class="line">crt_state = State</span><br><span class="line">crt_location = CN</span><br><span class="line">crt_organization = organization</span><br><span class="line">crt_organizationalunit = organizational unit</span><br><span class="line">crt_commonname = example.com</span><br><span class="line">crt_email = example@example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1、修改80端口为5000"><a href="#1、修改80端口为5000" class="headerlink" title="1、修改80端口为5000"></a>1、修改80端口为5000</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim docker-compose.yml</span></span><br><span class="line">proxy:</span><br><span class="line">image: vmware/nginx-photon:1.11.13</span><br><span class="line">container_name: nginx</span><br><span class="line">restart: always</span><br><span class="line">volumes:</span><br><span class="line">- ./common/config/nginx:/etc/nginx:z</span><br><span class="line">networks:</span><br><span class="line">- harbor</span><br><span class="line">ports:</span><br><span class="line">- 5000:80</span><br><span class="line">- 443:443</span><br><span class="line">- 4443:4443</span><br><span class="line">depends_on:</span><br><span class="line">- mysql</span><br><span class="line">- registry</span><br><span class="line">- ui</span><br><span class="line">- <span class="built_in">log</span></span><br><span class="line">logging:</span><br><span class="line">driver: <span class="string">&quot;syslog&quot;</span></span><br><span class="line">options:</span><br><span class="line">syslog-address: <span class="string">&quot;tcp://127.0.0.1:1514&quot;</span></span><br><span class="line">tag: <span class="string">&quot;proxy&quot;</span></span><br></pre></td></tr></table></figure>

<p>处理模板</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim common/templates/registry/config.yml</span></span><br><span class="line">auth:</span><br><span class="line">token:</span><br><span class="line">issuer: registry-token-issuer</span><br><span class="line">realm: <span class="variable">$ui_url</span>:5000/service/token</span><br><span class="line">rootcertbundle: /etc/registry/root.crt</span><br><span class="line">service: token-service</span><br></pre></td></tr></table></figure>

<p>启动，执行安装，加载镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>更改配置后执行 prepare 脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./prepare</span><br><span class="line"></span><br><span class="line">Generated configuration file: ./config/ui/env</span><br><span class="line">Generated configuration file: ./config/ui/app.conf</span><br><span class="line">Generated configuration file: ./config/registry/config.yml</span><br><span class="line">Generated configuration file: ./config/db/env</span><br><span class="line">Generated configuration file: ./config/jobservice/env</span><br><span class="line">Clearing the configuration file: ./config/ui/private_key.pem</span><br><span class="line">Clearing the configuration file: ./config/registry/root.crt</span><br><span class="line">Generated configuration file: ./config/ui/private_key.pem</span><br><span class="line">Generated configuration file: ./config/registry/root.crt</span><br><span class="line">The configuration files are ready, please use docker-compose to start the service.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose up -d 启动</span></span><br><span class="line"><span class="comment"># docker-compose ps 查看信息</span></span><br><span class="line"></span><br><span class="line">Name Command State Ports</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">harbor-adminserver /harbor/harbor_adminserver Up</span><br><span class="line">harbor-db docker-entrypoint.sh mysqld Up 3306/tcp</span><br><span class="line">harbor-jobservice /harbor/harbor_jobservice Up</span><br><span class="line">harbor-log /bin/sh -c crond &amp;&amp; <span class="built_in">rm</span> -f ... Up 127.0.0.1:1514-&gt;514/tcp</span><br><span class="line">harbor-ui /harbor/harbor_ui Up</span><br><span class="line">nginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:5000-&gt;80/tcp</span><br><span class="line">registry /entrypoint.sh serve /etc/ ... Up 5000/tcp</span><br></pre></td></tr></table></figure>

<p>访问ip:5000 就可以了<br>默认帐号密码admin&#x2F;Harbor12345<br>然后创建用户和项目，注意区分公开还是私有。</p>
<h4 id="2、修改存储目录"><a href="#2、修改存储目录" class="headerlink" title="2、修改存储目录"></a>2、修改存储目录</h4><p>默认情况下存在在&#x2F;data目录，很多时候还是需要修改一下目录的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">registry:</span><br><span class="line">    image: vmware/registry:2.6.2-photon</span><br><span class="line">    container_name: registry</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - /joyfs/oam/harbor/registry:/storage:z</span><br><span class="line">      - ./common/config/registry/:/etc/registry/:z</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">adminserver:</span><br><span class="line">    image: vmware/harbor-adminserver:v1.2.2</span><br><span class="line">    container_name: harbor-adminserver</span><br><span class="line">    env_file:</span><br><span class="line">      - ./common/config/adminserver/env</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/config/:/etc/adminserver/config/:z</span><br><span class="line">      - /data/secretkey:/etc/adminserver/key:z</span><br><span class="line">      - /joyfs/oam/harbor/data/:/data/:z</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、修改数据库为外置MySQL"><a href="#3、修改数据库为外置MySQL" class="headerlink" title="3、修改数据库为外置MySQL"></a>3、修改数据库为外置MySQL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker exec -i -t 6e1e4b576315 bash</span></span><br><span class="line">在db container中：</span><br><span class="line"><span class="comment"># mysqldump -u root -p --databases registry &gt; registry.dump</span></span><br><span class="line">回到node，将dump文件从container中copy出来：</span><br><span class="line"><span class="comment">#docker cp 6e1e4b576315:/root/registry.dump ./</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> common/templates/adminserver</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">env</span> env.bak</span><br><span class="line">vim <span class="built_in">env</span></span><br><span class="line"><span class="comment">#修改以下内容</span></span><br><span class="line">MYSQL_HOST=x.x.x.x</span><br><span class="line">MYSQL_PORT=3306</span><br><span class="line">MYSQL_USR=new name</span><br><span class="line">MYSQL_PWD=new password</span><br><span class="line">MYSQL_DATABASE=registry</span><br><span class="line">....</span><br><span class="line">RESET=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>docker-compose.yml删除 MySQL部分配置，包括proxy里面的- mysql。<br>不过需要注意需要删除 &#x2F;data&#x2F;config&#x2F;config.json 文件。</p>
<p>重启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">./prepare</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>验证登录正常，OK！！！</p>
<img src="https://img.econow.cn/medivh/1555837828882.png"  />

<h2 id="三、推送镜像"><a href="#三、推送镜像" class="headerlink" title="三、推送镜像"></a>三、推送镜像</h2><p>1、检查是否包含镜像地址，如果不包含则执行第2步<br><img src="https://img.econow.cn/medivh/1555838409977.png"  /></p>
<p>2、增加仓库地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry x.x.x.x:5000</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br></pre></td></tr></table></figure>

<p>部分低版本的则是修改其他文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim  /etc/docker/daemon.json</span></span><br><span class="line">&#123; <span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;ip:5000&quot;</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>3、构建并推送</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ip:5000/base/jdk .</span><br><span class="line">docker login ip:5000 </span><br><span class="line"><span class="comment"># 输入账号密码</span></span><br><span class="line">docker push ip:5000/base/jdk </span><br></pre></td></tr></table></figure>

<p>之后在浏览器检查是否正常即可。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md">github</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://econow.cn/%E4%BD%BF%E7%94%A8nmap%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="medivh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Medivh's castle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Medivh's castle">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E4%BD%BF%E7%94%A8nmap%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2.html" class="post-title-link" itemprop="url">使用nmap来进行一些探索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-31 10:15:08" itemprop="dateCreated datePublished" datetime="2023-10-31T10:15:08+08:00">2023-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
    <span id="/%E4%BD%BF%E7%94%A8nmap%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2.html" class="post-meta-item leancloud_visitors" data-flag-title="使用nmap来进行一些探索" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>很多时候需要探测局域网中存在哪些主机，或者开放了哪些端口，有一个特别好用的命令——nmap.</p>
</blockquote>
<h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。 当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图 突破防火墙的封锁。</p>
<p>由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(-sL)或者 通过关闭ping (-P0)跳过ping的步骤，也可以使用多个端口把TCP SYN&#x2F;ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0&#x2F;8尤其普遍。 那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。 主机发现能够找到零星分布于IP地址海洋上的那些机器。</p>
<p>如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用connect()系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用-PA -PE选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。</p>
<ul>
<li>-sL 列表扫描。只能列出来这个网段会有多少主机，并不能判断主机的任何状态。默认情况下还能获取主机名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nmap -sL 192.168.1.0/24</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 16:37 CST</span><br><span class="line">Nmap scan report for 192.168.1.0</span><br><span class="line">Nmap scan report for nsys.cn (192.168.1.1)</span><br><span class="line">...</span><br><span class="line">Nmap scan report for *.demo.haha.com (192.168.1.102)</span><br><span class="line">...</span><br><span class="line">Nmap done: 256 IP addresses (0 hosts up) scanned in 11.16 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>-sP ping扫描。仅使用ping来扫描主机，然后输出对ping进行响应的主机，速度较快，但是意义并不是太大，主要是因为不能获取所有存活的主机。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nmap -sP 192.168.1.0/24</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 16:42 CST</span><br><span class="line">Nmap scan report for nsys.cn (192.168.1.1)</span><br><span class="line">Host is up (0.00078s latency).</span><br><span class="line">Nmap scan report for 192.168.1.9</span><br><span class="line">Host is up (0.086s latency).</span><br><span class="line">Nmap scan report for 192.168.1.10</span><br><span class="line">Host is up (0.00054s latency).</span><br><span class="line">...</span><br><span class="line">Nmap done: 256 IP addresses (29 hosts up) scanned in 2.64 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>-PU UDP Ping,可以绕过只过滤TCP的防火墙和过滤器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nmap -P0 192.168.1.0/24</span><br><span class="line">Host discovery disabled (-Pn). All addresses will be marked &#x27;up&#x27; and scan times will be slower.</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 16:45 CST</span><br><span class="line">Nmap scan report for 192.168.1.0</span><br><span class="line">Host is up (0.000029s latency).</span><br><span class="line">All 1000 scanned ports on 192.168.1.0 are filtered</span><br><span class="line"></span><br><span class="line">Nmap scan report for nsys.cn (192.168.1.1)</span><br><span class="line">Host is up (0.0020s latency).</span><br><span class="line">Not shown: 998 filtered ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">80/tcp   open  http</span><br><span class="line">1723/tcp open  pptp</span><br><span class="line">...</span><br><span class="line">Nmap scan report for 192.168.1.97</span><br><span class="line">Host is up (0.000019s latency).</span><br><span class="line">Not shown: 863 closed ports, 135 filtered ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">5900/tcp open  vnc</span><br><span class="line">8086/tcp open  d-s-n</span><br></pre></td></tr></table></figure>

<h3 id="端口扫描基础"><a href="#端口扫描基础" class="headerlink" title="端口扫描基础"></a>端口扫描基础</h3><ul>
<li><p>open<br>  应用程序正在该端口接收TCP 连接或者UDP报文。</p>
</li>
<li><p>closed<br>  关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。</p>
</li>
<li><p>filtered<br>  由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。</p>
</li>
<li><p>unfiltered<br>  未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。</p>
</li>
<li><p>open|filtered(开放或者被过滤的)<br>  当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。</p>
</li>
<li><p>closed|filtered(关闭或者被过滤的)<br>  该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。</p>
</li>
<li><p>-sS TCP SYN扫描，执行速度快，每秒可以扫描上千个端口。因为它不完成一个完全的TCP连接。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo nmap -sS  192.168.1.0/24</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 16:52 CST</span><br><span class="line">Nmap scan report for nsys.cn (192.168.1.1)</span><br><span class="line">Host is up (0.00032s latency).</span><br><span class="line">Not shown: 993 filtered ports</span><br><span class="line">PORT     STATE  SERVICE</span><br><span class="line">80/tcp   open   http</span><br><span class="line">443/tcp  closed https</span><br><span class="line">xxx</span><br><span class="line">MAC Address: xxxx</span><br><span class="line">...</span><br><span class="line">Nmap scan report for 192.168.1.97</span><br><span class="line">Host is up (0.000017s latency).</span><br><span class="line">Not shown: 499 closed ports, 499 filtered ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">5900/tcp open  vnc</span><br><span class="line">8086/tcp open  d-s-n</span><br><span class="line"></span><br><span class="line">Nmap done: 256 IP addresses (100 hosts up) scanned in 127.95 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>-sT TCP connect()扫描</li>
<li>-sU UDP 扫描</li>
<li>-sA TCP ACK扫描</li>
<li>-sw TCP窗口扫描</li>
</ul>
<h3 id="端口说明和扫描顺序"><a href="#端口说明和扫描顺序" class="headerlink" title="端口说明和扫描顺序"></a>端口说明和扫描顺序</h3><ul>
<li>-p 只扫描指定端口</li>
<li>-F 快速有限的端口</li>
<li>-r 不要按随机顺序扫描</li>
</ul>
<h3 id="服务和版本探测"><a href="#服务和版本探测" class="headerlink" title="服务和版本探测"></a>服务和版本探测</h3><ul>
<li>-v</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.1.236</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 17:18 CST</span><br><span class="line">Nmap scan report for 192.168.1.236</span><br><span class="line">Host is up (1.0s latency).</span><br><span class="line">Not shown: 996 closed ports</span><br><span class="line">PORT      STATE SERVICE    VERSION</span><br><span class="line">22/tcp    open  ssh        OpenSSH 7.4 (protocol 2.0)</span><br><span class="line">111/tcp   open  rpcbind    2-4 (RPC #100000)</span><br><span class="line">9100/tcp  open  jetdirect?</span><br><span class="line">38292/tcp open  java-rmi   Java RMI</span><br><span class="line"></span><br><span class="line">Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 36.78 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>-O</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo nmap -O 192.168.1.236</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 17:20 CST</span><br><span class="line">Nmap scan report for 192.168.1.236</span><br><span class="line">Host is up (0.00057s latency).</span><br><span class="line">Not shown: 996 closed ports</span><br><span class="line">PORT      STATE SERVICE</span><br><span class="line">22/tcp    open  ssh</span><br><span class="line">111/tcp   open  rpcbind</span><br><span class="line">9100/tcp  open  jetdirect</span><br><span class="line">38292/tcp open  landesk-cba</span><br><span class="line">MAC Address: 52:xxxxxxx:49 (QEMU virtual NIC)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Linux 3.X|4.X</span><br><span class="line">OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4</span><br><span class="line">OS details: Linux 3.2 - 4.9</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line"></span><br><span class="line">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 1.91 seconds</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>指定端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>探测分为两部分，获取主机地址和端口。</p>
<ul>
<li>挖掘更多的网络服务信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=discovery</span><br></pre></td></tr></table></figure>

<ul>
<li>负责检查目标主机是否有常见的漏洞<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=vuln 192.168.1.xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其他脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">auth：负责处理鉴权证书、绕开鉴权的脚本。</span><br><span class="line"></span><br><span class="line">broadcast：处理在局域网内探查更多服务开启的状况，如 dhcp / dns / sqlserver 等服务。</span><br><span class="line"></span><br><span class="line">brute：提供暴力破解方式，针对常见的应用如 http / snmp 等。</span><br><span class="line"></span><br><span class="line">default：使用 sC 或 A 选项时默认的脚本，提供基本脚本扫描能力。</span><br><span class="line"></span><br><span class="line">discovery：挖掘更多的网络服务信息，如 smb 枚举、snmp 查询等。</span><br><span class="line"></span><br><span class="line">dos：用于进行拒绝服务攻击。</span><br><span class="line"></span><br><span class="line">exploit：利用已知的漏洞入侵系统。</span><br><span class="line"></span><br><span class="line">external：利用第三方的数据库或资源，如进行 whois 解析。</span><br><span class="line"></span><br><span class="line">fuzzer：模糊测试脚本，发送异常的包到目标主机，探测出潜在的漏洞。</span><br><span class="line"></span><br><span class="line">malware：探测目标是否感染了病毒，是否开启了后门。</span><br><span class="line"></span><br><span class="line">safe：与 fuzzer 功能相反，属于安全性脚本。</span><br><span class="line"></span><br><span class="line">version：负责增强信性服务与版本扫描功能的脚本。</span><br><span class="line"></span><br><span class="line">vuln：负责检查目标主机是否有常见的漏洞，如 ms08_067。</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备17063827号-2 </a>
      <img src="https://beian.miit.gov.cn/#/Integrated/index" alt="">
  </div>
  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">medivh</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"g1GwilqmVAUne2tDEDncEChG-gzGzoHsz","app_key":"YB2e5dSKMmMYYCtaSzxp9fdS","server_url":null,"security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
