<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux磁盘 LVM</title>
    <url>/%20Linux%E7%A3%81%E7%9B%98%20LVM.html</url>
    <content><![CDATA[<h2 id="GPT分区"><a href="#GPT分区" class="headerlink" title="GPT分区"></a>GPT分区</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>您的Linux实例上已经安装了parted工具和e2fsprogs工具。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>运行命令parted &#x2F;dev&#x2F;vdd开始分区。<br>运行命令mklabel gpt，将默认的MBR分区格式转为GPT分区格式。<br>运行命令mkpart primary 1 100%，划分一个主分区，并设置分区的开始位置和结束位置。<br>运行命令align-check optimal 1检查分区是否对齐。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecshost~ ]# yum install -y parted</span><br><span class="line">[root@ecshost~ ]# yum install -y e2fsprogs</span><br></pre></td></tr></table></figure>

<img data-src="https://img.econow.cn/medivh/1562063734050.png"  />

<img data-src="https://img.econow.cn/medivh/1562063851890.png"  />


<h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ul>
<li><p>PV（Phsical Volume，物理卷），PV是VG的组成部分，有分区构成，多块盘的时候，可以把一块盘格式化成一个主分区，然后用这个分区做成一个PV，只有一块盘的时候，可以这块盘的某一个分区做成一个PV，实际上一个PV就一个分区。</p>
</li>
<li><p>VG（Volume Group， 卷组），有若干个PV组成，作用就是将PV组成到以前，然后再重新划分空间。</p>
</li>
<li><p>LV（Logical Volume，逻辑卷），LV就是从VG中划分出来的卷，LV的使用要比PV灵活的多，可以在空间不够的情况下，增加空间。</p>
</li>
</ul>
<img data-src="https://img.econow.cn/medivh/1560482143355.png"  />

<p>就像图中所示，三块物理磁盘组成物理卷工170G；然后三个pv组成一个VG为170G；最后从VG里面分出多个LV。其中VG可以当成一块大盘。</p>
<h2 id="实现LVM"><a href="#实现LVM" class="headerlink" title="实现LVM"></a>实现LVM</h2><p>针对于&#x2F;dev&#x2F;vdc磁盘为例<br>###1、格式化磁盘<br><img data-src="https://img.econow.cn/medivh/1560484200006.png"  /><br><img data-src="https://img.econow.cn/medivh/1560484253384.png"  /></p>
<p>###2、创建PV<br>命令“pvcreate ＋分区”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/vdc1</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1560484437686.png"  />
###3、创建VG
命令“vgcreate ＋分区号＋分区号"
<img data-src="https://img.econow.cn/medivh/1560484533113.png"  />
###4、创建lv
命令“lvcreate -L Size(要建的LV大小） -n LV名+VG名”，也可以用命令“lvdisplay和lvscan”来查看LV的详细信息
<img data-src="https://img.econow.cn/medivh/1560491383392.png"  />

<h3 id="5、调整大小"><a href="#5、调整大小" class="headerlink" title="5、调整大小"></a>5、调整大小</h3><p>建立好lV后我们还可以通过命令“lvextend -L +Size（就是增加多少空间）＋LV的绝对路径”来增加LV的空间大小。也可以通过“lvreduce -L -Size（就是减小多少空间）＋LV的绝对路径”来减少LV的空间大小</p>
<h3 id="6、操作"><a href="#6、操作" class="headerlink" title="6、操作"></a>6、操作</h3><p>以上的PV、VG、LV、都可以通过“pvremove +分区号、vgremove +VG名称、lvremove +lv的绝对路径（如lvremove &#x2F;dev&#x2F;vg_liwei&#x2F;lv_liwei）”命令来删除。这里就不截图了。</p>
<h3 id="７、使用"><a href="#７、使用" class="headerlink" title="７、使用"></a>７、使用</h3><p>做完以上的这一切以后，通过命令“mkfs.ext3 +LV的路径”来格式化分区，然后进行挂载后就可以用了。</p>
<h2 id="LVM扩容"><a href="#LVM扩容" class="headerlink" title="LVM扩容"></a>LVM扩容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/sdc  ##创建新PV</span><br><span class="line">vgextend centos /dev/sdc   ##将新的PV加入到现有的VG</span><br><span class="line">lvextend -l +2559  /dev/centos/root  ##LV扩容lvresize或者lvextend</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 scsi_host]# df -Th</span><br><span class="line">Filesystem              Type      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root xfs        17G   17G  152K 100% /</span><br><span class="line">##文件系统仍未扩容</span><br><span class="line">##需要扩容的是xfs，则需要xfs_growfs命令</span><br><span class="line">xfs_growfs /dev/centos/root   ##扩容xfs文件系统</span><br><span class="line">##如果是ext3,ext4等，需要使用resizefs命令</span><br><span class="line">##再次查看df</span><br><span class="line">[root@node1 scsi_host]# df -Th</span><br><span class="line">Filesystem              Type      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root xfs        27G   17G   10G  63% /</span><br><span class="line">##完成文件系统扩容</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN的一些思考</title>
    <url>/CDN%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html</url>
    <content><![CDATA[<p>配置了一个CDN，却遇到很多问题，先是301，后来又是微服务的401。作为一个普通的网站怎么好意思出这么多问题呢？<br>先来好好了解CDN使用的一些逻辑。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>先了解一下CDN所用到的几个基本概念：</p>
<ul>
<li>源站：源站决定了回源时请求到的具体IP地址</li>
<li>回源HOST：回源HOST决定了回源请求访问到该IP地址上的具体站点。</li>
</ul>
<p>回源HOST指CDN节点在回源过程中，在源站访问的站点域名。当您的源站有多个业务共用的情况时，可以通过用户回源请求里面携带的回源HOST来区分不同的业务。具体的例子就是A记录指向的服务器上有多个域名，如果不区分的话就会默认指向第一个，就会出现业务混乱的情况。</p>
<h3 id="基本链路"><a href="#基本链路" class="headerlink" title="基本链路"></a>基本链路</h3><p>使用cdn这类工具，其实即使服务器上不部署ssl证书都可以实现ssl访问，如果是半程加密以我的博客为例，访问过程如下：</p>
<blockquote>
<p><a href="https://www.xxx.com(浏览器)/">https://www.xxx.com（浏览器）</a> -&gt; 阿里云cdn（进行校验证书是否有效）—回源–&gt; 服务器（80端口）</p>
</blockquote>
<p>可以看到这里回源的服务器的80端口，而非443端口，这就是半程加密。</p>
<p>所以为什么导致重定向次数过多的原因就知道了。</p>
<blockquote>
<p><a href="https://www.xxx.com/">https://www.xxx.com</a> -&gt; 服务器80端口-&gt; 触发rewrite规则 -&gt; <a href="https://www.xxx.com/">https://www.xxx.com</a> 导致循环。</p>
</blockquote>
<p>同样的不加密、全程加密、严格加密的意义就很容易理解了。</p>
<h3 id="301的情况"><a href="#301的情况" class="headerlink" title="301的情况"></a>301的情况</h3><p>源站开启了HTTP重定向至HTTPS的功能，并且CDN控制台上配置的回源端口为80。在这种情况下，由于CDN回源端口为80，客户端无论是通过HTTP还是HTTPS访问CDN加速域名时，CDN在回源的时候都是使用HTTP请求源站，此时会触发源站的HTTPS强制跳转逻辑，然后源站会要求CDN重新发送一个HTTPS的请求，但是CDN回源的时候仍然会发送HTTP回源请求，然后再进行跳转，以此类推，就会出现反复重定向问题，最终导致出现报错。</p>
<ul>
<li>浏览器请求 <a href="https://www.xxx.com/">https://www.xxx.com</a></li>
<li>回源请求  <a href="https://www.xxx.com/">http://www.xxx.com</a></li>
<li>Nginx配置了rewrite,因此  请求 <a href="https://www.xxx.com/">https://www.xxx.com</a></li>
<li>死循环完成，导致301次数过多</li>
</ul>
<h3 id="云现状"><a href="#云现状" class="headerlink" title="云现状"></a>云现状</h3><p>CDN <a href="https://www.xxx.com/">https://www.xxx.com</a> -&gt; cname <a href="http://w1.xxx.com/">http://w1.xxx.com</a> -&gt; slb 80-&gt; Nginx 9090 -&gt; <a href="http://w1.xxx.com/">http://w1.xxx.com</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 实践总结（一）</title>
    <url>/Docker%20%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="关于版本"><a href="#关于版本" class="headerlink" title="关于版本"></a>关于版本</h2><h3 id="版本概述"><a href="#版本概述" class="headerlink" title="版本概述"></a>版本概述</h3><p>Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。而在此之前CentOS官方自带的版本是这样的：</p>
<p>社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。  </p>
<img data-src="https://img.econow.cn/2018/1545117093997.png" />

<h3 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h3><img data-src="https://img.econow.cn/2018/1545117979095.png" />
### 防火墙
关闭firewall
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br><span class="line">                  </span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum makecache fast</span><br><span class="line">yum -y install docker-ce</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<h3 id="使用普通用户"><a href="#使用普通用户" class="headerlink" title="使用普通用户"></a>使用普通用户</h3><ul>
<li><p>1、 首先创建docker用户组，如果docker用户组存在可以忽略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure></li>
<li><p>2、把用户添加进docker组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure></li>
<li><p>3、重启docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>4、如果普通用户执行docker命令，如果提示<code>get …… dial unix /var/run/docker.sock</code>权限不够，则修改<code>/var/run/docker.sock</code>权限<br>使用root用户执行如下命令，即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod a+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h3><p>18.03</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/multi-user.target.wants/docker.service</span><br><span class="line">#加入</span><br><span class="line">ExecStart=/usr/bin/dockerd -H unix:// --registry-mirror=http://192.168.1.232:5000</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546486336192.png" />

<p>19.03</p>
<p>修改daemon.json</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.1.232:5000&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用自己的镜像仓库啦。如果没有配置这些，会提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get https://192.168.1.232:5000/v1/users/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure>

<h3 id="镜像示例"><a href="#镜像示例" class="headerlink" title="镜像示例"></a>镜像示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM 10.110.1.18:5000/base/jdk:1.8.0</span><br><span class="line">ENV LC_ALL en_US.UTF-8</span><br><span class="line">WORKDIR    /home/joy/src</span><br><span class="line">COPY  	xxx.war	 /home/joy/src</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;xxx.war&quot;,&quot;--server.port=8080&quot;,&quot;--Djava.security.egd=file:/dev/./urandom&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms2g -Xmx2g -Xmn512m -XX:PermSize=128M -XX:MaxPermSize=128m -XX:SurvivorRatio=6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d -m 2g  -e JAVA_OPTIONS=&#x27;-Xmx1g -Xms1g -Xmn512m  -XX:PermSize=64m -XX:MaxPermSize=256m&#x27;   10.110.1.18:5000/base/xxxx:latest  /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms：java Heap初始大小， 默认是物理内存的1/64。</span><br><span class="line">-Xmx：java Heap最大值，不可超过物理内存。</span><br><span class="line">-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一 。增大年轻代后，将会减小年老代大小，可以根据监控合理设置。</span><br><span class="line">-Xss：每个线程的Stack大小，而最佳值应该是128K,默认值好像是512k。</span><br><span class="line">-XX:PermSize：设定内存的永久保存区初始大小，缺省值为64M。</span><br><span class="line">-XX:MaxPermSize：设定内存的永久保存区最大大小，缺省值为64M。</span><br><span class="line">-XX:SurvivorRatio：Eden区与Survivor区的大小比值，设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10。</span><br><span class="line">-XX:+UseParallelGC：F年轻代使用并发收集，而年老代仍旧使用串行收集。</span><br><span class="line">-XX:+UseParNewGC：设置年轻代为并行收集，JDK5.0以上，JVM会根据系统配置自行设置，所无需再设置此值。</span><br><span class="line">-XX:ParallelGCThreads：并行收集器的线程数，值最好配置与处理器数目相等 同样适用于CMS。</span><br><span class="line">-XX:+UseParallelOldGC：年老代垃圾收集方式为并行收集(Parallel Compacting)。</span><br><span class="line">-XX:MaxGCPauseMillis：每次年轻代垃圾回收的最长时间(最大暂停时间)，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</span><br><span class="line">-XX:+ScavengeBeforeFullGC：Full GC前调用YGC,默认是true。</span><br></pre></td></tr></table></figure>


<h2 id="镜像库"><a href="#镜像库" class="headerlink" title="镜像库"></a>镜像库</h2><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search centos                                       # 查找源中镜像</span><br><span class="line">docker pull centos:6                                       # 从官方下载centos的docker镜像</span><br><span class="line"></span><br><span class="line">docker images                                              # 查看docker镜像</span><br><span class="line">docker ps                                                  # 查看docker启动的容器</span><br><span class="line">docker ps -a                                               # 查看docker所有容器 包括未启动的</span><br><span class="line">docker rm $(docker ps -a -q)                    #删除所有停止的容器</span><br><span class="line"></span><br><span class="line">docker run -d -t -i centos:6 /bin/bash          # 启动docker隔离的容器 -t 让Docker分配一个伪终端,并绑定到容器的标准输入上. -i 则让容器的标准输入保持打开. -d 守护进程</span><br><span class="line">docker attach ID                                           # 进入后台的容器 指定容器ID   # util-linux 也可以进入容器</span><br><span class="line">docker logs ID                                             # 获取容器内输出信息</span><br><span class="line"></span><br><span class="line">docker stop ID                                             # 停止已启动的容器</span><br><span class="line">docker start ID                                            # 启动已停止的容器</span><br><span class="line">docker restart ID                                          # 重启容器</span><br><span class="line"></span><br><span class="line">docker export 7691a814370e &gt; centos_a.tar                  # 导出容器快照到本地</span><br><span class="line">cat centos_a.tar | docker import - test/centos_a:v1.0      # 从容器快照文件中再导入为镜像</span><br><span class="line"></span><br><span class="line">docker save -o centos.6.tar centos:6                       # 保存镜像到文件</span><br><span class="line">docker load --input centos.6.tar                           # 载入镜像文件</span><br><span class="line"></span><br><span class="line">docker rm 容器ID                                           # 删除终止状态的容器   加-f强制终止运行中的容器</span><br><span class="line">docker rmi test/centos_a:v1.0                              # 移除本地镜像   在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器</span><br><span class="line">docker commit -m &#x27;nginx from centos7&#x27; 12bf9d3e4d94  medivh/nginx:v1          提交更改到一个镜像</span><br><span class="line">docker rm `docker ps -a|grep Exited|awk &#x27;&#123;print $1&#125;&#x27;`      # 删除所有退出的容器</span><br><span class="line">brctl show                                                 # 查看网桥</span><br><span class="line"></span><br><span class="line">docker pull library/nginx</span><br><span class="line"></span><br><span class="line">docker run --name some-nginx -v /some/content:/usr/share/nginx/html:ro -d nginx</span><br><span class="line"></span><br><span class="line">mkdir testa                            # 创建静态资源目录</span><br><span class="line">vim testa/a.txt</span><br><span class="line">aaaaaa</span><br><span class="line"></span><br><span class="line">vim Dockerfile                         # 创建 Dockerfile 文件</span><br><span class="line">FROM nginx</span><br><span class="line">COPY testa /usr/share/nginx/html       # 拷贝前面创建的静态资源目录</span><br><span class="line"></span><br><span class="line"># Dockerfile用来创建一个自定义的image,包含了用户指定的软件依赖等。当前目录下包含Dockerfile,使用命令build来创建新的image,并命名为 some-content-nginx</span><br><span class="line">docker build -t some-content-nginx .</span><br><span class="line"></span><br><span class="line">docker run --name some-nginx -d some-content-nginx</span><br><span class="line"></span><br><span class="line">docker run --name XXX -d -p 8080:80 XXX-nginx             # 暴漏端口的方式，将容器80端口映射到主机8080端口，可以直接访问</span><br><span class="line">docker run --name XXX -d -p 127.0.0.1::80 XXX-nginx     #将容器80端口映射到主机某个端口，访问主机该端口</span><br><span class="line">docker run --name XXX -d -P  XXX-nginx     #将容器80端口映射到主机某个端口，访问主机该端口</span><br><span class="line">docker run -d --name db training/postgres</span><br><span class="line">docker run -d -P --name web --link db:db training/webapp python app.py          # 新建立容器,并连接db容器   --link name:alias    </span><br><span class="line"></span><br><span class="line"># 启动仓库容器</span><br><span class="line">docker run -d -p 5000:5000 -v /data/registry:/tmp/registry registry</span><br><span class="line"></span><br><span class="line"># 可以拉取一个比较小的images做测试</span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line"># 更改images的tag</span><br><span class="line">sudo docker tag ubuntu 192.168.11.247:5000/ubuntu</span><br><span class="line"></span><br><span class="line"># Push images</span><br><span class="line">sudo docker push 192.168.11.247:5000/ubuntu</span><br><span class="line"></span><br><span class="line"># Pull images</span><br><span class="line">sudo docker pull 192.168.11.247:5000/ubuntu</span><br><span class="line"></span><br><span class="line"># 通过API查看</span><br><span class="line">curl http://192.168.11.247:5000/v1/search</span><br><span class="line"></span><br><span class="line"># 在私有仓库搜索</span><br><span class="line">docker search 192.168.11.247:5000/ubuntu</span><br><span class="line"></span><br><span class="line">导入</span><br><span class="line">cd CentOS-6.6_Base</span><br><span class="line">tar -c .|docker import - &quot;centos-6.6/base&quot;</span><br><span class="line"></span><br><span class="line">创建一个带ssh的images</span><br><span class="line">docker build -t &quot;CentOS-6.6/sshd&quot; .</span><br><span class="line"></span><br><span class="line">启动一个实例:</span><br><span class="line">docker run -d -p 127.0.0.1:1994:22 CentOS-6.6/sshd</span><br><span class="line"></span><br><span class="line">导出镜像    </span><br><span class="line">docker save IMAGENAME | bzip2 -9 -c&gt;img.tar.bz2</span><br><span class="line"></span><br><span class="line">导入镜像(换一台机器)</span><br><span class="line">bzip2 -d -c &lt;img.tar.bz2 | docker load</span><br><span class="line">curl http://localhost:8080/a.txt</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="进入容器脚本"><a href="#进入容器脚本" class="headerlink" title="进入容器脚本"></a>进入容器脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">CNAME=$1</span><br><span class="line">CPID=$(docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; $CNAME)</span><br><span class="line">nsenter --target &quot;$CPID&quot; --mount --uts  --ipc --net --pid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go XXX($cname)</span><br></pre></td></tr></table></figure>
<p>使用的时候直接 脚本+容器ID。</p>
<h3 id="文件互传"><a href="#文件互传" class="headerlink" title="文件互传"></a>文件互传</h3><p>文件传输</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp foo.txt mycontainer:/foo.txt</span><br><span class="line">docker cp mycontainer:/foo.txt foo.txt</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>精简Docker镜像尺寸的好处：</p>
<ol>
<li>减少构建时间</li>
<li>减少磁盘使用量</li>
<li>减少下载时间</li>
<li>因为包含文件少，攻击面减小，提高了安全性</li>
<li>提高部署速度</li>
</ol>
<h3 id="镜像优化"><a href="#镜像优化" class="headerlink" title="镜像优化"></a>镜像优化</h3><h4 id="优化基础镜像"><a href="#优化基础镜像" class="headerlink" title="优化基础镜像"></a>优化基础镜像</h4><p>推荐使用alpine&#x2F;busybox，实在不行就只能用CentOS了。</p>
<h4 id="串联-Dockerfile-指令"><a href="#串联-Dockerfile-指令" class="headerlink" title="串联 Dockerfile 指令"></a>串联 Dockerfile 指令</h4><p>大家在定义Dockerfile时，如果太多的使用RUN指令，经常会导致镜像有特别多的层，镜像很臃肿，而且甚至会碰到超出最大层数（127层）限制的问题，遵循 Dockerfile 最佳实践，我们应该把多个命令串联合并为一个 RUN（通过运算符&amp;&amp;和&#x2F; 来实现），每一个 RUN 要精心设计，确保安装构建最后进行清理，这样才可以降低镜像体积，以及最大化的利用构建缓存。<br>将多条RUN命令串联起来构建的镜像大小是每条命令分别RUN的三分之一。</p>
<h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>Dockerfile中每条指令都会为镜像增加一个镜像层，并且你需要在移动到下一个镜像层之前清理不需要的组件。实际上，有一个Dockerfile用于开发（其中包含构建应用程序所需的所有内容）以及一个用于生产的瘦客户端，它只包含你的应用程序以及运行它所需的内容。这被称为“建造者模式”。Docker 17.05.0-ce版本以后支持多阶段构建。使用多阶段构建，你可以在Dockerfile中使用多个FROM语句，每条FROM指令可以使用不同的基础镜像，这样您可以选择性地将服务组件从一个阶段COPY到另一个阶段，在最终镜像中只保留需要的内容。</p>
<p>下面是一个使用COPY –from 和 FROM … AS … 的Dockerfile：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Compile</span><br><span class="line">FROM golang:1.9.0 AS builder</span><br><span class="line">WORKDIR /go/src/v9.git...com/.../k8s-monitor</span><br><span class="line">COPY . .</span><br><span class="line">WORKDIR /go/src/v9.git...com/.../k8s-monitor</span><br><span class="line">RUN make build</span><br><span class="line">RUN mv k8s-monitor /root</span><br><span class="line"></span><br><span class="line"># Package</span><br><span class="line"># Use scratch image</span><br><span class="line">FROM scratch</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=builder /root .</span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;/root/k8s-monitor&quot;]</span><br></pre></td></tr></table></figure>
<p>构建镜像，你会发现生成的镜像只有上面COPY 指令指定的内容，镜像大小只有2M。这样在以前使用两个Dockerfile（一个Dockerfile用于开发和一个用于生产的瘦客户端），现在使用多阶段构建就可以搞定。</p>
<h4 id="修改docker0"><a href="#修改docker0" class="headerlink" title="修改docker0"></a>修改docker0</h4><p>在此文件中添加如下一行，然后重启服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">&quot;bip&quot;: &quot;192.168.102.1/24&quot;</span><br><span class="line">&#125;</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h4 id="构建业务服务镜像技巧"><a href="#构建业务服务镜像技巧" class="headerlink" title="构建业务服务镜像技巧"></a>构建业务服务镜像技巧</h4><ul>
<li>不变或者变化很少的体积较大的依赖库和经常修改的自有代码分开；</li>
<li>因为cache缓存在运行Docker build命令的本地机器上，建议固定使用某台机器来进行Docker build，以便利用cache。</li>
</ul>
<h4 id="其他优化技巧"><a href="#其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h4><p>如果在RUN命令中执行apt、apk或者yum类工具，可以借助这些工具提供的一些小技巧来减少镜像层数量及镜像大小。举几个例子：</p>
<p>（1）在执行<code>apt-get install -y</code> 时增加选项<code>— no-install-recommends </code>，可以不用安装建议性（非必须）的依赖，也可以在执行<code>apk add </code>时添加选项<code>--no-cache</code> 达到同样效果；</p>
<p>（2）执行yum install -y 时候， 可以同时安装多个工具，比如<code>yum install -y gcc gcc-c++ make …</code>。将所有<code>yum install</code> 任务放在一条RUN命令上执行，从而减少镜像层的数量；</p>
<p>（3）组件的安装和清理要串联在一条指令里面，如<code>apk --update add php7 &amp;&amp; rm -rf /var/cache/apk/*</code>，因为Dockerfile的每条指令都会产生一个文件层，如果将<code>apk add …</code> 和<code> rm -rf …</code> 命令分开，清理无法减小apk命令产生的文件层的大小。清理镜像中缓存文件；CentOS等系统使用yum clean all 命令清理。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><ul>
<li><p>1、docker dead 无法删除</p>
<ul>
<li>1、检查挂载信息  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep docker /proc/*/mountinfo &gt; x.log</span><br></pre></td></tr></table></figure></li>
<li>2、 获取进程ID  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -nr &#x27;/var/lib/docker/overlay2/bd47a216d1bc2e72ba3155169faee246b2352fe919c8fb4708891ad31d1d31c7/diff&#x27; x.log | awk -F &#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|awk -F &#x27;/&#x27; &#x27;&#123;print $3&#125;’</span><br></pre></td></tr></table></figure></li>
<li>3、杀死所有相关进程</li>
</ul>
</li>
<li><p>2、故障</p>
</li>
</ul>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 实践总结（二）</title>
    <url>/Docker%20%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h2><h2 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h2><h3 id="初始化swarm"><a href="#初始化swarm" class="headerlink" title="初始化swarm"></a>初始化swarm</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull swarm</span><br></pre></td></tr></table></figure>
<p>创建集群token，获取全球唯一的 token，作为集群唯一标识</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm swarm create</span><br><span class="line">a253407f93a759e7b1d69a49cf669732</span><br></pre></td></tr></table></figure>
<p>加入集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d swarm join -addr=192.168.1.228:2379  token://a253407f93a759e7b1d69a49cf669732</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.1.228</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546500467791.png" />
使用下面一段，在其它节点上执行加入集群
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-1g17yyrfepskeffufewmgfiewffqemcc8kjsy9x1zbjucqu4ms-dcp6ub8tjc2yq6bh7qbhs926e 192.168.1.228:2377</span><br></pre></td></tr></table></figure>
### 检查
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546500808458.png" />

<h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><p>离开集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure>
<p>部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stack deploy -c ws.yml  sys01</span><br><span class="line"></span><br><span class="line">-c 指定yaml文件</span><br><span class="line">name stack 名称</span><br></pre></td></tr></table></figure>
<p>检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stack ls</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546933824902.png" />

<p>stack 详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stack ps sys01</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546933878894.png" />

<p>检查service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546933935686.png" />

<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stack rm sys01</span><br><span class="line">docker service rm xxxx</span><br></pre></td></tr></table></figure>
<h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><h4 id="AVAILABILITY-的三种状态："><a href="#AVAILABILITY-的三种状态：" class="headerlink" title="AVAILABILITY 的三种状态："></a>AVAILABILITY 的三种状态：</h4><ul>
<li><p>Active：调度器能够安排任务到该节点</p>
</li>
<li><p>Pause：调度器不能够安排任务到该节点，但是已经存在的任务会继续运行</p>
</li>
<li><p>Drain：调度器不能够安排任务到该节点，而且会停止已存在的任务，并将这些任务分配到其他 Active 状态的节点</p>
</li>
</ul>
<h4 id="MANAGER-STATUS-的三种状态"><a href="#MANAGER-STATUS-的三种状态" class="headerlink" title="MANAGER STATUS 的三种状态"></a>MANAGER STATUS 的三种状态</h4><ul>
<li><p>Leader：为群体做出所有群管理和编排决策的主要管理者节点</p>
</li>
<li><p>Reachable：如果 Leader 节点变为不可用，该节点有资格被选举为新的 Leader</p>
</li>
<li><p>Unavailable：该节点不能和其他 Manager 节点产生任何联系，这种情况下，应该添加一个新的 Manager 节点到集群，或者将一个 Worker  节点提升为 Manager 节点</p>
</li>
</ul>
<h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><h4 id="改变节点的可用性-availability"><a href="#改变节点的可用性-availability" class="headerlink" title="改变节点的可用性(availability)"></a>改变节点的可用性(availability)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker node update --availability drain WorkerA</span><br></pre></td></tr></table></figure>
<h4 id="添加-移除标签元数据"><a href="#添加-移除标签元数据" class="headerlink" title="添加&#x2F;移除标签元数据"></a>添加&#x2F;移除标签元数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker node update --label-add foo --label-add bar=baz WorkerA</span><br></pre></td></tr></table></figure>

<p>类型一：–label-add <key></p>
<p>类型二：–label-add <key>&#x3D;<value></p>
<h4 id="升级-降级节点"><a href="#升级-降级节点" class="headerlink" title="升级&#x2F;降级节点"></a>升级&#x2F;降级节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[升级] docker node promote WorkerA</span><br><span class="line"></span><br><span class="line">[降级] docker node demote WorkerA</span><br></pre></td></tr></table></figure>


<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker swarm init               #初始化集群</span><br><span class="line">docker swarm join-token worker  #查看工作节点的 token</span><br><span class="line">docker swarm join-token manager #查看管理节点的 token</span><br><span class="line">docker swarm join               #加入集群中</span><br><span class="line"></span><br><span class="line">docker node ls      #查看所有集群节点</span><br><span class="line">docker node rm      #删除某个节点（-f强制删除）</span><br><span class="line">docker node inspect ##查看节点详情</span><br><span class="line">docker node demote  #节点降级，由管理节点降级为工作节点</span><br><span class="line">docker node promote #节点升级，由工作节点升级为管理节点</span><br><span class="line">docker node update  #更新节点</span><br><span class="line">docker node ps      #查看节点中的 Task 任务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker service create   #部署服务</span><br><span class="line">docker service inspect  #查看服务详情</span><br><span class="line">docker service logs     #产看某个服务日志</span><br><span class="line">docker service ls       #查看所有服务详情</span><br><span class="line">docker service rm       #删除某个服务（-f强制删除）</span><br><span class="line">docker service scale    #设置某个服务个数</span><br><span class="line">docker service update   #更新某个服务</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker标准镜像制作</title>
    <url>/Docker%E6%A0%87%E5%87%86%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C.html</url>
    <content><![CDATA[<blockquote>
<ul>
<li>由于hub.docker.com上提供的官方镜像为open-jdk，因此和程序运行时多少会有点小问题；</li>
<li>之前使用基于alpine的基础镜像来制作应用镜像时会遇到一些小麻烦，主要是因为和linux 多有不同，并且不能直接运行Oracle jdk；<br>综上所述，因此决定使用基于CentOS来构建镜像。</li>
</ul>
</blockquote>
<h3 id="初始化镜像"><a href="#初始化镜像" class="headerlink" title="初始化镜像"></a>初始化镜像</h3><h4 id="拉取基础镜像"><a href="#拉取基础镜像" class="headerlink" title="拉取基础镜像"></a>拉取基础镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
<h4 id="自定义jdk版本"><a href="#自定义jdk版本" class="headerlink" title="自定义jdk版本"></a>自定义jdk版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#解压</span><br><span class="line">tar xvcf jre-8u191-linux-x64.tar.gz</span><br><span class="line">#进入目录</span><br><span class="line">cd jre1.8.0_161/</span><br><span class="line">#删除文本文件</span><br><span class="line">rm -rf COPYRIGHT LICENSE README release THIRDPARTYLICENSEREADME-JAVAFX.txtTHIRDPARTYLICENSEREADME.txt Welcome.html</span><br><span class="line">#删除其他无用文件</span><br><span class="line">rm -rf     lib/plugin.jar \</span><br><span class="line">        lib/ext/jfxrt.jar \</span><br><span class="line">        bin/javaws \</span><br><span class="line">        lib/javaws.jar \</span><br><span class="line">        lib/desktop \</span><br><span class="line">        plugin \</span><br><span class="line">        lib/deploy* \</span><br><span class="line">        lib/*javafx* \</span><br><span class="line">        lib/*jfx* \</span><br><span class="line">        lib/amd64/libdecora_sse.so \</span><br><span class="line">        lib/amd64/libprism_*.so \</span><br><span class="line">        lib/amd64/libfxplugins.so \</span><br><span class="line">        lib/amd64/libglass.so \</span><br><span class="line">        lib/amd64/libgstreamer-lite.so \</span><br><span class="line">        lib/amd64/libjavafx*.so \</span><br><span class="line">        lib/amd64/libjfx*.so</span><br></pre></td></tr></table></figure>
<p>最后再重新打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zcvf jre-8u191-linux-x64.tar.gz jre1.8.0_191/</span><br></pre></td></tr></table></figure>

<h4 id="构建JDK"><a href="#构建JDK" class="headerlink" title="构建JDK"></a>构建JDK</h4><ul>
<li>编写Dockerfile<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; Dockerfile</span><br><span class="line"></span><br><span class="line">FROM centos:latest</span><br><span class="line">MAINTAINER by medivh</span><br><span class="line">RUN rm -f /etc/localtime  &amp;&amp; ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; mkdir  /usr/local/java &amp;&amp; useradd joy</span><br><span class="line">#相对路径jar,把java添加到容器中</span><br><span class="line">ADD jre-8u191-linux-x64.tar.gz /usr/local/java/</span><br><span class="line"></span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_91</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">USER joy</span><br><span class="line">RUN mkdir /home/joy/logs &amp;&amp; mkdir /home/joy/src</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
<li>构建镜像<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t 192.168.1.232:5000/base/jdk:1.8.0_91_v.0.5 .</span><br></pre></td></tr></table></figure>
因为镜像需要推送到仓库，因此在构建镜像的时候直接打标签了。</li>
</ul>
<h3 id="构建服务镜像"><a href="#构建服务镜像" class="headerlink" title="构建服务镜像"></a>构建服务镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Version: 0.0.1</span><br><span class="line">FROM 192.168.1.232:5000/base/jdk:1.8.0_91_v.0.5</span><br><span class="line">ENV LC_ALL en_US.UTF-8</span><br><span class="line">WORKDIR    /home/joy/src</span><br><span class="line">ADD xxxxx-SNAPSHOT.war /home/joy/src</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;xxxxx.jar&quot;,&quot;--server.port=8080&quot;,&quot;--Djava.security.egd=file:/dev/./urandom&quot;]</span><br></pre></td></tr></table></figure>



<h4 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h4><ul>
<li>from 基于之前构建好的jdk镜像</li>
<li>修改时区</li>
<li>workdir 设定工作目录，类似于cd命令</li>
<li>ADD 添加war包或者jar包</li>
<li>EXPOSE 暴露端口，默认设置为8080</li>
<li>ENTRYPOINT 程序启动相关参数</li>
</ul>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK 部署</title>
    <url>/ELK%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><ul>
<li>Elasticsearch 作为存储和索引这些数据;</li>
<li>Filebeat 日志文件托运,传送给Logstash;</li>
<li>Logstash 去插入数据到elasticsearch;</li>
<li>Kibana 作为展示平台。</li>
</ul>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><img data-src="https://img.econow.cn/2018/1539223733259.png" width="870"/>

<p>其中filebeat是作为轻量级的logstash来工作。每台机器上只需要部署filebeat,然后向1台logstash传输即可。</p>
<h3 id="实际相关"><a href="#实际相关" class="headerlink" title="实际相关"></a>实际相关</h3><p>服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.110.1.18 Filebeat+Logstash+Elasticsearch+Kibana</span><br></pre></td></tr></table></figure>
<p>路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/elk</span><br><span class="line">/etc/filebeat</span><br></pre></td></tr></table></figure>
<p>版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearch-6.4.2</span><br><span class="line">kibana-6.4.2</span><br><span class="line">logstash-6.4.2</span><br><span class="line">filebeat-6.4.2</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h3><p>Elasticsearch requires at least Java 8. Specifically as of this writing, it is recommended that you use the Oracle JDK version 1.8.0_131. Java installation varies from platform to platform so we won’t go into those details here. Oracle’s recommended installation documentation can be found on Oracle’s website. Suffice to say, before you install Elasticsearch, please check your Java version first by running (and then install&#x2F;upgrade accordingly if needed):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_91&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_91-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)</span><br></pre></td></tr></table></figure>
<p>简单说jdk版本必须为1.8以上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src/ &amp;&amp; tar -zxvf ./jdk1.8.0_91.tar.gz -C /usr/local</span><br><span class="line">ln -s /usr/local/jdk1.8.0_91 /usr/local/java</span><br><span class="line">echo &#x27;</span><br><span class="line">#JDK</span><br><span class="line">############################################################</span><br><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">############################################################</span><br><span class="line">&#x27; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h3 id="系统参数设定"><a href="#系统参数设定" class="headerlink" title="系统参数设定"></a>系统参数设定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;vm.max_map_count=262144&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536&quot; &gt;&gt; /etc/security/limits.conf &amp;&amp; \</span><br><span class="line">   echo &quot;ulimit -c unlimited&quot; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure>
<p>如果es启动的时候不生效，可以关闭当前窗口，重新打开。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.tar.gz</span><br><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.4.2-linux-x86_64.tar.gz</span><br><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.2.tar.gz</span><br><span class="line">mkdir /usr/local/elk</span><br><span class="line">wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.6.1-x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install filebeat-6.6.1-x86_64.rpm</span><br><span class="line">tar -zxvf elasticsearch-6.4.2.tar.gz -C /usr/local/elk/</span><br><span class="line">tar -zxvf kibana-6.4.2-linux-x86_64.tar.gz -C /usr/local/elk/</span><br><span class="line">tar -zxvf logstash-6.4.2.tar.gz -C /usr/local/elk/</span><br><span class="line">cd /usr/local/elk</span><br><span class="line">ln -s elasticsearch-6.4.2/ elasticsearch</span><br><span class="line">ln -s filebeat-6.4.2-linux-x86_64/ filebeat</span><br><span class="line">ln -s logstash-6.4.2/ logstash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中filebeat有些特殊，如果需要读取&#x2F;var&#x2F;log下的日志，注意启用用户的权限问题。至于安装方式可以选择RPM方式，启动更为简单，毕竟启动后基本就不会再动。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>需要修改的地方，重点是data目录，注意磁盘空间，时间久了会爆满的！！！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#vim /usr/local/elk/elasticsearch/config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line">cluster.name: es</span><br><span class="line">node.name: elk-1</span><br><span class="line">path.data: /joyfs/oam/elk/es-data</span><br><span class="line">path.logs: /joyfs/oam/elk/es-logs</span><br><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/elk/elasticsearch/./bin/elasticsearch -d</span><br></pre></td></tr></table></figure>
<h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><p>访问9200端口或者浏览器也可以。出现下面信息表示运行正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:9200</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/2018/1539164622896.png" width="387"/>

<h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>基本没有什么需要配置的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#vim /usr/local/elk/kibana/config/kibana.yml</span><br><span class="line"></span><br><span class="line">server.host: &quot;10.110.1.18&quot;</span><br><span class="line">#切换地图高德，最后加上这一段</span><br><span class="line">tilemap.url: &#x27;http://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=7&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&#x27;</span><br><span class="line">tilemap.options.minZoom: &quot;1&quot;</span><br><span class="line">tilemap.options.maxZoom: &quot;10&quot;</span><br></pre></td></tr></table></figure>
<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup ./bin/kibana &amp;</span><br></pre></td></tr></table></figure>
<p>访问默认5601端口</p>
<img data-src="https://img.econow.cn/2018/1539167701059.png" width="317"/>



<h3 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h3><h4 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#=========================== Filebeat inputs =============================</span><br><span class="line"></span><br><span class="line">filebeat.inputs:</span><br><span class="line">#按照以下示例增加多个日志类型</span><br><span class="line">- input_type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">    - /joyfs/logs/nginx/9011/c1/logs/access.log</span><br><span class="line">    - /joyfs/logs/nginx/9011/c1/logs/error.log</span><br><span class="line">    - /joyfs/logs/nginx/9011/a1/logs/access.log</span><br><span class="line">    - /joyfs/logs/nginx/9011/a1/logs/error.log</span><br><span class="line">  fields:</span><br><span class="line">    service: nginx_joy_app</span><br><span class="line"></span><br><span class="line">#----------------------------- Logstash output --------------------------------</span><br><span class="line">output.logstash:</span><br><span class="line">  #该地址为filebeat =&gt; logstash 地址端口</span><br><span class="line">  hosts: [&quot;10.110.1.18:5044&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果需要配置logstash的负载均衡，就需要增加下面的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;localhost:5044&quot;, &quot;localhost:5045&quot;]</span><br><span class="line">  loadbalance: true</span><br></pre></td></tr></table></figure>


<h4 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup ./bin/filebeat &amp;</span><br></pre></td></tr></table></figure>
<p>检查日志如果不报错就可以。</p>
<h3 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h3><h4 id="配置文件-3"><a href="#配置文件-3" class="headerlink" title="配置文件"></a>配置文件</h4><p>没啥可修改的，如果愿意的话修改一下日志目录和data目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#vim /usr/local/elk/logstash/config/logstash.yml</span><br><span class="line"></span><br><span class="line">path.data: /joyfs/oam/elk/logstash-data</span><br><span class="line">path.logs: /joyfs/oam/elk/logstash-logs</span><br></pre></td></tr></table></figure>
<h4 id="过滤执行文件"><a href="#过滤执行文件" class="headerlink" title="过滤执行文件"></a>过滤执行文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#vim /usr/local/elk/logstash/config/conf.d/joy.conf</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">     beats &#123;</span><br><span class="line">           port =&gt; 5044</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    if [fields][service] == &quot;nginx_joy_app&quot; &#123;</span><br><span class="line">      grok &#123;</span><br><span class="line">            match =&gt; &#123; &quot;message&quot; =&gt; &#x27;%&#123;IP&#125; - %&#123;NGUSER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] &quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;&quot; %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-) (?:%&#123;NOTSPACE:request&#125;|-) (?:&quot;(?:%&#123;URI:referrer&#125;|-)&quot;|%&#123;QS:referrer&#125;) %&#123;QS:agent&#125; %&#123;IPORHOST:clientip&#125; %&#123;URIHOST&#125; %&#123;BASE10NUM:request_duration&#125;&#x27; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      useragent &#123;</span><br><span class="line">        source =&gt; &quot;agent&quot;</span><br><span class="line">        target =&gt; &quot;device&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      date &#123;</span><br><span class="line">         match =&gt; [ &quot;timestamp&quot;,&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">      geoip &#123;</span><br><span class="line"></span><br><span class="line">        source =&gt; &quot;clientip&quot;</span><br><span class="line">        target =&gt; &quot;geoip&quot;</span><br><span class="line">        database =&gt; &quot;/usr/local/elk/logstash/GeoLite/GeoLite2-City.mmdb&quot;</span><br><span class="line">        add_field =&gt; [ &quot;[geoip][coordinates]&quot;, &quot;%&#123;[geoip][longitude]&#125;&quot; ]</span><br><span class="line">        add_field =&gt; [ &quot;[geoip][coordinates]&quot;, &quot;%&#123;[geoip][latitude]&#125;&quot;  ]</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      mutate &#123;</span><br><span class="line">        convert =&gt; [ &quot;[geoip][coordinates]&quot;, &quot;float&quot;]</span><br><span class="line">        remove_field =&gt; [</span><br><span class="line">                &quot;tags&quot;,</span><br><span class="line">                &quot;offset&quot;,</span><br><span class="line">                &quot;host&quot;,</span><br><span class="line">                &quot;beat&quot;</span><br><span class="line">            ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if [fields][service] == &quot;system&quot; &#123;</span><br><span class="line">      grok &#123;</span><br><span class="line">        match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      mutate &#123;</span><br><span class="line">            remove_field =&gt; [</span><br><span class="line">                &quot;tags&quot;,</span><br><span class="line">                &quot;offset&quot;,</span><br><span class="line">                &quot;host&quot;,</span><br><span class="line">                &quot;beat&quot;</span><br><span class="line">            ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  if [fields][service] == &quot;nginx_joy_app&quot;&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        index =&gt; &quot;logstash-nginx_joy_app-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if [fields][service] == &quot;system&quot;&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        index =&gt; &quot;system_oam-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意nginx日志索引必须为”logstash-xxxx”,否则地图会找不到字段。</p>
<h4 id="配置地图"><a href="#配置地图" class="headerlink" title="配置地图"></a>配置地图</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/elk/logstash</span><br><span class="line">mkdir GeoLite</span><br><span class="line">cd GeoLite</span><br><span class="line">wget http://geolite.maxmind.com/download/geoip/database/GeoLite2-City.mmdb.gz</span><br><span class="line">gunzip GeoLite2-City.mmdb.gz</span><br></pre></td></tr></table></figure>
<p>注意和配置文件里的GeoLite2-City.mmdb路径保持一致！！！</p>
<h4 id="启动-3"><a href="#启动-3" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup ./bin/logstash &amp;</span><br></pre></td></tr></table></figure>


<h2 id="kibana画图"><a href="#kibana画图" class="headerlink" title="kibana画图"></a>kibana画图</h2><p>visualize-&gt;Maps-&gt;Coordinate Map</p>
<img data-src="https://img.econow.cn/2018/1539169330458.png" width="346"/>

<img data-src="https://img.econow.cn/2018/1539169363305.png" width="192"/>

<h2 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h2><h3 id="1、创建地图时找不到字段"><a href="#1、创建地图时找不到字段" class="headerlink" title="1、创建地图时找不到字段"></a>1、创建地图时找不到字段</h3><img data-src="https://img.econow.cn/2018/1539222082965.png" width="348"/>

<p>**问题分析：  **</p>
<blockquote>
<p>索引格式为[nginx-xxx-]YYYY-MM的日志文件由logstash输出到Elasticsearch；在 elasticsearch 中，所有的数据都有一个类型，什么样的类型，就可以在其上做一些对应类型的特殊操作。geo信息中的location字段是经纬度，我们需要使用经纬度来定位地理位置；在 elasticsearch 中，对于经纬度来说，要想使用 elasticsearch 提供的地理位置查询相关的功能，就需要构造一个结构，并且将其类型属性设置为geo_point，此错误明显是由于我们的geo的location字段类型不是geo_point。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET nginx_joy_app-2018.10.11/_mapping</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/2018/1539222419814.png" width="579"/>
说明创建的index中location字段类型和要求的geo_point不一致。

<p><strong>解决方案:</strong></p>
<ul>
<li>修改ES模板</li>
<li>logstash配置文件中的output,命名设置为logstash-xxx的index</li>
</ul>
<img data-src="https://img.econow.cn/2018/1539222688909.png" width="422"/>


<p>如果以上方式还是不能解决geo_point的问题，那就碰上事了。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET _all/_mapping</span><br><span class="line">&quot;properties&quot;: &#123;</span><br><span class="line">          &quot;@timestamp&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;date&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;@version&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;geoip&quot;: &#123;</span><br><span class="line">            &quot;dynamic&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">              &quot;ip&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;ip&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;latitude&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;half_float&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;location&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;geo_point&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;longitude&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;half_float&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">如果检查发现找不到任何geo_point相关字段，说明这个模板就有问题。我的理解是es启动后才会依据内置模板&quot;logstash-xxxx&quot;,这样就有了geo_point这个字段。</span><br><span class="line"></span><br><span class="line">但是如果logstash在es之前启动就会造成es没有来得及匹配内置模板，这样就把所有的索引都认为是应用自定义模板。这样logstash是什么数据，es展示的就是什么数据了。</span><br><span class="line"></span><br><span class="line">### 2、配置完logstash，但是kibana或者es不显示index</span><br><span class="line">**分析**</span><br><span class="line">* 检查filebeat配置文件中搜集的日志路径是否正确,相关日志是否真的存在。</span><br><span class="line">&lt;img src=&quot;https://img.econow.cn/2018/1539223116186.png&quot; width=&quot;374&quot;/&gt;</span><br><span class="line"></span><br><span class="line">* 检查logstash中的filter是否和filebeat中的service保持一致</span><br><span class="line">&lt;img src=&quot;https://img.econow.cn/2018/1539223223935.png&quot; width=&quot;415&quot;/&gt;</span><br><span class="line"></span><br><span class="line">* 检查logstash中的output，service是否一致</span><br><span class="line">&lt;img src=&quot;https://img.econow.cn/2018/1539223282424.png&quot; width=&quot;434&quot;/&gt;</span><br><span class="line"></span><br><span class="line">### logstash时区问题</span><br><span class="line"></span><br><span class="line">2.x</span><br></pre></td></tr></table></figure>

<p>input { stdin {} }<br>output { stdout { codec &#x3D;&gt; rubydebug } }<br>filter {<br>  date {<br>    match &#x3D;&gt; [“message”,”UNIX_MS”]#message在实际应用中修改为自己的字段<br>    target &#x3D;&gt; “@timestamp”<br>  }<br> ruby {<br>   code &#x3D;&gt; “event[‘timestamp’] &#x3D; LogStash::Timestamp.new(event[‘@timestamp’]+ 8<em>60</em>60)”<br> }<br> ruby {<br>   code &#x3D;&gt; “event[‘@timestamp’]&#x3D; event[‘timestamp’]”<br> }<br> mutate {<br>   remove_field &#x3D;&gt; [“timestamp”]<br> }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.x</span><br></pre></td></tr></table></figure>

<p>input { stdin {} }<br>output { stdout { codec &#x3D;&gt; rubydebug } }<br>filter {<br>  date {<br>    match &#x3D;&gt; [“message”,”UNIX_MS”]<br>    target &#x3D;&gt; “@timestamp”<br>  }<br> ruby {<br>   code &#x3D;&gt; “event.set(‘timestamp’, event.get(‘@timestamp’).time.localtime + 8<em>60</em>60)”<br> }<br> ruby {<br>   code &#x3D;&gt; “event.set(‘@timestamp’,event.get(‘timestamp’))”<br> }<br> mutate {<br>   remove_field &#x3D;&gt; [“timestamp”]<br> }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**解决**</span><br><span class="line">如果保证以上配置文件service字段一致，那么基本就没问题了。</span><br><span class="line"></span><br><span class="line">3. logstash 调试</span><br><span class="line"></span><br><span class="line">先上一段配置代码,关于很多文章里面都提到了rubydebug.一看其实也清楚,就是调试的,但是怎么生效能,怎么查看日志呢</span><br><span class="line">需要后面使用--verbose --debug</span><br></pre></td></tr></table></figure>
<p>output {<br>    stdout {<br>        codec &#x3D;&gt; rubydebug<br>    }<br>}</p>
<p> bin&#x2F;logstash -f test_grok.conf –verbose –debug</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这样直接在前台启动,便可以看到日志输出到终端.</span><br><span class="line"></span><br><span class="line">4. logstash Nginx 代理</span><br></pre></td></tr></table></figure>
<p>stream {<br>    upstream logstash {<br>        hash $remote_addr consistent;<br>        server A:4560;<br>        server B:4560;<br>    }<br>    server {<br>        listen       5560;<br>        proxy_pass   logstash;<br>        proxy_protocol on;<br>    }<br>}</p>
<pre><code>
## 相关资料
[http://grokdebug.herokuapp.com/](http://grokdebug.herokuapp.com/)
[https://www.elastic.co/products/beats/filebeat](https://www.elastic.co/products/beats/filebeat)
[https://www.elastic.co/products/elasticsearch](https://www.elastic.co/products/elasticsearch)
[https://www.elastic.co/products/logstash](https://www.elastic.co/products/logstash)
[https://www.elastic.co/products/kibana](https://www.elastic.co/products/kibana)
[http://bbotte.com/logs-service/elasticsearch-template-and-mapping/](http://bbotte.com/logs-service/elasticsearch-template-and-mapping/)
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>Elastalert安装及使用</title>
    <url>/Elastalert%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="报警方式"><a href="#报警方式" class="headerlink" title="报警方式"></a>报警方式</h3><ul>
<li>Email</li>
<li>JIRA</li>
<li>OpsGenie</li>
<li>Commands</li>
<li>HipChat</li>
<li>MS Teams</li>
<li>Slack</li>
<li>Telegram</li>
<li>AWS SNS</li>
<li>VictorOps</li>
<li>PagerDuty</li>
<li>Exotel</li>
<li>Twilio</li>
<li>Gitter</li>
</ul>
<h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ul>
<li>Elasticsearch</li>
<li>Python 2.7</li>
<li>pip</li>
<li>python-pip python-dev libffi-dev libssl-dev</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul>
<li>pip<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install elastalert</span><br></pre></td></tr></table></figure></li>
<li>github<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Yelp/elastalert.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install &quot;setuptools&gt;=11.3&quot;</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<h3 id="elasticsearch-py"><a href="#elasticsearch-py" class="headerlink" title="elasticsearch-py"></a>elasticsearch-py</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Elasticsearch 5.0+:</span><br><span class="line">pip install &quot;elasticsearch&gt;=5.0.0&quot;</span><br><span class="line"></span><br><span class="line">#Elasticsearch 2.X:</span><br><span class="line">pip install &quot;elasticsearch&lt;3.0.0&quot;</span><br></pre></td></tr></table></figure>
<h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><p>提示<code>Could not find suitable distribution for Requirement.parse(&#39;thehive4py&gt;=1.4.</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install thehive4py</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Element-UI的使用总结</title>
    <url>/Element-UI%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h2 id="整理总结"><a href="#整理总结" class="headerlink" title="整理总结"></a>整理总结</h2><h3 id="el-table-column-中-boolean-类型的使用"><a href="#el-table-column-中-boolean-类型的使用" class="headerlink" title="el-table-column 中 boolean 类型的使用"></a>el-table-column 中 boolean 类型的使用</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>某些字段是 Boolean 类型，数据库中存储的是 1 和 0，怎么将其格式化为是和否？</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;是否跨天&quot; align=&quot;center&quot; prop=&quot;sfkt&quot; :formatter=&quot;sfktFormate&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>添加 formatter 属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    sfktFormate(row, index) &#123;</span><br><span class="line">      if (row.sfkt == 1) &#123;</span><br><span class="line">        return &quot;是&quot;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &quot;否&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>其中 row 就是传递的当前行对象，row.sfkt 要对应上面 prop 的 sfkt。这样就能格式化显示为是和否。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Grok Debugger本地化安装</title>
    <url>/Grok%20Debugger%20%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<blockquote>
<p>由于使用ELK对日志进行集中管理，grok表达式无法验证是否正确，所以使用Grok Debugger进行调试，但是由于国外网站上不去（<a href="http://grokdebug.herokuapp.com/%EF%BC%89%EF%BC%8C%E4%BB%8A%E5%A4%A9%E5%8E%BB%E7%94%A8%E5%9B%BD%E5%86%85%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8F%91%E7%8E%B0%E4%B9%9F%E8%BF%9B%E4%B8%8D%E5%8E%BB%E4%BA%86%EF%BC%88http://grok.qiexun.net/%EF%BC%89%EF%BC%8C%E5%A5%BD%E6%97%A0%E5%A5%88%E5%8F%AA%E8%83%BD%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA">http://grokdebug.herokuapp.com/），今天去用国内的一个网站发现也进不去了（http://grok.qiexun.net/），好无奈只能自己动手搭建一个</a>.</p>
</blockquote>
<p>以下内容参考网络搜索到的资料。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install  openssl-devel gcc</span><br><span class="line"></span><br><span class="line">wget https://cache.ruby-china.com/pub/ruby/2.1/ruby-2.1.7.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf ruby-2.1.7.tar.gz -C /usr/local/</span><br><span class="line">cd /usr/local/ruby-2.1.7</span><br><span class="line">./configure --prefix=/usr/local/ruby2.1.7</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">echo &#x27;export PATH=/usr/local/ruby2.1.7/bin:$PATH&#x27;&gt;&gt;/etc/profile</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 安装rubygems工具</span><br><span class="line">[https://rubygems.org/pages/download](https://rubygems.org/pages/download)</span><br><span class="line">wget https://rubygems.org/rubygems/rubygems-3.0.3.tgz</span><br><span class="line">tar zxvf rubygems-3.0.3.tgz -C /usr/local/</span><br><span class="line">cd /usr/local/rubygems-3.0.3/</span><br><span class="line">ruby setup.rb</span><br><span class="line"></span><br><span class="line">#替换gem源</span><br><span class="line">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line">gem sources -l</span><br><span class="line"></span><br><span class="line">#Grokbug的安装</span><br><span class="line">mkdir /usr/local/grokbug</span><br><span class="line">cd /usr/local/grokbug</span><br><span class="line">wget https://codeload.github.com/nickethier/grokdebug/zip/master</span><br><span class="line">unzip master</span><br><span class="line">mv grokdebug-master/* .</span><br><span class="line">rm -rf grokdebug-master/</span><br><span class="line"></span><br><span class="line">#查看缺少的组件，这一步的时候报了点错，但是似乎不影响后面的运行。</span><br><span class="line"></span><br><span class="line">ruby config.ru</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#安装组件及对应的版本，缺少什么就再安装什么</span><br><span class="line">gem install bundler</span><br><span class="line">gem install cabin -v=0.5.0</span><br><span class="line">gem install haml -v=3.1.7</span><br><span class="line">gem install jls-grok -v=0.10.10</span><br><span class="line">gem install json -v=1.7.5</span><br><span class="line">gem install kgio -v=2.8.0</span><br><span class="line">gem install rack -v=1.4.1</span><br><span class="line">gem install rack-protection -v=1.2.0</span><br><span class="line">gem install raindrops -v=0.11.0  </span><br><span class="line">gem install shotgun -v=0.9</span><br><span class="line">gem install tilt -v=1.3.3</span><br><span class="line">gem install sinatra -v=1.3.3</span><br><span class="line">gem install unicorn -v=4.6.3</span><br><span class="line"></span><br><span class="line">#替换Google的jquery源，将使用google的源替换为国内的新浪源</span><br><span class="line">cd views</span><br><span class="line">sed -i &#x27;s#//ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js#//lib.sinaapp.com/js/jquery/1.8.1/jquery.min.js#g&#x27; index.haml</span><br><span class="line">sed -i &#x27;s#//ajax.googleapis.com/ajax/libs/jqueryui/1.9.2/jquery-ui.min.js#//lib.sinaapp.com/js/jquery-ui/1.9.2/jquery-ui.min.js#g&#x27; index.haml</span><br><span class="line">sed -i &#x27;s#//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js#//lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js#g&#x27; patterns.haml</span><br><span class="line">sed -i &#x27;s#//ajax.googleapis.com/ajax/libs/jqueryui/1.9.0/themes/ui-lightness/jquery-ui.css#//lib.sinaapp.com/js/jquery-ui/1.9.0/themes/ui-lightness/jquery-ui.css#g&#x27; layout.haml</span><br><span class="line">sed -i &#x27;s#//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js#//lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js#g&#x27; discover.haml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动服务，9333 就是访问的端口，可以自定义</span><br><span class="line">cd /usr/local/grokbug</span><br><span class="line">unicorn -p 9333 -c ./unicorn  #仅一次运行</span><br><span class="line">#后台运行</span><br><span class="line">nohup bundle exec unicorn -p 9333 -c ./unicorn &amp;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab使用本地Nginx</title>
    <url>/Gitlab%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0Nginx.html</url>
    <content><![CDATA[<h3 id="配置文件编辑"><a href="#配置文件编辑" class="headerlink" title="配置文件编辑"></a>配置文件编辑</h3><p>vi &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb </p>
<ul>
<li>添加：<code>nginx[&#39;enable&#39;] = false</code></li>
<li>Set the username of the non-bundled web-server user 设置gitlab的用户名为你的webserver(也就是我的ngxin)的用户名还是在gitlab.rb中添加：<code>web_server[&#39;external_users&#39;] = [&#39;nginx&#39;]</code>(因为我的nginx的username是‘nginx’)</li>
<li><code>gitlab_rails[&#39;trusted_proxies&#39;] = [ &#39;127.0.0.1&#39; ]</code></li>
<li><code>gitlab_workhorse[&#39;listen_network&#39;] = &quot;tcp&quot;</code></li>
<li><code>gitlab_workhorse[&#39;listen_addr&#39;] = &quot;127.0.0.1:8181&quot;</code></li>
</ul>
<p>我们重载配置文件,执行命令：<code>gitlab-ctl reconfigure</code>等待完成。<code>gitlab-ctl start/stop</code>分别是启动和停止命令</p>
<h3 id="nginx配置文件"><a href="#nginx配置文件" class="headerlink" title="nginx配置文件"></a>nginx配置文件</h3><p>增加一个站点即可，注意监听的是之前配置的8181端口。<br><img data-src="https://img.econow.cn/medivh/1547453735621.png" /></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>H3C wap712c Fit to Fat</title>
    <url>/H3C%20wap712c%20Fit%20to%20Fat.html</url>
    <content><![CDATA[<blockquote>
<p>fat转fit简单，直接在web界面操作即可。但是fit转fat就困难多了。</p>
</blockquote>
<h2 id="TFTP服务器"><a href="#TFTP服务器" class="headerlink" title="TFTP服务器"></a>TFTP服务器</h2><p>MAC：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install tftp</span><br><span class="line"></span><br><span class="line">chmod -R 777 /private/tftpboot</span><br><span class="line">#/private/tftpboot是默认路径，需要改变其读写权限(非常重要)</span><br><span class="line">#开启</span><br><span class="line">sudo launchctl load -F /System/Library/LaunchDaemons/tftp.plist</span><br><span class="line">sudo launchctl start com.apple.tftpd</span><br><span class="line"></span><br><span class="line">#关闭</span><br><span class="line">sudo launchctl unload -F /System/Library/LaunchDaemons/tftp.plist</span><br><span class="line">sudo launchctl stop com.apple.tftpd</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***:~ ***$ tftp</span><br><span class="line">tftp&gt; connect localhost</span><br><span class="line">tftp&gt; status</span><br><span class="line">Connected to localhost.</span><br><span class="line">Mode: netascii Verbose: off Tracing: off</span><br><span class="line">Rexmt-interval: 5 seconds, Max-timeout: 25 seconds</span><br><span class="line">tftp&gt; verbose</span><br><span class="line">Verbose mode on.</span><br><span class="line">tftp&gt; get 1.txt</span><br><span class="line">getting from localhost:1.txt to 1.txt [netascii]</span><br><span class="line">Received 9 bytes in 0.0 seconds [inf bits/sec]</span><br><span class="line">tftp&gt; quit</span><br></pre></td></tr></table></figure>
<p>准备固件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://img.econow.cn/network/apwtu430_v1.06.btw</span><br><span class="line">wget https://img.econow.cn/network/wa4300s_fat.bin</span><br></pre></td></tr></table></figure>
<h2 id="版本降级"><a href="#版本降级" class="headerlink" title="版本降级"></a>版本降级</h2><ul>
<li><p>检查设备信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;H3C&gt;display device manuinfo</span><br><span class="line">DEVICE_NAME:WAP712C</span><br><span class="line">DEVICE_SERIAL_NUMBER:2198  01A0 X491 7CG0 04F8</span><br><span class="line">MAC_ADDRESS:307B-ACB2-5800</span><br><span class="line">MANUFACTURING_DATE:2017-12-20</span><br><span class="line">VENDOR_NAME:H3C</span><br></pre></td></tr></table></figure></li>
<li><p>开机启动检查软件版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System is starting...</span><br><span class="line"></span><br><span class="line">Press Ctrl+D to access BASIC-BOOTWARE MENU</span><br><span class="line"></span><br><span class="line">Booting Normal Extended BootWare</span><br><span class="line"></span><br><span class="line">The Extended BootWare is self-decompressing.................................</span><br><span class="line"></span><br><span class="line">...Done.  </span><br><span class="line"></span><br><span class="line">****************************************************************************</span><br><span class="line"></span><br><span class="line">*                                                                          *</span><br><span class="line"></span><br><span class="line">*                   H3C WA5530 BootWare, Version 7.09                      *</span><br><span class="line"></span><br><span class="line">*                                                                          *</span><br><span class="line"></span><br><span class="line">****************************************************************************</span><br><span class="line"></span><br><span class="line">Copyright (c) 2004-2017 New H3C Technologies Co., Ltd.</span><br></pre></td></tr></table></figure>
<p>注意此处的BootWare版本为7.09，要切换Fat模式必须降级。</p>
</li>
<li><p>降级</p>
</li>
</ul>
<p>第一步 格式化文件系统 Control + F</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==========================&lt;EXTENDED-BOOTWARE MENU&gt;=============</span><br><span class="line"></span><br><span class="line">|&lt;1&gt; Boot System                                                           |</span><br><span class="line"></span><br><span class="line">|&lt;2&gt; Enter Serial SubMenu                                                  |</span><br><span class="line"></span><br><span class="line">|&lt;3&gt; Enter Ethernet SubMenu                                                |</span><br><span class="line"></span><br><span class="line">|&lt;4&gt; File Control                                                          |</span><br><span class="line"></span><br><span class="line">|&lt;5&gt; Restore to Factory Default Configuration                              |</span><br><span class="line"></span><br><span class="line">|&lt;6&gt; Skip Current System Configuration                                     |</span><br><span class="line"></span><br><span class="line">|&lt;7&gt; BootWare Operation Menu                                               |</span><br><span class="line"></span><br><span class="line">|&lt;8&gt; Skip Authentication for Console Login                                 |</span><br><span class="line"></span><br><span class="line">|&lt;9&gt; Storage Device Operation                                              |</span><br><span class="line"></span><br><span class="line">|&lt;0&gt; Reboot                                                                |</span><br></pre></td></tr></table></figure>
<p>第二步：进入V7boot 通过网卡口，传入V6 AP bin文件，提示更新boot版本的时候选择Y</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入V7boot 通过网卡口，传入V6 AP bin文件，提示更新boot版本的时候选择Y</span><br><span class="line"></span><br><span class="line">Enter your choice(0-5): 5</span><br><span class="line"></span><br><span class="line">==========================&lt;ETHERNET PARAMETER SET&gt;==========================</span><br><span class="line">|Note:       &#x27;.&#x27; = Clear field.                                            |</span><br><span class="line">|            &#x27;-&#x27; = Go to previous field.                                   |</span><br><span class="line">|         Ctrl+D = Quit.                                                   |</span><br><span class="line">============================================================================</span><br><span class="line">Protocol (FTP or TFTP) :tftp</span><br><span class="line">Load File Name         :apwtu430_v1.06.btw</span><br><span class="line">                       :</span><br><span class="line">Target File Name       :apwtu430_v1.06.btw</span><br><span class="line">                       :</span><br><span class="line">Server IP Address      :192.168.21.1</span><br><span class="line">Local IP Address       :192.168.21.2</span><br><span class="line">Subnet Mask            :255.255.255.0</span><br><span class="line">Gateway IP Address     :0.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第三步：导入V6 AP版本</p>
<p>简单来说和之前的部分一样，tftp导入</p>
<p>第四步：重启，降级完成</p>
<h2 id="切换模式"><a href="#切换模式" class="headerlink" title="切换模式"></a>切换模式</h2><p>重启完成后，展示以下界面，可以选择FAT模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| &lt;1&gt; Display Current Device Model                          |</span><br><span class="line"></span><br><span class="line">| &lt;2&gt; Set The Device Into FIT AP Model                      |</span><br><span class="line"></span><br><span class="line">| &lt;3&gt; Set The Device Into FAT AP Model                      |</span><br><span class="line"></span><br><span class="line">| &lt;0&gt; Exit To Main Menu     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kms2.h3c.com/View.aspx?id=57788">http://kms2.h3c.com/View.aspx?id=57788</a></p>
<ul>
<li>h3c 公共账号 yx800&#x2F;01230123</li>
<li><a href="https://img.econow.cn/network/wa4300s_fit.bin">https://img.econow.cn/network/wa4300s_fit.bin</a></li>
</ul>
<p>降级boot<br><img data-src="https://img.econow.cn/medivh/1561364179876.png"  /><br>重启，再次格式化<br>切换模式，导入fat镜像文件</p>
<img data-src="https://img.econow.cn/medivh/1561362961838.png"  />


<p>初始化ip</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 主题配置</title>
    <url>/Hexo-Next-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><h4 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h4><p>阿里云省事，但是要记得不是所有域名都可以备案的，尤其是那些便宜的！！！</p>
<h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>有了域名后，xxx.github.io 增加cname<br><img data-src="http://img.econow.cn/2016/1493360584432.png" width="873"/><br>说明：192.30.252.154和192.30.252.153是github服务器对应的ip地址，这步一定要设置，否则访问不了</p>
<h4 id="添加CNAME"><a href="#添加CNAME" class="headerlink" title="添加CNAME"></a>添加CNAME</h4><p>然后回到博客项目根目录，在source&#x2F;下新建一个名为CNAME的文件，里面的内容写入xxxx.com即可。</p>
<h3 id="配置搜索"><a href="#配置搜索" class="headerlink" title="配置搜索"></a>配置搜索</h3><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。<br>安装 hexo-generator-search</p>
<p>在站点的根目录下执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装 hexo-generator-searchdb</span><br><span class="line">$ npm install hexo-generator-search --save</span><br><span class="line">$ npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="启用搜索"><a href="#启用搜索" class="headerlink" title="启用搜索"></a>启用搜索</h4><p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<h4 id="验证搜索"><a href="#验证搜索" class="headerlink" title="验证搜索"></a>验证搜索</h4><img data-src="https://img.econow.cn/medivh/1493345650335.png" width="873"/>

<h3 id="修改背景色"><a href="#修改背景色" class="headerlink" title="修改背景色"></a>修改背景色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim themes/next/source/css/_custom/custom.styl</span><br><span class="line">//Custom styles.</span><br><span class="line">body &#123;</span><br><span class="line">	background:rgb(250, 235, 215);</span><br><span class="line">  #可以设置背景色或者背景图片</span><br><span class="line">&#125;</span><br><span class="line">//首页文章阴影样式</span><br><span class="line">.post &#123;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    margin-bottom: 60px;</span><br><span class="line">    padding: 25px;</span><br><span class="line">    -webkit-box-shadow: 0 0 14px rgba(202, 203, 203, .5);</span><br><span class="line">    -moz-box-shadow: 0 0 14px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开启动画效果"><a href="#开启动画效果" class="headerlink" title="开启动画效果"></a>开启动画效果</h3><p>修改_config.yml,true为开启，false为关闭。<br><img data-src="http://7xp3xc.com1.z0.glb.clouddn.com/2016/1493347316086.png" width="873"/><br>但是有个问题，three_waves这个动画效果开启后，风扇就开始狂转，建议选择其它效果。</p>
<h3 id="开启访问量统计"><a href="#开启访问量统计" class="headerlink" title="开启访问量统计"></a>开启访问量统计</h3><h4 id="申请帐号"><a href="#申请帐号" class="headerlink" title="申请帐号"></a>申请帐号</h4><p><a href="https://leancloud.cn/">注册帐号</a></p>
<h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><img data-src="http://7xp3xc.com1.z0.glb.clouddn.com/2016/1493358213242.png" width="873"/>
#### 创建class
<img data-src="http://7xp3xc.com1.z0.glb.clouddn.com/2016/1493358279110.png" width="873"/>
#### 获取key
<img data-src="http://7xp3xc.com1.z0.glb.clouddn.com/2016/1493358329637.png" width="873"/>
#### 修改配置文件_confi.yml
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: B1L35FebIXXX3MloNCxrCS-gzGzoHsz</span><br><span class="line">  app_key: iQH7DjsXXXMB58gpevWMC</span><br></pre></td></tr></table></figure>
重新加载后就出来了，但是只能在外网访问的时候才会增加。
<img data-src="http://7xp3xc.com1.z0.glb.clouddn.com/2016/1493358386367.png" width="873"/>
按照Next官方手册给的LeanCloud教程
弄完以后，次数格式出现了xx:xx:xx的形式，当时的内心是崩溃的。Why?经多方的研究和询问以后发现是因为Next主题已经集成了LeanCloud，而我们只需要配置主题_config.yml即可，但是，坑爹的又出现了，把教程里面的配置过的东西删除后，次数就完全不显示了，再次经过多方的研究，解决了这个问题，所以在此记录。
### 增加评论功能

<h4 id="获取key"><a href="#获取key" class="headerlink" title="获取key"></a>获取key</h4><p>登录<a href="https://manage.gentie.163.com/">网易云跟帖</a> 获取你的 Product Key<br><img data-src="http://7xp3xc.com1.z0.glb.clouddn.com/2016/1493360341707.png" width="873"/></p>
<h4 id="编辑主题配置文件"><a href="#编辑主题配置文件" class="headerlink" title="编辑主题配置文件"></a>编辑主题配置文件</h4><p>编辑 gentie_productKey 字段，设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gentie_productKey: #your-gentie-product-key</span><br></pre></td></tr></table></figure>
<p>请注意，您在云跟帖管理后台设置的域名必须跟您站点的域名一致</p>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客系统搭建</title>
    <url>/Hexo-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA.html</url>
    <content><![CDATA[<h3 id="初识Hexo"><a href="#初识Hexo" class="headerlink" title="初识Hexo"></a>初识Hexo</h3><p>Hexo是一个快速的、简单的、功能强大的博客框架。你可以通过Markdown语言写文章，然后hexo帮你生成一个带有漂亮主题的静态页面。<br>最近入手了一个树莓派，所以有事没事就想着折腾它，后来无意中看到了hexo的博客，真漂亮！就试着在派上部署一下环境试试。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h4><p>hexo依赖于nodejs，因此记得先装一下nodejs。有些平台上就编译一下吧，比如在树莓派上就得好几个小时，那就在那编译着吧。。。<br>编译安装nodejs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v10.15.3/node-v10.15.3.tar.gz</span><br><span class="line">tar -zxvf node-v10.15.3.tar.gz   </span><br><span class="line">cd node-v10.15.3   </span><br><span class="line">./configure   </span><br><span class="line">make   </span><br><span class="line">make install   </span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p>安装完成后安装hexo<br>Node, npm和Git都安装成功, 开始安装hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo -g</span><br><span class="line">#-g表示全局安装, npm默认为当前项目安装</span><br></pre></td></tr></table></figure>
<h4 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br><span class="line">#hexo 使用git</span><br></pre></td></tr></table></figure>
<h4 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jack:~ jack$ hexo version</span><br><span class="line">hexo-cli: 1.0.2</span><br><span class="line">os: Darwin 15.4.0 darwin x64</span><br><span class="line">http_parser: 2.6.2</span><br><span class="line">node: 5.10.1</span><br><span class="line">v8: 4.6.85.31</span><br><span class="line">uv: 1.8.0</span><br><span class="line">zlib: 1.2.8</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">icu: 56.1</span><br><span class="line">modules: 47</span><br><span class="line">openssl: 1.0.2g</span><br></pre></td></tr></table></figure>

<h4 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init hexo  </span><br><span class="line">#执行init命令初始化到你指定的hexo目录</span><br><span class="line">初始化后目录结构</span><br><span class="line">-rw-r--r--    1 jack  staff  1483  4 21 10:19 _config.yml</span><br><span class="line">drwxr-xr-x  288 jack  staff  9792  4 21 10:24 node_modules/</span><br><span class="line">-rw-r--r--    1 jack  staff   443  4 21 10:19 package.json</span><br><span class="line">drwxr-xr-x    5 jack  staff   170  4 21 10:19 scaffolds/</span><br><span class="line">drwxr-xr-x    3 jack  staff   102  4 21 10:19 source/</span><br><span class="line">drwxr-xr-x    3 jack  staff   102  4 21 10:19 themes/</span><br><span class="line"></span><br><span class="line">npm install    #install before start blogging</span><br><span class="line">hexo generate       #自动根据当前目录下文件,生成静态网页</span><br><span class="line">hexo server         #运行本地服务</span><br></pre></td></tr></table></figure>
<p>浏览器输入<a href="http://localhost:4000/">http://localhost:4000</a>就可以看到效果。</p>
<h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h3><img data-src='http://7xp3xc.com1.z0.glb.clouddn.com/2016/1492755503227.png' width=873>
### 配置域名
repo->settings-> 检查是否和配置文件一致

<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo depoly</span><br></pre></td></tr></table></figure>
<p>访问<br>如果出现404，检查配置文件和域名是否一致。<br><a href="http://xiajieok.github.io/">http://xiajieok.github.io</a></p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>如果出现ERROR Deployer not found: git<br>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>– end</p>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo框架的回顾总结</title>
    <url>/Hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<blockquote>
<p>将近一年多的时间没怎么整理过文档，更多的时候放在笔记里。但是笔记里的记录总是太随意。回过头来看，还是记录在网络上更为安全和踏实。</p>
</blockquote>
<p>若干年前接触到 Hexo 这个框架，从起初的好奇到后来的放弃，中间经历了许多。现在回头看看，也是不错。之前的文档只求快速实现，自此之后，更多关注细节或者更深入的一些东西。</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>想象一下，为什么要使用这个框架来实现一些东西呢？答案是快速和简单。作为当今时代的一个技术从业者，基本有部分人知道 Markdown 是个什么。恰巧我很喜欢这种语法格式，简洁且快速，不用再纠结于格式的调整和样式的美化。<br>所以当初选择了 Hexo。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>此处没有什么可说的。依赖环境就是 Node.js。跨平台，大部分设备都可以使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>官方说的，强烈建议永远安装最新版本的 Hexo，以及 推荐的 Node.js 版本。</p>
<img data-src="https://img.econow.cn/medivh/1610785615949.png"  />

<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装完 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li>source 资源文件夹是存放用户资源的地方。除<code>_posts</code>文件夹之外，开头命名为<code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li>
<li>themes 主题 文件夹。Hexo 会根据主题来生成静态页面。</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><img data-src="https://img.econow.cn/medivh/1610789448691.png"/>

<h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><img data-src="https://img.econow.cn/medivh/1610789480090.png"/>

<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><img data-src="https://img.econow.cn/medivh/1610789507680.png"  />

<blockquote>
<p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p>
</blockquote>
<h4 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h4><img data-src="https://img.econow.cn/medivh/1610789600428.png"/>

<blockquote>
<p>相对地址<br>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com,您有一篇文章名为 hello，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是绝对于域名的。相对链接像这样：&#x2F;hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="文件修改，但是内容没有变化"><a href="#文件修改，但是内容没有变化" class="headerlink" title="文件修改，但是内容没有变化"></a>文件修改，但是内容没有变化</h3><ul>
<li>文件没有提交<ul>
<li>检查 public 目录是否有对应的新的 HTML 文件</li>
<li>检查 Git 仓库是否是否有对应的新的 HTML 文件</li>
</ul>
</li>
<li>仓库地址不对</li>
</ul>
<h3 id="搜索，总是转圈"><a href="#搜索，总是转圈" class="headerlink" title="搜索，总是转圈"></a>搜索，总是转圈</h3><h4 id="搜索插件没有配置好"><a href="#搜索插件没有配置好" class="headerlink" title="搜索插件没有配置好"></a>搜索插件没有配置好</h4><p>问题分析：</p>
<ul>
<li>打开浏览器开发者工具，查看 search.xml 状态，是否 404，如果是则说明不存在</li>
</ul>
<p>安装插件:<br><code>npm install hexo-generator-searchdb --save</code><br>修改根配置文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure>

<p>修改主题配置文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="文章中包含特殊字符"><a href="#文章中包含特殊字符" class="headerlink" title="文章中包含特殊字符"></a>文章中包含特殊字符</h4><p>问题分析：</p>
<ul>
<li>打开浏览器开发者工具，查看 search.xml 状态，文件存在</li>
<li>浏览器访问域名+search.xml，提示报错信息</li>
</ul>
<img data-src="https://img.econow.cn/medivh/1610790341444.png"  />

<ul>
<li>根据报错提示，在控制台定位具体文章标题</li>
<li>用Sublime Text3和Visual Studio Code分别打开文件对比看看，这两个编辑器都找到了特殊字符。删除特殊字符并保存。</li>
</ul>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>在使用过程中，search.xml文件报错的机率越来越高，有没有个好的方法一劳永逸呢？是的，使用JSON。更改文件后缀为JSON即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改_config.yml</span></span><br><span class="line">search:</span><br><span class="line">  path: search.json</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br><span class="line">  content: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="valine-js加载慢"><a href="#valine-js加载慢" class="headerlink" title="valine.js加载慢"></a>valine.js加载慢</h3><p>获取最新的 Valine.min.js 获取地址：<a href="%5Bhttps://www.jsdelivr.com/package/npm/valine">https://www.jsdelivr.com/package/npm/valine</a><br><img data-src="https://img.econow.cn/medivh/1659346848336.png" alt="1659346848336.png"><br>拿到URL之后修改文件，替换链接即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim themes/next/layout/_third-party/comments/valine.swig</span><br><span class="line"><span class="comment"># 更改为</span></span><br><span class="line">&#123;% <span class="built_in">set</span> valine_uri = <span class="string">&#x27;//cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 2.121 部署</title>
    <url>/Jenkins%202.121%20%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JDK     1.8.0_91</span><br><span class="line">Tomecat apache-tomcat-8.0.45</span><br><span class="line">Jenkins 1.121.3</span><br></pre></td></tr></table></figure>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src/ &amp;&amp; tar -zxvf ./jdk1.8.0_91.tar.gz -C /usr/local</span><br><span class="line">ln -s /usr/local/jdk1.8.0_91 /usr/local/java</span><br><span class="line">echo &#x27;</span><br><span class="line">#JDK</span><br><span class="line">############################################################</span><br><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">############################################################</span><br><span class="line">&#x27; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src/</span><br><span class="line">wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.0.5/binaries/apache-maven-3.0.5-bin.tar.gz</span><br><span class="line">tar -zxvf apache-maven-3.0.5-bin.tar.gz  -C /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line">ln -s apache-maven-3.0.5 maven</span><br><span class="line"></span><br><span class="line">echo &#x27;</span><br><span class="line">#maven</span><br><span class="line">############################################################</span><br><span class="line">export MAVEN_HOME=/usr/local/maven</span><br><span class="line">export PATH=$&#123;MAVEN_HOME&#125;/bin:$&#123;PATH&#125;</span><br><span class="line">############################################################</span><br><span class="line">&#x27; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="部署war包"><a href="#部署war包" class="headerlink" title="部署war包"></a>部署war包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war</span><br><span class="line">cp jenkins.war /usr/local/apache-tomcat-8.0.45/webapps</span><br></pre></td></tr></table></figure>
<h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/apache-tomcat-8.0.45/bin/catalina.sh start</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>访问<a href="http://192.168.1.232:8080/jenkins">http://192.168.1.232:8080/jenkins</a> 根据提示输入初始化安装的key<br>如果提示离线安装，可以选择跳过代理设置。之后再设置插件管理中的更新地址，更改https为http。</p>
<blockquote>
<p>注意，有时候第一次启动后登录会出现空白页面，解决方式：重启一下就好了。如果还不能解决，那你就遇上大问题了。youxia</p>
</blockquote>
<h3 id="1-修改主目录"><a href="#1-修改主目录" class="headerlink" title="1 修改主目录"></a>1 修改主目录</h3><ol>
<li>修改&#x2F;etc&#x2F;profile<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">############################################################</span><br><span class="line">JENKINS_HOME=/xxxx/jenkins/data</span><br><span class="line">############################################################</span><br></pre></td></tr></table></figure></li>
<li>修改tomcat<br>增加以下内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JENKINS_HOME=&quot;/xxxx/jenkins/data&quot;</span><br></pre></td></tr></table></figure>



<h3 id="2-配置插件"><a href="#2-配置插件" class="headerlink" title="2 配置插件"></a>2 配置插件</h3><p>系统管理-管理插件-高级，将URL修改为http，然后重新获取即可。<br><img data-src="https://img.econow.cn/medivh/1553484237221.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建项目</span><br><span class="line">切换到指定目录</span><br><span class="line">mvn archetype:create -DgroupId=com.learn -DartifactId=LearnNew -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes job的深入理解</title>
    <url>/Kubernetes%20job%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html</url>
    <content><![CDATA[<p>Deployment、StatefulSet以及DeamonSet这三种编排概念都有一些共同点，实际上编排的对象都是在线业务。一般的在线业务是一种长时间的作业，比如NGINX、Tomcat，这些应用一旦运行起来，除非出错或者停止，否则容器进程会一直保持在Running状态。</p>
<p>还有一类是离线业务，或者叫做Batch Job。这种业务在计算完成后就直接退出了。</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes关于StorageClass的应用——Flare</title>
    <url>//Kubernetes%E5%85%B3%E4%BA%8EStorageClass%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94Flare</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在折腾NAS和虚拟机的时候发现一个问题，部署的应用和服务太多了，有点记不住地址和端口了，所以需要一个导航页来展示这一切。</p>
<p>本想自己开发一个单页面应用呢，但是想到vue或react，对于前端的东西能不碰就不想碰，所以找到了一个开源的项目——flare。恰巧搭建了一个Kubernetes集群，正好练习一下。</p>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><h3 id="Storage-Class"><a href="#Storage-Class" class="headerlink" title="Storage Class"></a>Storage Class</h3><h4 id="什么是Storage-Class"><a href="#什么是Storage-Class" class="headerlink" title="什么是Storage Class"></a>什么是Storage Class</h4><p>Kubernetes提供了一套可以自动创建PV的机制，即：Dynamic Provisioning。而这个机制的核心在于StorageClass这个API对象。</p>
<p>StorageClass对象会定义下面两部分内容:</p>
<ol>
<li>PV的属性。比如，存储类型，Volume的大小等。</li>
<li>创建这种PV需要用到的存储插件，即存储制备器。</li>
</ol>
<p>有了这两个信息之后，Kubernetes就能够根据用户提交的PVC，找到一个对应的StorageClass，之后Kubernetes就会调用该StorageClass声明的存储插件，进而创建出需要的PV。</p>
<h4 id="为什么用Storage-Class"><a href="#为什么用Storage-Class" class="headerlink" title="为什么用Storage Class"></a>为什么用Storage Class</h4><p>在一个大规模的Kubernetes集群里，可能有成千上万个PVC，这就意味着运维人员必须实现创建出这个多个PV，此外，随着项目的需要，会有新的PVC不断被提交，那么运维人员就需要不断的添加新的，满足要求的PV，否则新的Pod就会因为PVC绑定不到PV而导致创建失败。而且通过 PVC 请求到一定的存储空间也很有可能不足以满足应用对于存储设备的各种需求。</p>
<p>而且不同的应用程序对于存储性能的要求可能也不尽相同，比如读写速度、并发性能等，为了解决这一问题，Kubernetes 又为我们引入了一个新的资源对象：StorageClass，通过 StorageClass 的定义，管理员可以将存储资源定义为某种类型的资源，比如快速存储、慢速存储等，用户根据 StorageClass 的描述就可以非常直观的知道各种存储资源的具体特性了，这样就可以根据应用的特性去申请合适的存储资源了。</p>
<p>pvc是无法直接去向nfs-client-provisioner申请使用的存储空间的，这时，就需要通过SC这个资源对象去申请了，SC的根本作用就是根据pvc定义的来动态创建pv，不仅节省了我们管理员的时间，还可以封装不同类型的存储供pvc选用。</p>
<h4 id="Storage-Class资源"><a href="#Storage-Class资源" class="headerlink" title="Storage Class资源"></a>Storage Class资源</h4><p>每个sc都包含以下三个重要的字段，这些字段会在sc需要动态分配pv时会使用到：</p>
<ul>
<li>Provisioner（供给方）：提供了存储资源的存储系统。</li>
<li>ReclaimPolicy：pv的回收策略，可用的值有Delete（默认）和Retiain</li>
<li>Parameters（参数）：存储类使用参数描述要关联到存储卷。</li>
</ul>
<p>每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV。 该字段必须指定。</p>
<table>
<thead>
<tr>
<th>插件</th>
<th>内置制备器</th>
<th>配置例子</th>
</tr>
</thead>
<tbody><tr>
<td>AWSElasticBlockStore</td>
<td>✓</td>
<td>AWS EBS</td>
</tr>
<tr>
<td>AzureFile</td>
<td>✓</td>
<td>Azure File</td>
</tr>
<tr>
<td>AzureDisk</td>
<td>✓</td>
<td>Azure Disk</td>
</tr>
<tr>
<td>CephFS</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Cinder</td>
<td>✓</td>
<td>OpenStack Cinder</td>
</tr>
<tr>
<td>FC</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>FlexVolume</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Flocker</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>GCEPersistentDisk</td>
<td>✓</td>
<td>GCE PD</td>
</tr>
<tr>
<td>Glusterfs</td>
<td>✓</td>
<td>Glusterfs</td>
</tr>
<tr>
<td>iSCSI</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Quobyte</td>
<td>✓</td>
<td>Quobyte</td>
</tr>
<tr>
<td>NFS</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>RBD</td>
<td>✓</td>
<td>Ceph RBD</td>
</tr>
<tr>
<td>VsphereVolume</td>
<td>✓</td>
<td>vSphere</td>
</tr>
<tr>
<td>PortworxVolume</td>
<td>✓</td>
<td>Portworx Volume</td>
</tr>
<tr>
<td>ScaleIO</td>
<td>✓</td>
<td>ScaleIO</td>
</tr>
<tr>
<td>StorageOS</td>
<td>✓</td>
<td>StorageOS</td>
</tr>
<tr>
<td>Local</td>
<td>-</td>
<td>Local</td>
</tr>
</tbody></table>
<p>回收策略，由 StorageClass 动态创建的 PersistentVolume 会在类的 reclaimPolicy 字段中指定回收策略，可以是 Delete 或者 Retain。如果 StorageClass 对象被创建时没有指定 reclaimPolicy，它将默认为 Delete。</p>
<h3 id="flare"><a href="#flare" class="headerlink" title="flare"></a>flare</h3><p>轻量、快速、美观的个人导航页面，适用于 HomeLab 或其他注重私密的场景。<br>支持 x86 以及常见的 ARM (ARM32v6、ARM32v7、ARM64v8)设备，应用资源消耗非常低：</p>
<ul>
<li>CPU: &lt; 1%</li>
<li>MEM: &lt; 30M</li>
<li>Docker Image: &lt; 10M</li>
</ul>
<p>使用方式很简单：</p>
<ol>
<li>下载Git仓库</li>
<li>使用docker启动，注意挂载<code>/app</code>目录</li>
</ol>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="创建Storage-class"><a href="#创建Storage-class" class="headerlink" title="创建Storage class"></a>创建Storage class</h3><p>要使用 StorageClass，我们就得安装对应的自动配置程序，比如我们这里存储后端使用的是 nfs，那么我们就需要使用到一个 nfs-client 的自动配置程序，我们也叫它 Provisioner（制备器），这个程序使用我们已经配置好的 nfs 服务器，来自动创建持久卷，也就是自动帮我们创建 PV。</p>
<ol>
<li>自动创建的 PV 以${namespace}-${pvcName}-${pvName}这样的命名格式创建在 NFS 服务器上的共享数据目录中</li>
<li>而当这个 PV 被回收后会以archieved-${namespace}-${pvcName}-${pvName}这样的命名格式存在 NFS 服务器上。</li>
</ol>
<p><img data-src="https://img.econow.cn/medivh/1669884658926.png" alt="1669884658926.png"></p>
<p>注意在所有节点安装<code>yum -y install nfs-utils</code>.</p>
<p>创建rbac权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-provisioner</span><br><span class="line">  namespace: default</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-provisioner-runner</span><br><span class="line">  namespace: default</span><br><span class="line">rules:</span><br><span class="line">   -  apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">      resources: [<span class="string">&quot;persistentvolumes&quot;</span>]</span><br><span class="line">      verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line">   -  apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">      resources: [<span class="string">&quot;persistentvolumeclaims&quot;</span>]</span><br><span class="line">      verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">   -  apiGroups: [<span class="string">&quot;storage.k8s.io&quot;</span>]</span><br><span class="line">      resources: [<span class="string">&quot;storageclasses&quot;</span>]</span><br><span class="line">      verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line">   -  apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">      resources: [<span class="string">&quot;events&quot;</span>]</span><br><span class="line">      verbs: [<span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span><br><span class="line">   -  apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">      resources: [<span class="string">&quot;services&quot;</span>, <span class="string">&quot;endpoints&quot;</span>]</span><br><span class="line">      verbs: [<span class="string">&quot;get&quot;</span>,<span class="string">&quot;create&quot;</span>,<span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>,<span class="string">&quot;update&quot;</span>]</span><br><span class="line">   -  apiGroups: [<span class="string">&quot;extensions&quot;</span>]</span><br><span class="line">      resources: [<span class="string">&quot;podsecuritypolicies&quot;</span>]</span><br><span class="line">      resourceNames: [<span class="string">&quot;nfs-provisioner&quot;</span>]</span><br><span class="line">      verbs: [<span class="string">&quot;use&quot;</span>]</span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: run-nfs-provisioner</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nfs-provisioner</span><br><span class="line">    namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: nfs-provisioner-runner</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>

<p>执行yaml文件。我们新建的一个名为nfs-provisioner的ServiceAccount，然后绑定了一个名为nfs-provisioner-runner的ClusterRole，而该ClusterRole声明了一些权限，其中就包括对pv的增，删，改，查等权限，所以我们可以利用该serviceAccount来自动创建pv。</p>
<p>创建NFS的deployment：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: Recreate</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nfs-client-provisioner</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-client-provisioner</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccount: nfs-provisioner</span><br><span class="line">      containers:</span><br><span class="line">        - name: nfs-client-provisioner</span><br><span class="line">          image: registry.cn-hangzhou.aliyuncs.com/open-ali/nfs-client-provisioner</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: nfs-client-root</span><br><span class="line">              mountPath:  /persistentvolumes</span><br><span class="line">          <span class="built_in">env</span>:</span><br><span class="line">            - name: PROVISIONER_NAME</span><br><span class="line">              value: nfs-deploy    <span class="comment">#供给方的名称（自定义）</span></span><br><span class="line">            - name: NFS_SERVER</span><br><span class="line">              value: 192.168.31.98     <span class="comment">#nfs服务器的ip地址</span></span><br><span class="line">            - name: NFS_PATH</span><br><span class="line">              value: /mnt/free/nfs      <span class="comment">#nfs共享的目录</span></span><br><span class="line">      volumes:</span><br><span class="line">        - name: nfs-client-root</span><br><span class="line">          nfs:</span><br><span class="line">            server: 192.168.31.98</span><br><span class="line">            path: /mnt/free/nfs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行yaml文件，检查pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master-51 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">nfs-client-provisioner-7d9b557c55-9vs77   1/1     Running   0          16m</span><br></pre></td></tr></table></figure>

<p>创建storage class:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: stateful-nfs</span><br><span class="line">  namespace: default</span><br><span class="line">provisioner: nfs-deploy</span><br><span class="line">reclaimPolicy: Retain</span><br></pre></td></tr></table></figure>

<p>我们声明了一个名为statefu-nfs的sc对象，注意下面的provisioner字段对应的值一定要和上面的nfs的Deployment下面的PROVISIONER_NAME这个环境变量的值一样。</p>
<p>执行yaml文件，检查该资源对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master-51 ~]<span class="comment"># kubectl get storageclass</span></span><br><span class="line">NAME           PROVISIONER   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">stateful-nfs   nfs-deploy    Retain          Immediate           <span class="literal">false</span>                  1m</span><br></pre></td></tr></table></figure>

<p>动态创建PVC</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: flare</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  storageClassName: stateful-nfs</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 100Mi</span><br></pre></td></tr></table></figure>

<p>执行yaml文件，检查是否创建了对应的PVC。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master-51 flare]<span class="comment"># kubectl get pvc</span></span><br><span class="line">NAME    STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">flare   Bound    pvc-ed851458-fe37-4095-a6e5-4838e46a58d0   100Mi      RWX            stateful-nfs   1m</span><br></pre></td></tr></table></figure>

<h3 id="部署flare"><a href="#部署flare" class="headerlink" title="部署flare"></a>部署flare</h3><p>编辑yaml文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: flare</span><br><span class="line">  name: flare</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: flare</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: flare</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: soulteary/flare</span><br><span class="line">        name: flare</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: flare-app</span><br><span class="line">          mountPath: /app</span><br><span class="line">      volumes:</span><br><span class="line">      - name: flare-app</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: flare</span><br></pre></td></tr></table></figure>

<p>执行yaml文件，检查pod文件nfs。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master-51 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">flare-5c57955b54-rj6hr                    1/1     Running   0          2m</span><br><span class="line">nfs-client-provisioner-7d9b557c55-9vs77   1/1     Running   0          7m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查nfs目录</span></span><br><span class="line"></span><br><span class="line">root@truenas[...-ed851458-fe37-4095-a6e5-4838e46a58d0]<span class="comment"># ll</span></span><br><span class="line">total 39</span><br><span class="line">drwxrwxrwx 2 nobody   5 Dec  1 14:55 ./</span><br><span class="line">drwxrwxrwx 3 nfs      6 Dec  1 14:42 ../</span><br><span class="line">-rwxr-xr-x 1 nobody 418 Dec  1 15:51 apps.yml*</span><br><span class="line">-rwxr-xr-x 1 nobody 733 Dec  1 15:51 bookmarks.yml*</span><br><span class="line">-rwxr-xr-x 1 nobody 467 Dec  1 14:58 config.yml*</span><br><span class="line">root@truenas[...-ed851458-fe37-4095-a6e5-4838e46a58d0]<span class="comment"># pwd</span></span><br><span class="line">/mnt/free/nfs/default-flare-pvc-ed851458-fe37-4095-a6e5-4838e46a58d0</span><br></pre></td></tr></table></figure>

<p>临时使用nodeport的方式访问：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: flare</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 35005</span><br><span class="line">    targetPort: 5005</span><br><span class="line">    nodePort: 35005</span><br><span class="line">  selector:</span><br><span class="line">    app: flare</span><br></pre></td></tr></table></figure>

<p>之后可以考虑使用ingress或者其他方式。</p>
<p>访问页面，很美好：</p>
<p><img data-src="https://img.econow.cn/medivh/1669886114176.png" alt="1669886114176.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到的问题：</p>
<p>**问题 1.**：unexpected error getting claim reference: selfLink was empty, can’t make reference<br><strong>解决</strong> Kubernetes 1.20及以后版本禁用了 selfLink 所致。修改 &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-apiserver.yaml，添加 - –feature-gates&#x3D;RemoveSelfLink&#x3D;false 后重新部署。</p>
<p>**问题 2.**：waiting for a volume to be created, either by external provisioner “fuseim.pri&#x2F;ifs” or manually created by system administrator<br><strong>解决</strong> Kubernetes 1.20及以后版本禁用了 selfLink 所致。修改 &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-apiserver.yaml，添加 - –feature-gates&#x3D;RemoveSelfLink&#x3D;false 后重新部署。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/soulteary/docker-flare">https://github.com/soulteary/docker-flare</a></li>
<li><a href="https://hub.docker.com/r/soulteary/flare">https://hub.docker.com/r/soulteary/flare</a></li>
<li><a href="https://blog.csdn.net/u012069313/article/details/125264651">Kubernetes常见报错</a></li>
</ul>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes的最佳实践</title>
    <url>//Kubernetes%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5</url>
    <content><![CDATA[<p>Kubernetes 作为最流行的容器编排系统已经成为大部分运维需要掌握的一项基本技能。而很好的掌握它应该做什么和不应该做什么，将是一个很好的开局。</p>
<h2 id="程序开发"><a href="#程序开发" class="headerlink" title="程序开发"></a>程序开发</h2><h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>使用不同的命名空间，以限制组的访问控制以及可能发生任何错误的爆炸半径。<br>还可以针对命名空间配置limitRange对象，以定义命名空间中容器的标准大小。ResourceQuotas可以限制命名空间内所有容器的总资源消耗。</p>
<h3 id="使用就绪和存活探针"><a href="#使用就绪和存活探针" class="headerlink" title="使用就绪和存活探针"></a>使用就绪和存活探针</h3><p>就绪和存活两种探针本质上都是健康检查的类型。<br>当就绪探针确保当pod准备好为请求提供服务时，才会将Pod的请求定向到它。<br>存活探针将应用程序是否正在允许将其作为是否健康的标志。</p>
<h3 id="使用自动伸缩"><a href="#使用自动伸缩" class="headerlink" title="使用自动伸缩"></a>使用自动伸缩</h3><p>在适当的情况下，可以使用自动伸缩来动态调整Pod的数量（Pod水平伸缩，HPA）、（Pod垂直伸缩，VPA）或集群的节点数量（集群自动伸缩，CA），具体取决于对资源的需求。</p>
<p>使用伸缩时也会带来一些挑战，比如持久化数据。</p>
<h3 id="使用资源请求和约束"><a href="#使用资源请求和约束" class="headerlink" title="使用资源请求和约束"></a>使用资源请求和约束</h3><p>设置资源请求和约束可以避免容器在未分配所需资源的情况下启动，或集群用尽可用资源。如没有限制，Pod可以使用比所需要的更多的资源，从而导致可用资源总量减少。</p>
<h3 id="使用deployment、DaemonSet、RelicaSet或SattefulSet跨节点部署Pod"><a href="#使用deployment、DaemonSet、RelicaSet或SattefulSet跨节点部署Pod" class="headerlink" title="使用deployment、DaemonSet、RelicaSet或SattefulSet跨节点部署Pod"></a>使用deployment、DaemonSet、RelicaSet或SattefulSet跨节点部署Pod</h3><p>永远不应该直接运行Pod。为了提高容错性，Pod应该始终作为Deployment、DaemonSet、ReplicaSet或SatefulSet的一部分。然后可以部署中使用反亲和性规则跨节点部署Pod，避免所有Pod调度到同一个节点上运行。</p>
<h2 id="集群治理"><a href="#集群治理" class="headerlink" title="集群治理"></a>集群治理</h2><h3 id="使用多节点"><a href="#使用多节点" class="headerlink" title="使用多节点"></a>使用多节点</h3><p>如果提升可靠性，在单个节点上运行k8s不是一个好主意。集群中应该使用多个节点，一遍可以在他们之间分散工作负载。</p>
<h3 id="使用RBAC"><a href="#使用RBAC" class="headerlink" title="使用RBAC"></a>使用RBAC</h3><p>RABC可以为用户、组合service account分配权限，以在特定命名空间或整个集群执行被运行的操作。<br>主意分配权限应仅授予所需的权限。</p>
<h3 id="使用云服务"><a href="#使用云服务" class="headerlink" title="使用云服务"></a>使用云服务</h3><p>将k8s托管在云上会更轻松。</p>
<h3 id="升级版本"><a href="#升级版本" class="headerlink" title="升级版本"></a>升级版本</h3><p>新版本会更安全些，还会引入新功能。</p>
<h3 id="监控集群资源和审计策略日志"><a href="#监控集群资源和审计策略日志" class="headerlink" title="监控集群资源和审计策略日志"></a>监控集群资源和审计策略日志</h3><p>针对APIServer的日志进行分析和监控。</p>
<h3 id="使用版本控制"><a href="#使用版本控制" class="headerlink" title="使用版本控制"></a>使用版本控制</h3><p>对编排文件进行版本控制，对更改进行审计跟踪，有助于提高集群的稳定性。</p>
<h3 id="使用精简镜像"><a href="#使用精简镜像" class="headerlink" title="使用精简镜像"></a>使用精简镜像</h3><p>较小的镜像有助于加速构建和部署速度，减少容器在集群上消耗的资源量。</p>
<h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><h3 id="用标签治理对象"><a href="#用标签治理对象" class="headerlink" title="用标签治理对象"></a>用标签治理对象</h3><p>在云环境中对资源使用标签，以跟踪与业务相关的事务。</p>
<h3 id="使用网络策略"><a href="#使用网络策略" class="headerlink" title="使用网络策略"></a>使用网络策略</h3><p>使用网络策略限制集群中对象之间的流量。</p>
<h3 id="使用防火墙"><a href="#使用防火墙" class="headerlink" title="使用防火墙"></a>使用防火墙</h3><p>限制外部对APIServer的请求。</p>
<h2 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h2><p>在kubernetes中，常见的“自动伸缩”有：</p>
<ul>
<li>HPA：Pod水平伸缩</li>
<li>VPA：Pod垂直伸缩</li>
<li>CA：集群自动伸缩</li>
</ul>
<p>不同类型的自动伸缩器，应用的场景不同。</p>
<blockquote>
<p>HPA，HPA 定期检查内存和CPU等指标，自动跳转Deployment中副本数量。<br>VPA，无法通过调整Pod数量来扩容是，可以通过VPA增加Pod资源的大小，比如调整CPU和内存。<br>CA。当集群资源不足时，CA会自动配置新的计算资源并添加到集群中。</p>
</blockquote>
<h3 id="HPA"><a href="#HPA" class="headerlink" title="HPA"></a>HPA</h3><p>HPA 可以基于CPU使用率来自动伸缩Pod的数量，还可以基于其他指标，比如：</p>
<ul>
<li>Resource metrics CPU、内存使用率</li>
<li>Pod metrics 网络利用率和流量</li>
<li>Object metrics 特定对象的指标，比如Ingress，可以按每秒使用请求数来扩展容器</li>
<li>Custom metrics 自定义监控，比如定义服务响应时间</li>
</ul>
<p>工作原理：<strong>定时检测每个Pod指标的平均值，并检测删除或添加副本，是否会使该值更接近目标</strong>。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul>
<li>为HPA提供每个pod的资源指标，metrics-server；</li>
<li>为每个容器配置指标阈值，HPA根据指标的阈值来做出伸缩的决策；</li>
<li>使用自定义指标，确保使用正确的目标类型</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个HPA用来控制上述步骤中的Deployment，是Pod副本数量维持在1~10。HPA通过改变Pod副本的数量以保持所有Pod的平均CPU使用率在50%以内。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">        <span class="attr">averageUtilization:</span> <span class="number">50</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="VPA"><a href="#VPA" class="headerlink" title="VPA"></a>VPA</h3><p>VPA，即使垂直Pod自动伸缩，是根据容器资源使用率自动设置CPU和内存的requests，从而允许在节点上进行适当的调度。既可以缩小过度请求资源的容器，也可以根据使用情况提升资源不足的容量。</p>
<p>组件：</p>
<ul>
<li>Recommender 监控资源利用率并计算目标值，并推荐一个理想的资源请求值</li>
<li>Updater 检查Pod资源限制是否需要更新</li>
<li>Admission Controller 在创建Pod时覆盖其资源请求</li>
</ul>
<h4 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol>
<li>避免在Kubernetes的1.11版本之前使用</li>
<li>使用updateMode:OFF运行VPA，以及了解要自动伸缩的Pod的资源使用情况，为以后调整做基础</li>
<li>如果工作负载经常出现高使用率和低使用率的峰值，则VPA过于激进，使用HPA效果会更好</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>注意使用VPA需要先部署 <a href="https://github.com/kubernetes/autoscaler.git">autoscaler</a>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">vpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">250Mi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">vpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>创建VPA：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VerticalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-vpa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">vpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">targetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">&quot;apps/v1&quot;</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">updatePolicy:</span></span><br><span class="line">    <span class="attr">updateMode:</span> <span class="string">&quot;Off&quot;</span></span><br><span class="line">  <span class="attr">resourcePolicy:</span></span><br><span class="line">    <span class="attr">containerPolicies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerName:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">      <span class="attr">minAllowed:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;100Mi&quot;</span></span><br><span class="line">      <span class="attr">maxAllowed:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;2000m&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;2048Mi&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意<code>updateMode</code>设置为<code>Auto</code>的时候才会自动调整。使用限制：</p>
<ul>
<li>不能和HPA共存</li>
<li>Pod使用副本控制器，比如Deployment或StatefulSet</li>
</ul>
<p>优势：</p>
<ul>
<li>Pod资源用其所需，所以集群节点使用效率高</li>
<li>Pod会被安排到具有适当资源的节点上</li>
<li>不必运行基准测试任务来确定CPU和内存的请求和食指</li>
<li>VPA可以随时调整资源设置，无需手动操作</li>
</ul>
<h3 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h3><p>CA是基于Pod来扩展集群节点，会定期检查是否有不可调度的的的Pod，如需更多资源，并且扩展的集群仍然在用户提供的约束范围内，则会调整集群的大小。</p>
<p>影响的因素：</p>
<ol>
<li>HPA的响应耗时</li>
<li>CA的响应耗时</li>
<li>节点的初始化耗时</li>
<li>Pod创建耗时</li>
</ol>
<p>默认情况下，kubelet每10秒抓取一下Pod的CPU和内存使用情况；<br>每分钟，Metrices Server将聚合的指标开放给API Server及其他组件使用；<br>CA 每10秒排查不可调度的Pod。&lt;100个节点，每个节点最大30个Pod，平均延迟在5s。100到1000个节点时，平均延迟在15s左右；<br>节点的配置时间，通常在3~5分钟；<br>容器创建Pod，在几秒到1分钟不等。</p>
<p>因此对于小的集群，最差的情况可能在6分钟左右，大的集群则可能在7分钟以上。因此，压缩时间的方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HPA 的刷新时间，默认 15 秒，通过 --horizontal-pod-autoscaler-sync-period 标志控制;</span><br><span class="line"></span><br><span class="line">Metrics Server 的指标抓取时间，默认 60 秒，通过 metric-resolution 控</span><br><span class="line"></span><br><span class="line">CA 的扫描间隔，默认 10 秒，通过 scan-interval 控制;</span><br><span class="line"></span><br><span class="line">节点上缓存镜像，比如 kube-fledged等工具;</span><br></pre></td></tr></table></figure>

<p>总之，尽量避免被动创建新节点，主动创建新节点。</p>
<h4 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol>
<li>选择和Kubernetes匹配的版本</li>
<li>检查集群节点是否有相同的CPU和内存，否则无法正常工作，因为它假设每个节点都有相同的资源</li>
<li>确保自动伸缩的Pod都有指定的资源请求</li>
</ol>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes的调度</title>
    <url>/Kubernetes%E7%9A%84%E8%B0%83%E5%BA%A6.html</url>
    <content><![CDATA[<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>kube-scheduler 是kubernetes 集群的默认调度器，该调度器将Pod绑定在对应的node上，之后对应的node上的kubelet才能够创建和运行Pod。<br>对每个新建的Pod或者未被调度的Pod，kube-scheduler 会选择一个最优的node去运行这个Pod。Pod内的每个容器以及自身都有不通的资源需求。因此，Pod在被调度之前，会根据特定的资源调度需求，对集群中的Node进行一次过滤。<br>调度器会在集群中过滤后的可调度节点，根据一些列函数进行打分，最终选择出得分最高的node。之后，调度器将这个调度通知给kube-apiserver，进行绑定。</p>
<h2 id="亲和性"><a href="#亲和性" class="headerlink" title="亲和性"></a>亲和性</h2><p>原则</p>
<ul>
<li>同时指定了nodeSelector和nodeAffinity，必须同时满足两个条件</li>
<li>如果nodeAffinity指定了多个nodeSelectorTerms，满足一个即可</li>
<li>如果在nodeSelectorTerms中有多个matchExpressions,则一个节点必须满足全部才可以加</li>
<li>如果修改或删除了Pod所调度到的节点的标签，Pod不会被删除</li>
<li>软策略中的weight属性代表权重，范围1-100。如果存在多个软策略的话，权重越大越亲和。对于反亲和规则而言，权重越大越不亲和</li>
</ul>
<p>应用的运行对于kubernetes在亲和性上有一些要求，可以概况为以下几个方面：</p>
<ol>
<li>Pod固定调度的某些节点上</li>
<li>Pod不会调度到某些节点上</li>
<li>Pod的多个副本调度到相同节点上</li>
<li>Pod的多个副本调度不同节点上</li>
</ol>
<h3 id="调度到某些节点上"><a href="#调度到某些节点上" class="headerlink" title="调度到某些节点上"></a>调度到某些节点上</h3><h4 id="方式一、nodeSelector"><a href="#方式一、nodeSelector" class="headerlink" title="方式一、nodeSelector"></a>方式一、nodeSelector</h4><p>在对于Pod的定义中通过nodeSelector指定label，Pod将会只调度到具有该标签的node上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">env</span>: <span class="built_in">test</span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: ssd</span><br></pre></td></tr></table></figure>

<p>上述例子中，Pod将会只调度到包含disktype&#x3D;ssd的node上。</p>
<h4 id="方式二、nodeName"><a href="#方式二、nodeName" class="headerlink" title="方式二、nodeName"></a>方式二、nodeName</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: webpc</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: webpc</span><br><span class="line">    spec:</span><br><span class="line">      nodeName: web-server</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>上述例子中，将会只调度到主机名为web-server的node上。</p>
<h4 id="方式三、亲和性"><a href="#方式三、亲和性" class="headerlink" title="方式三、亲和性"></a>方式三、亲和性</h4><p>NodeAffinity 亲和性调度，用来取代nodeSelector的策略，支持IN，NOTLn，exists,doesNotExit,GT,Lt。</p>
<p>又分为两类：</p>
<ol>
<li>soft，表示调度的时候，无法满足节点的时候会选择非nodeSelector匹配的节点。PreferredDuringSchedulingIgnoreDuringExecution 优先满足制定规则，并不强求</li>
<li>hard，表示调度的时候，必须满足亲和性设置。requiredDuringSchedulingIgnoredDuringExecution 必须调度到满足条件的节点，如不满足，则一直重试。</li>
</ol>
<p>也可以分为三类：</p>
<ol>
<li>亲和节点 NodeAffinity</li>
<li>亲和Pod podAffinity</li>
<li>不亲和Pod podAntiAffinity</li>
</ol>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: eureka</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;eureka&quot;</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: eureka-pod</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: eureka-pod</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">              - matchExpressions:</span><br><span class="line">                - key: kubernetes.io/hostname</span><br><span class="line">                  operator: In</span><br><span class="line">                  values:</span><br><span class="line">                    - k8s-node-217</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证，新的Pod已经调度到k8s-node-217</span></span><br><span class="line">~<span class="comment"># kubectl get pods -o wide |grep eureka</span></span><br><span class="line">eureka-0                  1/1     Running             0          2d23h   10.200.128.142   uat-master     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">eureka-1                  1/1     Running             0          2d23h   10.200.128.141   uat-master     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">eureka-2                  0/1     ContainerCreating   0          1s      &lt;none&gt;           k8s-node-217   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述示例中，terms满足一个条件就行（或的关系），但是match的条件必须全部满足（且的关系）。</p>
<h3 id="调度到不同的节点"><a href="#调度到不同的节点" class="headerlink" title="调度到不同的节点"></a>调度到不同的节点</h3><p>调度到不同的节点，在亲和性中的应用需要使用到topolgyKey。toplogyKey 对应的值是node上的一个标签的名称，比如节点zone&#x3D;A 标签，其他节点有zone&#x3D;B 标签。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KIND:     StatefulSet</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: affinity &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     If specified, the pod<span class="string">&#x27;s scheduling constraints</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     Affinity is a group of affinity scheduling rules.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FIELDS:</span></span><br><span class="line"><span class="string">   nodeAffinity	&lt;Object&gt;</span></span><br><span class="line"><span class="string">     Describes node affinity scheduling rules for the pod.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   podAffinity	&lt;Object&gt;</span></span><br><span class="line"><span class="string">     Describes pod affinity scheduling rules (e.g. co-locate this pod in the</span></span><br><span class="line"><span class="string">     same node, zone, etc. as some other pod(s)).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   podAntiAffinity	&lt;Object&gt;</span></span><br><span class="line"><span class="string">     Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod</span></span><br><span class="line"><span class="string">     in the same node, zone, etc. as some other pod(s)).</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl explain --api-version=apps/v1 sts.spec.template.spec.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution.topologyKey</span><br><span class="line">KIND:     StatefulSet</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">FIELD:    topologyKey &lt;string&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     This pod should be co-located (affinity) or not co-located (anti-affinity)</span><br><span class="line">     with the pods matching the labelSelector <span class="keyword">in</span> the specified namespaces, <span class="built_in">where</span></span><br><span class="line">     co-located is defined as running on a node whose value of the label with</span><br><span class="line">     key topologyKey matches that of any node on <span class="built_in">which</span> any of the selected pods</span><br><span class="line">     is running. Empty topologyKey is not allowed.</span><br></pre></td></tr></table></figure>

<p>topology 就是拓扑的意思，指的是一个拓扑域，一个范围的概念，比如一个node、一个机柜、一个机房，实际对应的是node的标签。而这里的topologyKey对应的是node上标签的Key。那么怎么样才算属于一个拓扑域呢？</p>
<p>如果使用<code>k8s.io/hostname</code>，则表示拓扑域为node范围，那么<code>k8s.io/hostname</code> 对应的值不一样的就是不同的拓扑域。比如Pod1在<code>k8s.io/hostname=n1</code>的node上，Pod2在<code>k8s.io/hostname=n2</code>的node上，Pod3在<code>k8s.io/hostname=n1</code>的node上。那么Pod1和Pod3在一个拓扑域，Pod2 则和其他两个Pod不在同一个拓扑域。因此，概况来说，拥有相同标签的key，就可以认定为在同一个拓扑域。</p>
<p>原则上，topologyKey可以是任何合法的标签key，但是有一些限制：</p>
<ol>
<li>topologyKey不可以为空</li>
<li>对于 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 的 Pod 反亲和性，引入 LimitPodHardAntiAffinityTopology 准入控制器来限制 topologyKey 只能是 kubernetes.io&#x2F;hostname。如果要使用自定义拓扑域，则可以修改准入控制器，或者直接禁用它。</li>
<li>对于 preferredDuringSchedulingIgnoredDuringExecution 的 Pod 反亲和性，空的 topologyKey 表示所有拓扑域。除上述情况外，topologyKey 可以是任何合法的标签 key。</li>
</ol>
<p>此外，还有一些官网文档中提示的拓扑域可以使用：</p>
<ol>
<li>topology.kubernetes.io&#x2F;region</li>
<li>topology.kubernetes.io&#x2F;zone</li>
</ol>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: eureka</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;eureka&quot;</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: eureka-pod</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: eureka-pod</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        podAntiAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            - topologyKey: kubernetes.io/hostname</span><br><span class="line">              labelSelector:</span><br><span class="line">                matchExpressions:</span><br><span class="line">                - key: app</span><br><span class="line">                  operator: In</span><br><span class="line">                  values:</span><br><span class="line">                  - eureka-pod</span><br></pre></td></tr></table></figure>

<p>上述示例中指定创建了label为<code>app=eureka-pod</code> 的statefulSet，并且指定副本数量为3。根据反亲和性规则，以<code>kubernetes.io/hostname</code>为key的拓扑域，将不会调度到node上已经运行了label为<code>app=eureka-pod</code>的Pod，这样就会将3个副本分别部署在不同hostname的node上。</p>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~<span class="comment"># kubectl get pods -o wide |grep eureka</span></span><br><span class="line">eureka-0                  1/1     Running   0          5m47s   10.200.128.152   uat-master     &lt;none&gt;           &lt;none&gt;</span><br><span class="line">eureka-1                  0/1     Pending   0          38s     &lt;none&gt;           &lt;none&gt;         &lt;none&gt;           &lt;none&gt;</span><br><span class="line">eureka-2                  1/1     Running   0          108s    10.200.96.155    k8s-node-217   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>由于示例中只有两个node，因此有一个Pod处于pending状态，但是其他的两个节点均被分配了Pod。</p>
<p>亲和性的进阶应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        - topologyKey: kubernetes.io/hostname</span><br><span class="line">          labelSelector:</span><br><span class="line">            matchExpressions:</span><br><span class="line">            - key: app</span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">              - eureka-pod</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        - topologyKey: kubernetes.io/hostname</span><br><span class="line">          labelSelector:</span><br><span class="line">            matchExpressions:</span><br><span class="line">            - key: app</span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">              - geteway-pod</span><br></pre></td></tr></table></figure>

<p>上述例子中，根据反亲和性和亲和性规则，每个节点上都会有eureka-pod的Pod，和gateway-pod的Pod。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://kubernetes.io/zh/docs/reference/labels-annotations-taints/">https://kubernetes.io/zh/docs/reference/labels-annotations-taints/</a></li>
</ol>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 日常整理</title>
    <url>/Linux%20%E6%97%A5%E5%B8%B8%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><h4 id="the-NTP-socket-is-in-use-exiting问题"><a href="#the-NTP-socket-is-in-use-exiting问题" class="headerlink" title="the NTP socket is in use, exiting问题"></a>the NTP socket is in use, exiting问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@esx4 ~]# ntpdate ntp.api.bz</span><br><span class="line">21 Sep 14:39:09 ntpdate[24744]: the NTP socket is in use, exiting</span><br><span class="line"></span><br><span class="line">[root@esx4 ~]# service ntpd stop</span><br><span class="line">Shutting down ntpd:                                        [  OK  ]</span><br><span class="line"></span><br><span class="line">[root@esx4 ~]# ntpdate 0.debian.pool.ntp.org</span><br><span class="line">21 Sep 15:22:43 ntpdate[25723]: step time server 114.80.81.1 offset 2312.159684 sec</span><br></pre></td></tr></table></figure>
<h4 id="同步crontab"><a href="#同步crontab" class="headerlink" title="同步crontab"></a>同步crontab</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;59 23 * * * /usr/sbin/ntpdate 0.debian.pool.ntp.org &gt;&gt; /var/log/time.log &amp;&amp; hwclock --systohc 2&gt;&amp;1&quot; &gt;&gt; /etc/crontab</span><br></pre></td></tr></table></figure>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><h4 id="大于2T的分区"><a href="#大于2T的分区" class="headerlink" title="大于2T的分区"></a>大于2T的分区</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parted  /dev/sdb</span><br><span class="line">mklabel gpt --建立gpt标签</span><br><span class="line">mkpart primary 0% 100%  （开始和终止位置）</span><br><span class="line">print   查看结果</span><br><span class="line">quit 退出</span><br><span class="line"></span><br><span class="line">mkfs.ext4 /dev/sdb</span><br><span class="line"></span><br><span class="line">mkdir /data</span><br><span class="line">mount  /dev/sdb /data</span><br></pre></td></tr></table></figure>
<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hadoop01-bj-a src]# blk</span><br><span class="line">blkdeactivate  blkdiscard     blkid</span><br><span class="line">[root@hadoop01-bj-a src]# blkid</span><br><span class="line">/dev/vda1: UUID=&quot;976105f5-f402-456c-aadd-50de49ff88f9&quot; TYPE=&quot;ext4&quot;</span><br><span class="line">/dev/vdb1: UUID=&quot;7f7dfded-4bbd-4a38-b823-1ddf904be9db&quot; TYPE=&quot;ext4&quot;</span><br><span class="line">[root@hadoop01-bj-a src]# cat /etc/fstab</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># /etc/fstab</span><br><span class="line"># Created by anaconda on Thu Aug 17 07:38:21 2017</span><br><span class="line">#</span><br><span class="line"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span><br><span class="line"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span><br><span class="line">#</span><br><span class="line">UUID=976105f5-f402-456c-aadd-50de49ff88f9 /                       ext4    defaults        1 1</span><br><span class="line">UUID=976105f5-f402-456c-aadd-50de49ff88f9 /opt                    ext4    defaults        0 0</span><br></pre></td></tr></table></figure>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cd /usr/src/ &amp;&amp; tar -zxvf ./jre-8u191-linux-x64.tar.gz -C /usr/local</span><br><span class="line">ln -s /usr/local/jdk1.8.0_91/ /usr/local/java</span><br><span class="line">echo &#x27;</span><br><span class="line">#JDK</span><br><span class="line">############################################################</span><br><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">############################################################</span><br><span class="line">&#x27; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd /usr/src/ &amp;&amp; wget 10.110.1.18/open-falcon-agnt.tar.gz &amp;&amp; tar -xvf open-falcon-agnt.tar.gz -C /usr/local &amp;&amp; chmod 755 /usr/local/open-falcon -R  &amp;&amp; cd   /usr/local/open-falcon</span><br><span class="line">./open-falcon start agent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="name-or-service-not-known"><a href="#name-or-service-not-known" class="headerlink" title="name or service not known"></a>name or service not known</h3><p>配置jumpserver发邮件的时候提示<code>name or service not known</code>。<br>检查发现能ping通<code>smtp.exmail.qq.com</code>，但是不知道为啥发不出邮件</p>
<p>使用以下命令，然后加入hosts文件,即可<br><img data-src="https://img.econow.cn/medivh/1551426333101.png" /><br><img data-src="https://img.econow.cn/medivh/1551426435903.png" /></p>
<h3 id="查看文件编码"><a href="#查看文件编码" class="headerlink" title="查看文件编码"></a>查看文件编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim </span><br><span class="line"></span><br><span class="line">:set fileencoding</span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查找30天以前的文件</span><br><span class="line">find . -name &quot;*.png&quot; -ctime +1</span><br><span class="line"></span><br><span class="line">find -name april*                      在当前目录下查找以april开始的文件</span><br><span class="line">find -name april* fprint file        在当前目录下查找以april开始的文件，并把结果输出到file中</span><br><span class="line">find -name ap* -o -name may* 查找以ap或may开头的文件</span><br><span class="line">find /mnt -name tom.txt -ftype vfat 在/mnt下查找名称为tom.txt且文件系统类型为vfat的文件</span><br><span class="line">find /mnt -name t.txt ! -ftype vfat   在/mnt下查找名称为tom.txt且文件系统类型不为vfat的文件</span><br><span class="line">find /tmp -name wa* -type l           在/tmp下查找名为wa开头且类型为符号链接的文件</span><br><span class="line">find /home -mtime -2                 在/home下查最近两天内改动过的文件</span><br><span class="line">find /home   -atime -1                  查1天之内被存取过的文件</span><br><span class="line">find /home -mmin   +60                  在/home下查60分钟前改动过的文件</span><br><span class="line">find /home -amin +30                  查最近30分钟前被存取过的文件</span><br><span class="line">find /home -newer tmp.txt             在/home下查更新时间比tmp.txt近的文件或目录</span><br><span class="line">find /home -anewer tmp.txt            在/home下查存取时间比tmp.txt近的文件或目录</span><br><span class="line">find /home -used -2                  列出文件或目录被改动过之后，在2日内被存取过的文件或目录</span><br><span class="line">find /home -user cnscn                列出/home目录内属于用户cnscn的文件或目录</span><br><span class="line">find /home -uid +501                 列出/home目录内用户的识别码大于501的文件或目录</span><br><span class="line">find /home -group cnscn              列出/home内组为cnscn的文件或目录</span><br><span class="line">find /home -gid 501                   列出/home内组id为501的文件或目录</span><br><span class="line">find /home -nouser                    列出/home内不属于本地用户的文件或目录</span><br><span class="line">find /home -nogroup                   列出/home内不属于本地组的文件或目录</span><br><span class="line">find /home   -name tmp.txt   -maxdepth 4 列出/home内的tmp.txt 查时深度最多为3层</span><br><span class="line">find /home -name tmp.txt -mindepth 3 从第2层开始查</span><br><span class="line">find /home -empty                     查找大小为0的文件或空目录</span><br><span class="line">find /home -size +512k               查大于512k的文件</span><br><span class="line">find /home -size -512k               查小于512k的文件</span><br><span class="line">find /home -links +2                 查硬连接数大于2的文件或目录</span><br><span class="line">find /home -perm 0700                查权限为700的文件或目录</span><br><span class="line">find /tmp -name tmp.txt -exec cat &#123;&#125; /;</span><br><span class="line">find /tmp -name tmp.txt -ok rm &#123;&#125; /;</span><br><span class="line"></span><br><span class="line">find   / -amin   -10       # 查找在系统中最后10分钟访问的文件</span><br><span class="line">find   / -atime -2         # 查找在系统中最后48小时访问的文件</span><br><span class="line">find   / -empty              # 查找在系统中为空的文件或者文件夹</span><br><span class="line">find   / -group cat        # 查找在系统中属于 groupcat的文件</span><br><span class="line">find   / -mmin -5         # 查找在系统中最后5分钟里修改过的文件</span><br><span class="line">find   / -mtime -1        #查找在系统中最后24小时里修改过的文件</span><br><span class="line">find   / -nouser             #查找在系统中属于作废用户的文件</span><br><span class="line">find   / -user   fred       #查找在系统中属于FRED这个用户的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-name filename             #查找名为filename的文件</span><br><span class="line">-perm                       #按执行权限来查找</span><br><span class="line">-user   username            #按文件属主来查找</span><br><span class="line">-group groupname            #按组来查找</span><br><span class="line">-mtime -n +n               #按文件更改时间来查找文件，-n指n天以内，+n指n天以前</span><br><span class="line">-atime   -n +n              #按文件访问时间来查</span><br><span class="line">-perm                        #按执行权限来查找</span><br><span class="line">-user   username            #按文件属主来查找</span><br><span class="line">-group groupname            #按组来查找</span><br><span class="line">-mtime -n +n               #按文件更改时间来查找文件，-n指n天以内，+n指n天以前</span><br><span class="line">-atime   -n +n              #按文件访问时间来查找文件，-n指n天以内，+n指n天以前 </span><br><span class="line">-ctime   -n +n              #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 </span><br><span class="line">-nogroup                    #查无有效属组的文件，即文件的属组在/etc/groups中不存在</span><br><span class="line">-nouser                     #查无有效属主的文件，即文件的属主在/etc/passwd中不存</span><br><span class="line">-newer f1 !f2              找文件，-n指n天以内，+n指n天以前 </span><br><span class="line">-ctime   -n +n              #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 </span><br><span class="line">-nogroup                    #查无有效属组的文件，即文件的属组在/etc/groups中不存在</span><br><span class="line">-nouser                     #查无有效属主的文件，即文件的属主在/etc/passwd中不存</span><br><span class="line">-newer f1 !f2              #查更改时间比f1新但比f2旧的文件</span><br><span class="line">-type    b/d/c/p/l/f        #查是块设备、目录、字符设备、管道、符号链接、普通文件</span><br><span class="line">-size     n[c]              #查长度为n块[或n字节]的文件</span><br><span class="line">-depth                      #使查找在进入子目录前先行查找完本目录</span><br><span class="line">-fstype                     #查更改时间比f1新但比f2旧的文件</span><br><span class="line">-type    b/d/c/p/l/f        #查是块设备、目录、字符设备、管道、符号链接、普通文件</span><br><span class="line">-size     n[c]              #查长度为n块[或n字节]的文件</span><br><span class="line">-depth                      #使查找在进入子目录前先行查找完本目录</span><br><span class="line">-fstype                     #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到</span><br><span class="line">-mount                      #查文件时不跨越文件系统mount点</span><br><span class="line">-follow                     #如果遇到符号链接文件，就跟踪链接所指的文件</span><br><span class="line">-cpio                   #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到</span><br><span class="line">-mount                      #查文件时不跨越文件系统mount点</span><br><span class="line">-follow                     #如果遇到符号链接文件，就跟踪链接所指的文件</span><br><span class="line">-cpio                       #对匹配的文件使用cpio命令，将他们备份到磁带设备中</span><br><span class="line">-prune                      #忽略某个目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取昨天 </span><br><span class="line">date -d &#x27;yesterday&#x27;  # 或 date -d &#x27;last day&#x27; </span><br><span class="line"># 获取明天 </span><br><span class="line">date -d &#x27;tomorrow&#x27;   # 或 date -d &#x27;next day&#x27; </span><br><span class="line"># 获取上个月 </span><br><span class="line">date -d &#x27;last month&#x27; </span><br><span class="line"># 获取下个月 </span><br><span class="line">date -d &#x27;next month&#x27; </span><br><span class="line"># 获取上一年 </span><br><span class="line">date -d ’last year&#x27; </span><br><span class="line"># 获取下一年 </span><br><span class="line">date -d &#x27;next year&#x27; </span><br><span class="line">此外你可以获取多天前，多天后，多个月前，多个月后，多年前或多年后 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 三年前 </span><br><span class="line">date -d &#x27;3 year ago&#x27; </span><br><span class="line"># 五年后 </span><br><span class="line">date -d &#x27;-5 year ago&#x27; </span><br><span class="line"># 两天后 </span><br><span class="line">date -d &#x27;-2 day ago&#x27; </span><br><span class="line"># 一个月前 </span><br><span class="line">date -d &#x27;1 month ago&#x27; </span><br></pre></td></tr></table></figure>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查找指定日期的内容</span><br><span class="line">sed -n &#x27;/^2019-03-14/p&#x27; xxx.info.log &gt; new.log</span><br><span class="line"></span><br><span class="line">#删除指定行</span><br><span class="line">sed -i &#x27;1,14430d&#x27; xx.info.log</span><br><span class="line"></span><br><span class="line">#删除指定行，例如第5行</span><br><span class="line">sed -i &#x27;5 d&#x27; test.txt</span><br><span class="line"></span><br><span class="line">#删除首行</span><br><span class="line">sed -i &#x27;1d&#x27; test.txt</span><br><span class="line"></span><br><span class="line">#删除末行</span><br><span class="line">sed -i &#x27;$d&#x27; test.txt</span><br><span class="line"></span><br><span class="line">#删除空行</span><br><span class="line">sed -i &#x27;/^$/d&#x27; test.txt</span><br><span class="line"></span><br><span class="line">#剔除空格</span><br><span class="line">sed -i &#x27;s/[ ]*//g&#x27; test.txt</span><br><span class="line"></span><br><span class="line">#删除车符</span><br><span class="line">sed -i &#x27;s/^M//g&#x27; test.txt</span><br><span class="line"></span><br><span class="line">#删除指定字段的下一行</span><br><span class="line">sed -i &#x27;/test/&#123;n;d&#125;&#x27; test.txt  #匹配到test字段</span><br><span class="line"></span><br><span class="line">#删除指定字段的上一行</span><br><span class="line">sed -i -e :a -e &#x27;$!N;s/.*n(.*test)/1/;ta&#x27; -e &#x27;P;d&#x27; test.txt    #匹配到test字段</span><br></pre></td></tr></table></figure>


<p>CentOS的启动出错：</p>
<p>当执行 ifup ens33</p>
<p>出现错误：Error:Connection activation failed: No suitable device found for this connection</p>
<p>解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig NetworkManager off</span><br><span class="line">chkconfig network on</span><br><span class="line">service NetworkManager stop</span><br><span class="line">service network start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="切割大文件"><a href="#切割大文件" class="headerlink" title="切割大文件"></a>切割大文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">split -b 100m 1111.log (按照字节分隔)</span><br><span class="line">split -l 1000000 1111.log(按照行数分隔)</span><br></pre></td></tr></table></figure>

<h3 id="journalctl日志文件清理"><a href="#journalctl日志文件清理" class="headerlink" title="journalctl日志文件清理"></a>journalctl日志文件清理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --disk-usage</span><br><span class="line">Journals take up 3.8G on disk.</span><br></pre></td></tr></table></figure>

<p>手动删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --vacuum-time=7d</span><br><span class="line">journalctl --vacuum-size=1024M</span><br></pre></td></tr></table></figure>
<p>控制目录大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/systemd/journald.conf</span><br><span class="line">SystemMaxUse=1G</span><br></pre></td></tr></table></figure>
<p>如果不生效，重启该服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl kill --kill-who=main --signal=SIGUSR2 systemd-journald.service</span><br></pre></td></tr></table></figure>
<p>校验是否正常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --verify</span><br></pre></td></tr></table></figure>

<h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line"></span><br><span class="line">yum -y install python-pip</span><br></pre></td></tr></table></figure>



<h3 id="Nginx-代理"><a href="#Nginx-代理" class="headerlink" title="Nginx 代理"></a>Nginx 代理</h3><p>作用：给爬虫服务器做代理服务器</p>
<p>遇到的问题：访问部分机器的时候出现少量504错误</p>
<p>解决：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastcgi_buffers 8 128k;</span><br><span class="line">send_timeout 60;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#user  nobody;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    fastcgi_buffers 8 128k;</span><br><span class="line">    send_timeout 60;</span><br><span class="line">    gzip  on;</span><br><span class="line"></span><br><span class="line">   server&#123;</span><br><span class="line">        listen   2019;</span><br><span class="line">        resolver 100.100.2.136;</span><br><span class="line">        proxy_connect;</span><br><span class="line">        proxy_connect_allow            443 563;</span><br><span class="line">        proxy_connect_connect_timeout  10s;</span><br><span class="line">        proxy_connect_read_timeout     10s;</span><br><span class="line">        proxy_connect_send_timeout     10s;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">		        proxy_pass	http://$http_host$request_uri;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="初试化"><a href="#初试化" class="headerlink" title="初试化"></a>初试化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown root:root /etc/passwd /etc/shadow /etc/group /etc/gshadow</span><br><span class="line">chmod 0644 /etc/group  </span><br><span class="line">chmod 0644 /etc/passwd  </span><br><span class="line">chmod 0400 /etc/shadow  </span><br><span class="line">chmod 0400 /etc/gshadow </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 磁盘经常出现一些的问题的总结</title>
    <url>/Linux-%E7%A3%81%E7%9B%98%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E4%B8%80%E4%BA%9B%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<blockquote>
<p>Linux磁盘空间经常会出现一些或多或少的问题。比如磁盘空间不足。但是有些时候是真的磁盘空间不足吗？</p>
</blockquote>
<h1 id="常规流程"><a href="#常规流程" class="headerlink" title="常规流程"></a>常规流程</h1><p>在收到一条告警信息的时候，一定要先检查一下磁盘是否真的空间不足。否则，走下去的可能就是一条弯路！</p>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>优先推荐使用<code>df -h</code>命令，否则用<code>du -h</code>的话，就要遍历磁盘中的所有文件，这是绝对不允许的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">or</span><br><span class="line">du -sh /xxx</span><br></pre></td></tr></table></figure>
<p>因此我们可以结合着使用，先在根目录下找出那个子目录是最大的，然后使用 <code>du -sh</code>来排查。</p>
<h2 id="查看最大的文件目录"><a href="#查看最大的文件目录" class="headerlink" title="查看最大的文件目录"></a>查看最大的文件目录</h2><p>查询当前目录，哪个目录占用空间最大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du -sh --max-depth=1</span><br></pre></td></tr></table></figure>
<h2 id="查看最大的文件"><a href="#查看最大的文件" class="headerlink" title="查看最大的文件"></a>查看最大的文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lhS</span><br></pre></td></tr></table></figure>
<p>综上所述，如果找到了占用空间最大的文件或者目录。说明这是一般的问题。</p>
<h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><h2 id="已删除文件被进程所占用"><a href="#已删除文件被进程所占用" class="headerlink" title="已删除文件被进程所占用"></a>已删除文件被进程所占用</h2><p>有时候文件已经被删除了，但是进程依然在使用它。因此导致，在进程运行期间，Linux并不会释放该文件的存储空间。因此需要找出这个进程，杀死或者重启。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof |grep deleted</span><br></pre></td></tr></table></figure>

<h2 id="inode不足"><a href="#inode不足" class="headerlink" title="inode不足"></a>inode不足</h2><p>文件系统中有一些元数据，用来保存文件的相关信息。文件系统中的inode数量是固定的，因此可能inode已经耗尽了，而文件系统本身还没用完。如果真的不足了，那就删除无用和过去的文件来释放吧。可以用以下命令检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df -i</span><br></pre></td></tr></table></figure>
<h3 id="inode不足引发的问题"><a href="#inode不足引发的问题" class="headerlink" title="inode不足引发的问题"></a>inode不足引发的问题</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>发现6400多的进程都是sleep状态，load值较高，内存使用率持续上升</p>
<h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><p>偶然发现inode使用率到了100%，排查哪个目录下文件过多</p>
<ul>
<li>检查哪个磁盘出现的问题</li>
<li>检查哪个目录 <code>for i in /*; do echo $i; find $i |wc -l|sort -nr; done</code></li>
<li>然后逐级查下去</li>
</ul>
<p>最终发现是&#x2F;var&#x2F;spool&#x2F;maildrop 有问题，直接rm -rf ,但是提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Argument list too long</span><br></pre></td></tr></table></figure>

<p>在linux中删除大量文件时，直接用rm会出现：<code>-bash: /bin/rm: 参数列表过长</code>错误。<br>这时可以用find命令来结合使用。<br>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rm * -rf 改为:</span><br><span class="line">find . -name &quot;*&quot; | xargs rm -rf &#x27;*&#x27;</span><br><span class="line"></span><br><span class="line"># rm test* -rf 改为:</span><br><span class="line">find . -name &quot;test*&quot; | xargs rm -rf &quot;test*&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="坏块"><a href="#坏块" class="headerlink" title="坏块"></a>坏块</h2><p>最后一个很常见的问题就是坏的文件系统块。除非另有标记，否则操作系统很可能会认为这些块都是可用的，这会导致文件系统损坏或者硬盘坏死。最好是使用带 -cc 标志的 fsck 搜索并标记出这些块。记住，你不能使用正在使用的文件系统中的 fsck 命令。你应该会要用到 live CD。最后这种情况，目前的确没有遇到过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上内容是常见的磁盘空间不足的处理访问，基本能覆盖绝大部分场景。很多时候单纯处理问题并不困难，复杂的是找出事件的原因。对病下药，才是正道。其实，这个问题还可以延伸一下，比如现在是磁盘空间不足，那么是什么导致不足的呢？之后如何规避呢，写一些脚本，还是某代码有问题。。。。。。</p>
<p>参考资料：[1] Nick Congleton <a href="https://linux.cn/article-9196-1.html">如何解决 Linux 中“磁盘空间不足”的问题</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Logstash 输出到 hdfs</title>
    <url>/Logstash%20%E8%BE%93%E5%87%BA%E5%88%B0%20hdfs.html</url>
    <content><![CDATA[<blockquote>
<p>由于ES集群价格较为昂贵，相对来讲还是Hadoop平台便宜，耐用。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>logstash 可以直接把文件内容写入 hdfs 中， 并支持 hdfs 压缩格式。但是需要安装第三方插件，webhdfs插件，通过hdfs的web接口写入，即 <a href="http://namenode00:50070/webhdfs/v1/">http://namenode00:50070/webhdfs/v1/</a> 接口。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/elk/logstash/bin/logstash-plugin install logstash-output-webhdfs-discontinued</span><br></pre></td></tr></table></figure>
<p>一般情况下不会出问题，至少我目前没有遇到过。</p>
<h3 id="检查hdfs端口是否可访问"><a href="#检查hdfs端口是否可访问" class="headerlink" title="检查hdfs端口是否可访问"></a>检查hdfs端口是否可访问</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl  hdfs:50070</span><br></pre></td></tr></table></figure>

<h2 id="配置output"><a href="#配置output" class="headerlink" title="配置output"></a>配置output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">fileter&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">    if [serverType] == &quot;xxxx&quot; &#123;</span><br><span class="line">       webhdfs &#123;</span><br><span class="line">        host =&gt; &quot;x.x.x.x&quot; # hdfs 主机</span><br><span class="line">        port =&gt; 50070   # hdfs 端口</span><br><span class="line">        flush_size =&gt; 500</span><br><span class="line">        idle_flush_time =&gt; 10</span><br><span class="line">        user =&gt; &quot;hdfs&quot;   # hdfs 用户</span><br><span class="line">        path =&gt; &quot;/data/log/%&#123;+YYYYMMdd&#125;_xxxxx.log&quot;</span><br><span class="line">        compression =&gt; &quot;gzip&quot;   # 压缩模式</span><br><span class="line">        codec =&gt; &#x27;json&#x27;         </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置好重启即可。</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>上述配置文件中基本为必选项或者为建议参考值。</p>
<img data-src="https://img.econow.cn/medivh/1568025146014.png"  />
<img data-src="https://img.econow.cn/medivh/1568025165706.png"  />


<h3 id="压缩模式说明"><a href="#压缩模式说明" class="headerlink" title="压缩模式说明"></a>压缩模式说明</h3><img data-src="https://img.econow.cn/medivh/1568025379386.png"  />

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.elastic.co/guide/en/logstash/6.4/plugins-outputs-webhdfs.html">https://www.elastic.co/guide/en/logstash/6.4/plugins-outputs-webhdfs.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>elk,hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 初始化环境</title>
    <url>/Mac%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%8E%AF%E5%A2%83.html</url>
    <content><![CDATA[<blockquote>
<p>很多时候，没有人愿意重装系统，除非万不得已。<br>在拥有一台刚初始化操作系统后的笔记本后，停下来想一想自己要做什么。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>安装优秀的终端管理工具iTerm2&#x2F;zsh以及包管理工具homebrew</li>
<li>安装开发环境<ul>
<li>Python<ul>
<li>pip</li>
<li>virtualenv</li>
</ul>
</li>
<li>redis</li>
<li>mysql</li>
<li>nginx</li>
</ul>
</li>
<li>其他常用软件<ul>
<li>KVM管理工具</li>
<li>图床</li>
</ul>
</li>
</ol>
<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><h3 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h3><p>安装<br><a href="https://img.econow.cn/iTerm2-3_4_10.zip">https://img.econow.cn/iTerm2-3_4_10.zip</a></p>
<h3 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="brew的备份和恢复"><a href="#brew的备份和恢复" class="headerlink" title="brew的备份和恢复"></a>brew的备份和恢复</h4><p>homebrew-bundle可以帮助我们备份已安装的包和app们，这样我们在重装系统或者换电脑后可以一键恢复安装，节省时间。</p>
<ul>
<li>–describe代表会加上包的描述</li>
<li>–force代表覆盖已有的文件</li>
<li>–file指定输出文件</li>
</ul>
<p>参考示例：<br>备份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew bundle dump --describe --force --all --file=&quot;~/Desktop/Brewfile&quot;</span><br></pre></td></tr></table></figure>

<p>恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 mas</span><br><span class="line">brew install mas</span><br><span class="line"># 批量安装软件 </span><br><span class="line">brew bundle --file=&quot;~/Desktop/Brewfile&quot;</span><br></pre></td></tr></table></figure>

<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<h4 id="bash-zsh切换"><a href="#bash-zsh切换" class="headerlink" title="bash&#x2F;zsh切换"></a>bash&#x2F;zsh切换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.econow.cn/medivh/1632292508749.png" alt="1632292508749.png"></p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo easy_install pip</span><br><span class="line">sudo pip install requests</span><br></pre></td></tr></table></figure>

<h4 id="pip源"><a href="#pip源" class="headerlink" title="pip源"></a>pip源</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">豆瓣 https://pypi.douban.com/simple</span><br><span class="line">阿里云 https://mirrors.aliyun.com/pypi/simple</span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">中国科学技术大学 https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">官方 https://pypi.python.org/simple/</span><br></pre></td></tr></table></figure>

<h4 id="pip-加速"><a href="#pip-加速" class="headerlink" title="pip 加速"></a>pip 加速</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">format = columns</span><br></pre></td></tr></table></figure>

<p>插件目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Users/medivh/.oh-my-zsh/plugins</span><br></pre></td></tr></table></figure>

<h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br><span class="line"># 不安装任何第三方包</span><br><span class="line">virtualenv --no-site-packages venv </span><br><span class="line"></span><br><span class="line"># 指定版本</span><br><span class="line">virtualenv -p /usr/bin/python2.7 venv</span><br><span class="line"></span><br><span class="line">#激活虚拟环境</span><br><span class="line">source venv/bin/activate</span><br><span class="line"></span><br><span class="line">#推出虚拟环境</span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h4 id="Mac-redis"><a href="#Mac-redis" class="headerlink" title="Mac redis"></a>Mac redis</h4><p><code>brew install redis</code><br>开机启动<br><code>brew services start redis</code></p>
<p>配置文件<br><code>/usr/local/etc/redis.conf</code></p>
<p>编辑配置文件 配置后台运行<br><code>daemonize yes</code></p>
<p>服务端启动及查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server /usr/local/etc/redis.conf</span><br><span class="line">ps aux | grep redis</span><br></pre></td></tr></table></figure>

<p>客户端调用<br><code>redis-cli</code></p>
<p>给redis设置密码<br>打开redis.conf文件，找到以下配置项<br><code># requirepass foobared</code><br>更改为<br><code>requirepass 你的密码</code><br>注意：由于上诉操作更改了redis.conf文件，所以下次再启动的时候，要手动加载一下redis.conf文件。例如<br>进入到redis根目录，启动如下<br><code>redis-server /usr/local/etc/redis.conf</code></p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="Markdown-图床"><a href="#Markdown-图床" class="headerlink" title="Markdown 图床"></a>Markdown 图床</h3><p>参考<a href="http://econow.cn/markdown%20%E5%9B%BE%E5%BA%8A%E7%94%9F%E6%88%90.html">http://econow.cn/markdown%20%E5%9B%BE%E5%BA%8A%E7%94%9F%E6%88%90.html</a></p>
<h3 id="vs-code"><a href="#vs-code" class="headerlink" title="vs code"></a>vs code</h3><ul>
<li>安装vs code</li>
<li>安装插件 markdownlint evermonkey</li>
<li>配置插件-印象笔记<ul>
<li>命令行输入 ever tokent，然后分别粘贴evermonkey.token, evermonkey.noteStoreUrl</li>
<li>新建笔记 option+n</li>
<li>推送笔记 option+</li>
</ul>
</li>
</ul>
<h3 id="hexo-环境"><a href="#hexo-环境" class="headerlink" title="hexo 环境"></a>hexo 环境</h3><p>参考<a href="http://econow.cn/Hexo-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA.html">http://econow.cn/Hexo-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA.html</a></p>
<h3 id="Mac-kvm"><a href="#Mac-kvm" class="headerlink" title="Mac kvm"></a>Mac kvm</h3><p><a href="https://github.com/jeffreywildman/homebrew-virt-manager.git">https://github.com/jeffreywildman/homebrew-virt-manager.git</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap jeffreywildman/homebrew-virt-manager</span><br><span class="line">brew install virt-manager virt-viewer</span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line">virt-manager -c &#x27;qemu+ssh://user@libvirthost/system?socket=/var/run/libvirt/libvirt-sock&#x27;</span><br><span class="line">virt-viewer -c &#x27;qemu+ssh://user@libvirthost/system?socket=/var/run/libvirt/libvirt-sock&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Mac-部分进程负载较高（bird）"><a href="#Mac-部分进程负载较高（bird）" class="headerlink" title="Mac 部分进程负载较高（bird）"></a>Mac 部分进程负载较高（bird）</h3><ul>
<li>关闭iCloud 文稿&#x2F;桌面的备份</li>
<li>从iCloud中复制出来文稿里面的文件，因为关闭同步后文稿会自动清空。其实感觉这个就像软链</li>
</ul>
]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 初试化的记忆</title>
    <url>/Mac-%E5%88%9D%E8%AF%95%E5%8C%96%E7%9A%84%E8%AE%B0%E5%BF%86.html</url>
    <content><![CDATA[<blockquote>
<p>每重装一次系统感觉就要减少一个月的寿命。人生如此短暂，还是少些忧愁吧。</p>
</blockquote>
<p>重装系统后基本的配置路线：终端-&gt;开发-&gt;浏览器。浏览器最主要的配置就是同步标签和数据，关于Chrome浏览器的同步就自行解决吧。</p>
<h2 id="Mac-重装"><a href="#Mac-重装" class="headerlink" title="Mac 重装"></a>Mac 重装</h2><p>如果遇到问题先进行一下设备的检测。<br>关掉mac，完全断电，按住D不松开，然后开机。进入诊断系统看一下结果，是否提示硬盘或者固定存储装置报告异常。</p>
<h3 id="重装选项"><a href="#重装选项" class="headerlink" title="重装选项"></a>重装选项</h3><p>Command（⌘）+ R：安装Mac之前安装的最新macOS，而不升级到更高的版本。<br>Option + Command + R：升级到与Mac兼容的最新macOS。<br>Shift + Option + Command + R：安装Mac原本出厂搭载的macOS，或是最接近且依然可用的版本。</p>
<h2 id="更换硬盘"><a href="#更换硬盘" class="headerlink" title="更换硬盘"></a>更换硬盘</h2><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><ul>
<li>ssd 西数 sn750</li>
<li>m.2 转接卡 </li>
<li>系统U盘（至少8G）</li>
<li>螺丝刀 （螺丝刀没讲究，只要口能对上就行，千万别用对不上的硬拧，滑丝了就只能暴力钻了）</li>
</ul>
<h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><ul>
<li>TimeMachine 如果，那么就最好，否则就是完全的重装</li>
<li>系统U盘，为了以防万一，TimeMachine无法使用的情况，有备无患</li>
<li>系统，一定要升级到High Sierra及以后的版本，要不然识别不到新的SSD，macOS 10.13.1之前可能不兼容NVMe协议（笔记本本来就是10.14的，也没有遇到其他情况）</li>
</ul>
<h3 id="系统U盘制作"><a href="#系统U盘制作" class="headerlink" title="系统U盘制作"></a>系统U盘制作</h3><p>连接要用于保存可引导安装器的 USB 闪存驱动器或其他宗卷。<br>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。<br>在“终端”中键入或粘贴以下命令之一。这些命令假设安装器位于您的“应用程序”文件夹中，并且“MyVolume”是您所使用的 USB 闪存驱动器或其他宗卷的名称。如果不是这个名称，请将这些命令中的 MyVolume 替换为您的宗卷名称。</p>
<p>Big Sur*：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ Big\ Sur.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br></pre></td></tr></table></figure>

<p>Catalina*：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ Catalina.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br></pre></td></tr></table></figure>

<p>Mojave*：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br></pre></td></tr></table></figure>
<p>在使用上述命令的时候，遇到了找不到命令的情况，删除重新下载也不行，最后重启了一下笔记本，才可以。</p>
<p>键入命令后：</p>
<p>按下 Return 键以输入这个命令。<br>出现提示时，请键入您的管理员密码，然后再次按下 Return 键。在您键入密码时，“终端”不会显示任何字符。<br>出现提示时，请键入 Y 以确认您要抹掉宗卷，然后按下 Return 键。在抹掉宗卷的过程中，“终端”会显示进度。<br>宗卷被抹掉后，您可能会看到一条提醒，提示“终端”要访问可移除宗卷上的文件。点按“好”以允许继续拷贝。<br>当“终端”显示操作已完成时，相应宗卷将拥有与您下载的安装器相同的名称，例如“安装 macOS Big Sur”。您现在可以退出“终端”并弹出宗卷。</p>
<p>写入的时间有点长，主要取决于U盘的写入速度。</p>
<img data-src="https://img.econow.cn/medivh/1614578974150.png"  />


<h3 id="如果新的SSD系统不识别"><a href="#如果新的SSD系统不识别" class="headerlink" title="如果新的SSD系统不识别"></a>如果新的SSD系统不识别</h3><p>将 Mac 开机，然后立即按住 Command (⌘) 和 R 这两个按键，直至看到 Apple 标志或其他图像。从 macOS 恢复功能的实用工具窗口中，选择“磁盘工具”并点按“继续”。</p>
<h4 id="下载系统"><a href="#下载系统" class="headerlink" title="下载系统"></a>下载系统</h4><p>去Apple Store搜索 mojave 点击下载即可，Install macOS Mojave10.14下载好后，打开安装（即将软件直接调入程序文件夹里面）。</p>
<h3 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h3><p>开机还是按着option键，出现制作系统U盘最后一步的那个启动盘，打开。<br>不要慌着装系统，先打开最后一项磁盘工具，看看能不能识别到INTEL，识别到了就格式化为APFS（网上普遍先搞Mac日志，出问题了再换APFS，这里推荐直接APFS），方案选择GUID分区图。要是没有识别到，回到拆机，拔掉重插。<br>装系统，这个很简单，按操作走就是了。</p>
<ul>
<li>将可引导安装器插入已连接到互联网且与您要安装的 macOS 版本兼容的 Mac。</li>
<li>将 Mac 开机或重新启动后，立即按住 Option (Alt) ⌥ 键。</li>
<li>当您看到显示可引导宗卷的黑屏时，松开 Option 键。</li>
<li>选择包含可引导安装器的宗卷。然后点按向上箭头或按下 Return 键。 </li>
<li>如果您无法从可引导安装器启动，请确保“启动安全性实用工具”中的“外部启动”设置已设为允许从外部介质启动。<br>根据提示选取您的语言。</li>
<li>从“实用工具”窗口中选择“安装 macOS”（或“安装 OS X”），然后点按“继续”，并按照屏幕上的说明进行操作。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>最简单的方式就是直接从时光机里恢复，但是不能保证一定能恢复成功，比如我这次恢复了60~70，提示失败，但是系统能进去了，看样子恢复了不少。</li>
<li>ssd 一定要配合 m.2的转接卡使用</li>
</ul>
<h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><h3 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h3><p>官网 <a href="https://iterm2.com/downloads/stable/latest">https://iterm2.com/downloads/stable/latest</a></p>
<h3 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line"># zsh/bash切换</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>插件目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Users/medivh/.oh-my-zsh/plugins</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>python3.5的版本已经放弃了，尽量选一些长期支持的版本，比如3.8、3.9。简单的方式就直接brew安装，麻烦点就去官网下载，再麻烦点就下载软件包进行编译。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install python3</span><br></pre></td></tr></table></figure>

<h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo easy_install pip</span><br><span class="line">sudo pip install requests</span><br></pre></td></tr></table></figure>

<p>pip源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">豆瓣 https://pypi.douban.com/simple</span><br><span class="line">阿里云 https://mirrors.aliyun.com/pypi/simple</span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">中国科学技术大学 https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple</span><br><span class="line">官方 https://pypi.python.org/simple/</span><br></pre></td></tr></table></figure>

<p>pip加速</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">format = columns</span><br></pre></td></tr></table></figure>

<h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br><span class="line"># 不安装任何第三方包</span><br><span class="line">virtualenv --no-site-packages venv </span><br><span class="line"></span><br><span class="line"># 指定版本</span><br><span class="line">virtualenv -p /usr/bin/python2.7 venv</span><br><span class="line"></span><br><span class="line">#激活虚拟环境</span><br><span class="line">source venv/bin/activate</span><br><span class="line"></span><br><span class="line">#推出虚拟环境</span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>参考 <a href="http://econow.cn/markdown%20%E5%9B%BE%E5%BA%8A%E7%94%9F%E6%88%90.html">http://econow.cn/markdown%20%E5%9B%BE%E5%BA%8A%E7%94%9F%E6%88%90.html</a></p>
<h3 id="iterm2-文件传输"><a href="#iterm2-文件传输" class="headerlink" title="iterm2 文件传输"></a>iterm2 文件传输</h3><p>在 mac 下，实现与服务器进行便捷的文件上传和下载操作。</p>
<ul>
<li>安装支持rz和sz命令的lrzsz：<code>brew install lrzsz</code></li>
<li>在本地&#x2F;usr&#x2F;local&#x2F;bin&#x2F;目录下保存iterm2-send-zmodem.sh 和iterm2-recv-zmodem.sh两个脚本</li>
</ul>
<p>iterm2-recv-zmodem.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">osascript -e &#x27;tell application &quot;iTerm2&quot; to version&#x27; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm</span><br><span class="line">if [[ $NAME = &quot;iTerm&quot; ]]; then</span><br><span class="line">	FILE=$(osascript -e &#x27;tell application &quot;iTerm&quot; to activate&#x27; -e &#x27;tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27; -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;)</span><br><span class="line">else</span><br><span class="line">	FILE=$(osascript -e &#x27;tell application &quot;iTerm2&quot; to activate&#x27; -e &#x27;tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27; -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $FILE = &quot;&quot; ]]; then</span><br><span class="line">	echo Cancelled.</span><br><span class="line">	# Send ZModem cancel</span><br><span class="line">	echo -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">	sleep 1</span><br><span class="line">	echo</span><br><span class="line">	echo \# Cancelled transfer</span><br><span class="line">else</span><br><span class="line">	cd &quot;$FILE&quot;</span><br><span class="line">	/usr/local/bin/rz -E -e -b --bufsize 4096</span><br><span class="line">	sleep 1</span><br><span class="line">	echo</span><br><span class="line">	echo</span><br><span class="line">	echo \# Sent \-\&gt; $FILE</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>iterm2-send-zmodem.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">osascript -e &#x27;tell application &quot;iTerm2&quot; to version&#x27; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm</span><br><span class="line">if [[ $NAME = &quot;iTerm&quot; ]]; then</span><br><span class="line">	FILE=`osascript -e &#x27;tell application &quot;iTerm&quot; to activate&#x27; -e &#x27;tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27; -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;`</span><br><span class="line">else</span><br><span class="line">	FILE=`osascript -e &#x27;tell application &quot;iTerm2&quot; to activate&#x27; -e &#x27;tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27; -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;`</span><br><span class="line">fi</span><br><span class="line">if [[ $FILE = &quot;&quot; ]]; then</span><br><span class="line">	echo Cancelled.</span><br><span class="line">	# Send ZModem cancel</span><br><span class="line">	echo -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">	sleep 1</span><br><span class="line">	echo</span><br><span class="line">	echo \# Cancelled transfer</span><br><span class="line">else</span><br><span class="line">	/usr/local/bin/sz &quot;$FILE&quot; --escape --binary --bufsize 4096</span><br><span class="line">	sleep 1</span><br><span class="line">	echo</span><br><span class="line">	echo \# Received $FILE</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ul>
<li>设置脚本权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /usr/local/bin/iterm2-*</span><br></pre></td></tr></table></figure>

<p>4.设置Iterm2的Tirgger特性，profiles-&gt;default-&gt;editProfiles-&gt;Advanced中的Tirgger</p>
<p>添加两条trigger，分别设置 Regular expression，Action，Parameters，Instant如下：</p>
<img data-src="https://img.econow.cn/medivh/1614522207826.png"  />

<img data-src="https://img.econow.cn/medivh/1614522222576.png"  />



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.第一条</span><br><span class="line">        Regular expression: rz waiting to receive.\*\*B0100</span><br><span class="line">        Action: Run Silent Coprocess</span><br><span class="line">        Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line">        Instant: checked</span><br><span class="line">2.第二条</span><br><span class="line">        Regular expression: \*\*B00000000000000</span><br><span class="line">        Action: Run Silent Coprocess</span><br><span class="line">        Parameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br><span class="line">        Instant: checked</span><br></pre></td></tr></table></figure>

<h3 id="iStat-Menus"><a href="#iStat-Menus" class="headerlink" title="iStat Menus"></a>iStat Menus</h3><p>激活码见163邮箱</p>
<h3 id="Mac-外设键盘乱位"><a href="#Mac-外设键盘乱位" class="headerlink" title="Mac 外设键盘乱位"></a>Mac 外设键盘乱位</h3><p>修改 修饰键<br><img data-src="https://img.econow.cn/medivh/1614566892484.png"  /></p>
<p>更改键位如下<br><img data-src="https://img.econow.cn/medivh/1614566905551.png"  /></p>
<p>图片中是我自己的习惯，因人而异。</p>
]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook Pro m1迁移记录</title>
    <url>/MacBook%20Pro%20m1%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>从旧的笔记本迁移到新笔记本上一般有两种方式：</p>
<ul>
<li>第一种是最简单的迁移助理APP；</li>
<li>第二种是使用TimeMachine。</li>
</ul>
<h3 id="迁移助理"><a href="#迁移助理" class="headerlink" title="迁移助理"></a>迁移助理</h3><p>“迁移助理”可将您的所有文件从旧 Mac 拷贝到新 Mac 上，让您不必手动拷贝这些文件。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol>
<li>两台笔记本的系统版本注意不要差距太大，否则会出现迁移后很多设置比较乱的情况或者其他异常情况。</li>
<li>如果两台电脑使用的都是 macOS Sierra 或更高版本，那么请将它们彼此靠近放置并打开 Wi-Fi 。如果其中有一台电脑使用的是 OS X El Capitan 或更低版本，请确保两者位于同一网络上。</li>
<li>在旧 Mac 上，选取苹果菜单  &gt;“系统偏好设置”，然后点按“共享”。确保“电脑名称”栏中显示一个名称。</li>
</ol>
<h4 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h4><p>在新Mac上</p>
<ol>
<li>打开“迁移助理”，它位于“应用程序”文件夹的“实用工具”文件夹内。然后，点按“继续”。</li>
<li>当“迁移助理”就做出更改而征求您的许可时，输入您的管理员密码，然后点按“好”。</li>
<li>当系统询问您要怎样传输信息时，请选择从 Mac、“时间机器”备份或启动磁盘进行传输的方式。然后，点按“继续”。</li>
</ol>
<p><img data-src="https://img.econow.cn/medivh/1636891253812.png" alt="1636891253812.png"></p>
<p>在旧Mac上</p>
<ol>
<li>打开“迁移助理”，然后点按“继续”。</li>
<li>当系统询问您想要怎样传输信息时，请选择“至另一台 Mac”这一传输选项。然后，点按“继续”。</li>
</ol>
<p>在新 Mac 上<br>当系统提示您选择 Mac、“时间机器”备份或其他启动磁盘时，请选择另一台 Mac。然后，点按“继续”。</p>
<p><img data-src="https://img.econow.cn/medivh/1636891321526.png" alt="1636891321526.png"></p>
<p>在旧 Mac 上<br>如果看到安全码，请确保其与新 Mac 上显示的安全码相同。然后，点按“继续”。</p>
<p>在新 Mac 上<br>1.选择要传输的信息。</p>
<blockquote>
<p>在这个示例中，John Appleseed 是一个 macOS 用户帐户。如果这个帐户与新 Mac 上已有的帐户同名，则系统会提示您重命名这个旧帐户或替换新 Mac 上的帐户。如果进行重命名，则这个旧帐户会作为单独的用户出现在新 Mac 上，并且拥有单独的个人文件夹和登录名。如果进行替换，则这个旧帐户会删除并随后替换新 Mac 上的帐户，包括相应个人文件夹中的所有内容。</p>
</blockquote>
<p><img data-src="https://img.econow.cn/medivh/1636891361313.png" alt="1636891361313.png"></p>
<p>2.点按“继续”以开始传输。大型传输可能需要几个小时才能完成。<br>3.“迁移助理”完成操作后，在两台电脑上退出“迁移助理”，然后在新 Mac 上登录迁移的帐户以查看它的文件。</p>
<h4 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h4><ol>
<li><p>迁移助理一直显示正在启动中<br>原因是没有等新的Mac计算为每个项目的大小就点击了继续，解决方式就是重启笔记本，再来一遍。之后等笔记本计算完文件大小，之后再点击继续就可以传输了。</p>
</li>
<li><p>其他</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我使用的就是这种方式，简单，但是略微费时。执行过程中基本没有出现什么问题，大体比较顺利，加上摸索的时间全程大约2小时内。</p>
<h3 id="全盘恢复"><a href="#全盘恢复" class="headerlink" title="全盘恢复"></a>全盘恢复</h3><p>所谓的全盘恢复就是使用时间机器的备份恢复到新的笔记本中。</p>
<h4 id="执行步骤-1"><a href="#执行步骤-1" class="headerlink" title="执行步骤"></a>执行步骤</h4><ol>
<li><p>如果需要重新安装 macOS，请先完成这一操作，然后再继续。例如，如果 Mac 启动时显示闪烁的问号，则您需要先重新安装 macOS。</p>
</li>
<li><p>确保您的“时间机器”备份磁盘已连接到 Mac，并处于打开状态。</p>
</li>
<li><p>在 Mac 上打开“迁移助理”。它位于“应用程序”文件夹的“实用工具”文件夹中。</p>
<blockquote>
<p>如果 Mac 启动时显示设置助理，要求提供您所在的国家或地区和您的网络等详细信息，请继续前往下一步，因为设置助理包含了迁移助理。</p>
</blockquote>
</li>
<li><p>当系统询问您要怎样传输信息时，请选择从 Mac、“时间机器”备份或启动磁盘进行传输的方式。然后，点按“继续”。</p>
</li>
</ol>
<p><img data-src="https://img.econow.cn/medivh/1636893548067.png" alt="1636893548067.png"></p>
<ol start="5">
<li>选择您的“时间机器”备份，然后点按“继续”。</li>
</ol>
<p><img data-src="https://img.econow.cn/medivh/1636893570556.png" alt="1636893570556.png"></p>
<ol>
<li>选取一个备份，然后点按“继续”。</li>
</ol>
<p><img data-src="https://img.econow.cn/medivh/1636893593127.png" alt="1636893593127.png"></p>
<ol start="7">
<li>选择要传输的信息</li>
</ol>
<blockquote>
<p>在这个示例中，John Appleseed 是一个 macOS 用户帐户。如果这个旧帐户与 Mac 上已有的帐户同名，则系统会提示您重命名这个旧帐户或替换 Mac 上的帐户。如果进行重命名，则这个旧帐户会作为单独的用户出现在 Mac 上，并且拥有单独的个人文件夹和登录名。如果进行替换，则这个旧帐户会删除并随后替换 Mac 上的帐户，包括相应个人文件夹中的所有内容。</p>
</blockquote>
<p><img data-src="https://img.econow.cn/medivh/1636893631865.png" alt="1636893631865.png"></p>
<ol start="8">
<li>点按“继续”以开始传输。大型传输可能需要几个小时才能完成。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://support.apple.com/zh-cn/HT204350">https://support.apple.com/zh-cn/HT204350</a></li>
</ul>
]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 技巧</title>
    <url>/Mac%E9%83%A8%E5%88%86%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h3 id="查看中文字体"><a href="#查看中文字体" class="headerlink" title="查看中文字体"></a>查看中文字体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew  install fontconfig</span><br><span class="line">fc-list :lang=zh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown常见语法错误解析</title>
    <url>//MarkDown%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E8%A7%A3%E6%9E%90</url>
    <content><![CDATA[<blockquote>
<p>MD001 - Heading levels should only increment by one level at a time</p>
</blockquote>
<p>标题级数只能每次扩大一个，也就是说不能隔级创建标题，必须h1-h2-h3…这样</p>
<blockquote>
<p>MD002 - First heading should be a top level heading</p>
</blockquote>
<p>文档的第一个标题必须是最高级的标题，也就是h1</p>
<blockquote>
<p>MD003 - Heading style</p>
</blockquote>
<p>整篇文档的标题格式要采取统一的</p>
<blockquote>
<p>MD004 - Unordered list style</p>
</blockquote>
<p>整篇文档的无序列表的格式要一致</p>
<blockquote>
<p>MD005 - Inconsistent indentation for list items at the same level</p>
</blockquote>
<p>同一个等级的列表的缩进要一致</p>
<blockquote>
<p>MD006 - Consider starting bulleted lists at the beginning of the line</p>
</blockquote>
<p>一级标题不能够缩进</p>
<blockquote>
<p>MD007 - Unordered list indentation</p>
</blockquote>
<p>无序列表嵌套的时候默认采取两个空格的缩进方式</p>
<blockquote>
<p>MD008 - 无</p>
</blockquote>
<p>Rules</p>
<blockquote>
<p>MD009 - Trailing spaces</p>
</blockquote>
<p>行尾最多可以添加两个空格，超出之后会有警告，最好每次都是两个空格因为两个空格刚好可以用来换行</p>
<blockquote>
<p>MD010 - Hard tabs</p>
</blockquote>
<p>不能使用tab来进行缩进，要使用空格</p>
<blockquote>
<p>MD011 - Reversed link syntax</p>
</blockquote>
<p>内联形式的链接和创建方式是否错误，中括号和圆括号是否使用正确</p>
<blockquote>
<p>MD012 - Multiple consecutive blank lines</p>
</blockquote>
<p>文档中不能有连续的空行（文档末可以有一个空行），在代码块中这个规则不会生效</p>
<blockquote>
<p>MD013 - Line length</p>
</blockquote>
<p>默认行的最大长度是80，对表格代码块标题都起效果</p>
<blockquote>
<p>MD014 - Dollar signs used before commands without showing output</p>
</blockquote>
<p>在代码块中，终端命令前面不需要有美元符号，如果如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)</p>
<blockquote>
<p>MD018 - No space after hash on atx style heading</p>
</blockquote>
<p>标题格式如果是”atx”的话，#号和文字之间需要一个空格隔开</p>
<blockquote>
<p>MD019 - Multiple spaces after hash on atx style heading</p>
</blockquote>
<p>标题格式如果是”atx”的话，#号和文字之间只需要一个空格隔开，不需要多个</p>
<blockquote>
<p>MD020 - No space inside hashes on closed atx style heading</p>
</blockquote>
<p>在closed_atx格式的标题中，文字和前后的#号之间都需要一个空格隔开</p>
<blockquote>
<p>MD021 - Multiple spaces inside hashes on closed atx style heading</p>
</blockquote>
<p>在closed_atx格式的标题中，文字和前后的#号之间只需要一个空格隔开，不能有多余的</p>
<blockquote>
<p>MD022 - Headings should be surrounded by blank lines</p>
</blockquote>
<p>标题的上下行必须都是空格</p>
<blockquote>
<p>MD023 - Headings must start at the beginning of the line</p>
</blockquote>
<p>标题行不能缩进</p>
<blockquote>
<p>MD024 - Multiple headings with the same content</p>
</blockquote>
<p>在文档中不能有重复性的标题</p>
<blockquote>
<p>MD025 - Multiple top level headings in the same document</p>
</blockquote>
<p>同一个文档中，只能有一个最高级的标题，默认也只能有一个一级标题</p>
<blockquote>
<p>MD026 - Trailing punctuation in heading</p>
</blockquote>
<p>标题的末尾不能有”. , ; : ! ? “这些符号</p>
<blockquote>
<p>MD027 - Multiple spaces after blockquote symbol</p>
</blockquote>
<p>在创建引用块的时候，右尖号与文字之间必须有且只有一个空格</p>
<blockquote>
<p>MD028 - Blank line inside blockquote</p>
</blockquote>
<p>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用&gt;开头</p>
<blockquote>
<p>MD029 - Ordered list item prefix</p>
</blockquote>
<p>有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字</p>
<blockquote>
<p>MD030 - Spaces after list markers</p>
</blockquote>
<p>列表（有序、无序）的前缀符号和文字之间用1个空格隔开，在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进3个空格</p>
<blockquote>
<p>MD031 - Fenced code blocks should be surrounded by blank lines</p>
</blockquote>
<p>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块</p>
<blockquote>
<p>MD032 - Lists should be surrounded by blank lines</p>
</blockquote>
<p>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表，列表的缩进必须一致，否则会警告</p>
<blockquote>
<p>MD033 - Inline HTML</p>
</blockquote>
<p>文档中不允许使用html语句</p>
<blockquote>
<p>MD034 - Bare URL used</p>
</blockquote>
<p>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接</p>
<blockquote>
<p>MD035 - Horizontal rule style</p>
</blockquote>
<p>创建水平线时整篇文档要统一，要和文档中第一次创建水平线使用的符号一致</p>
<blockquote>
<p>MD036 - Emphasis used instead of a heading</p>
</blockquote>
<p>不能用强调来代替标题 ****</p>
<blockquote>
<p>MD037 - Spaces inside emphasis markers</p>
</blockquote>
<p>强调的符号和文字之间不能有空格</p>
<blockquote>
<p>MD038 - Spaces inside code span elements</p>
</blockquote>
<p>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格，如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开</p>
<blockquote>
<p>MD039 - Spaces inside link text</p>
</blockquote>
<p>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格</p>
<blockquote>
<p>MD040 - Fenced code blocks should have a language specified</p>
</blockquote>
<p>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮</p>
<blockquote>
<p>MD041 - First line in file should be a top level heading</p>
</blockquote>
<p>文档的第一个非空行应该是文档最高级的标题，默认是1级标题</p>
<blockquote>
<p>MD042 - No empty links</p>
</blockquote>
<p>链接的地址不能为空</p>
<blockquote>
<p>MD043 - Required heading structure</p>
</blockquote>
<p>要求标题遵循一定的结构，默认是没有规定的结构</p>
<blockquote>
<p>MD044 - Proper names should have the correct capitalization</p>
</blockquote>
<p>指定一些名称，会检查它是否有正确的大写</p>
<blockquote>
<p>MD045 - Images should have alternate text (alt text)</p>
</blockquote>
<p>图片链接必须包含描述文本 all文本</p>
<blockquote>
<p>MD046 - Code block style</p>
</blockquote>
<p>整篇文档采用一致的代码格式</p>
<blockquote>
<p>MD047 - Files should end with a single newline character</p>
</blockquote>
<p>文档末尾需要一个空行结尾</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/6844903938165047309">https://juejin.cn/post/6844903938165047309</a></li>
<li><a href="https://www.jianshu.com/p/q81RER">https://www.jianshu.com/p/q81RER</a></li>
</ul>
]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongodb 探索</title>
    <url>/Mongodb%20%E6%8E%A2%E7%B4%A2.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。MongoDB是工作在集合和文档上一种概念。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>支持特别查询在MongoDB中，可以通过字段，范围查询进行搜索，并且还支持正则表达式搜索。</li>
<li>索引可以索引文档中的任何字段。</li>
<li>复制MongoDB支持主从复制。主机可以执行读写操作，从机从主机复制数据，只能用于读取或备份(不写入)</li>
<li>复制数据MongoDB可以在多台服务器上运行。 复制数据以保持系统正常运行，并在硬件故障的情况下保持其运行状态。</li>
<li>负载均衡由于数据放在碎片中，因此具有自动负载平衡配置。</li>
<li>支持映射缩减和聚合工具</li>
<li>使用JavaScript而不是Procedure</li>
<li>它是一个用C++编写的无模式数据库</li>
<li>提供高性能</li>
<li>轻松存储任何大小的文件，而不会使您的堆栈复杂化</li>
<li>在故障的情况下易于管理</li>
<li>它还支持：<ul>
<li>具有动态模式的JSON数据模型</li>
<li>自动分片用于水平可扩展性</li>
<li>内置复制高可用性</li>
</ul>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>MongoDB 的架构较少。它是一个文档数据库，它的一个集合持有不同的文档。</li>
<li>从一个到另一个的文档的数量，内容和大小可能有差异。</li>
<li>MongoDB 中单个对象的结构很清淅。</li>
<li>MongoDB 中没有复杂的连接。</li>
<li>MongoDB 提供深度查询的功能，因为它支持对文档的强大的动态查询。</li>
<li>MongoDB 很容易扩展。</li>
<li>它使用内部存储器来存储工作集，这是其快速访问的原因。</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>大而复杂的数据</li>
<li>移动和社会基础设施数据</li>
<li>内容管理和交付</li>
<li>用户数据管理</li>
<li>数据中心</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载</span><br><span class="line">tar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压</span><br><span class="line"></span><br><span class="line">mv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb                         # 将解压包拷贝到指定目录</span><br></pre></td></tr></table></figure>
<p>MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p><mongodb-install-directory> 为你 MongoDB 的安装路径。如本文的 &#x2F;usr&#x2F;local&#x2F;mongodb 。</p>
<h3 id="创建数据库目录"><a href="#创建数据库目录" class="headerlink" title="创建数据库目录"></a>创建数据库目录</h3><p>MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。</p>
<p>以下实例中我们将data目录创建于根目录下(&#x2F;)。</p>
<p>注意：&#x2F;data&#x2F;db 是 MongoDB 默认的启动的数据库路径(–dbpath)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/db</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>可以在命令行中执行mongo安装目录中的bin目录执行mongod命令来启动mongdb服务。如果你的数据库目录不是&#x2F;data&#x2F;db，可以通过 –dbpath 来指定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./mongod</span><br></pre></td></tr></table></figure>
<h3 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h3><ul>
<li>–dbpath 指定数据目录，默认是&#x2F;data&#x2F;db,每个mongod进程都需要独立的数据目录</li>
<li>–port 指定服务器监听端口，默认27017</li>
<li>–fork 以守护进程的方式运行服务</li>
<li>–logpath 指定输出日志的路径，而不是输出到命令行</li>
<li>–config 指定配置文件</li>
</ul>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><ul>
<li>查看进程，使用kill命令</li>
<li>在客户端进去，使用db.shutdownServer()</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show dbs;</span><br><span class="line">#查看数据库</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546668277063.png" />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use wesure;</span><br><span class="line">#切换或者创建（如果没有该库的话）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.getName();</span><br><span class="line">#db; db和getName方法是一样的效果，都可以查询当前使用的数据库</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546668518239.png" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.stats();</span><br><span class="line">#查看数据库状态</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1546668460378.png" />

<h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p>1、添加一个用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.addUser(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true); 添加用户、设置密码、是否只读</span><br></pre></td></tr></table></figure>
<p>2、数据库认证、安全模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.auth(&quot;userName&quot;, &quot;123123&quot;);</span><br></pre></td></tr></table></figure>
<p>3、显示当前所有用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show users;</span><br></pre></td></tr></table></figure>
<p>4、删除用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.removeUser(&quot;userName&quot;);</span><br></pre></td></tr></table></figure>
<p>其他</p>
<ul>
<li>查询之前的错误信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.getPrevError();</span><br></pre></td></tr></table></figure></li>
<li>清除错误记录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.resetError();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>使用copyDatabase命令实现数据库复制，可以在几秒内创建数据库副本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.copyDatabase(fromdb, todb, fromhost, username, password, mechanism)¶</span><br></pre></td></tr></table></figure>

<img data-src="https://img.econow.cn/medivh/1630924290229.png"  />


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@gz-tencent mongo]# mongo localhost:27018</span><br><span class="line">&gt; db.copyDatabase(&quot;backup&quot;,&quot;backup&quot;,&quot;xxx.x.x.x:27017&quot;);</span><br><span class="line">WARNING: db.copyDatabase is deprecated. See http://dochub.mongodb.org/core/copydb-clone-deprecation</span><br><span class="line">&#123;</span><br><span class="line">    &quot;note&quot; : &quot;Support for the copydb command has been deprecated. See http://dochub.mongodb.org/core/copydb-clone-deprecation&quot;,</span><br><span class="line">    &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，执行后不会立刻展示正确的容量大小，取决于数据库实际的大小和网速。另外4.0以后的版本以及不能使用该命令了。</p>
<blockquote>
<p>IMPORTANT<br>Starting in version 4.2, MongoDB removes the copydb command. The deprecated db.copyDatabase(), which wraps the copydb command, can only be run against MongoDB 4.0 or earlier versions. For behavior and examples, refer to the 4.0 or earlier version of the manual.<br>For an alternative in version 4.2+, see Copy&#x2F;Clone a Database. </p>
</blockquote>
<h4 id="4-2-copy-clone"><a href="#4-2-copy-clone" class="headerlink" title="4.2 copy&#x2F;clone"></a>4.2 copy&#x2F;clone</h4><p>As an alternative, users can use mongodump and mongorestore (with the mongorestore options –nsFrom and –nsTo).</p>
<p>For example, to copy the test database from a local instance running on the default port 27017 to the examples database on the same instance, you can:</p>
<ol>
<li>Use mongodump to dump the test database to an archive mongodump-test-db:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodump --archive=&quot;mongodump-test-db&quot; --db=test</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Use mongorestore with –nsFrom and –nsTo to restore (with database name change) from the archive:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongorestore --archive=&quot;mongodump-test-db&quot; --nsFrom=&#x27;test.*&#x27; --nsTo=&#x27;examples.*&#x27;</span><br></pre></td></tr></table></figure>

<p>简单来说分为两步，首先dump导出，然后restore恢复，也可以指定源空间和目标空间。</p>
<h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><p>The canonical name for a collection or index in MongoDB. The namespace is a combination of the database name and the name of the collection or index, like so: [database-name].[collection-or-index-name]. All documents belong to a namespace. See Namespaces.</p>
<p>规范的命名是集合或者索引在MongoDB中。命名空间是由数据库名和集合或者索引共同组成。</p>
<h4 id="database"><a href="#database" class="headerlink" title="database"></a>database</h4><p>A physical container for collections. Each database gets its own set of files on the file system. A single MongoDB server typically has multiple databases.</p>
<p>一种存放集合的物理容器。每个数据库在文件系统都有自己的文件。单个MongoDB服务可以有多个数据库。</p>
<h4 id="journal"><a href="#journal" class="headerlink" title="journal"></a>journal</h4><p>A sequential, binary transaction log used to bring the database into a valid state in the event of a hard shutdown. Journaling writes data first to the journal and then to the core data files. MongoDB enables journaling by default for 64-bit builds of MongoDB version 2.0 and newer. Journal files are pre-allocated and exist as files in the data directory. See Journaling.</p>
<p>一种连续的，二进制不间断的日志用来数据库有效状态记录事件在硬件宕机的时候。</p>
<h4 id="数据文件类型"><a href="#数据文件类型" class="headerlink" title="数据文件类型"></a>数据文件类型</h4><ol>
<li>journal 日志文件</li>
<li>namespace 表名文件</li>
<li>data 数据及索引文件</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://docs.mongodb.com/manual/introduction/">https://docs.mongodb.com/manual/introduction/</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx知识点</title>
    <url>//Nginx%E7%9F%A5%E8%AF%86%E7%82%B9</url>
    <content><![CDATA[<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><h3 id="文字描述"><a href="#文字描述" class="headerlink" title="文字描述"></a>文字描述</h3><ol>
<li>如果有精确匹配，则会进行精确匹配，成功的话返回结果</li>
<li>普通匹配和顺序无关，根据匹配的长短来取匹配结果</li>
<li>正则匹配和顺序有关，从上往下，匹配成功就返回结果</li>
<li>统配，都可以匹配</li>
</ol>
<p><img data-src="https://img.econow.cn/medivh/1648549562146.png" alt="1648549562146.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(location = uri &#123;&#125;) &amp;gt; (location 完整路径 &#123;&#125;) &amp;gt; (location ^~ 路径 &#123;&#125;) &amp;gt; (location ~,~* 正则顺序 &#123;&#125;) &amp;gt; (location 部分起始路径 &#123;&#125;) &amp;gt; (location / &#123;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="案例示例"><a href="#案例示例" class="headerlink" title="案例示例"></a>案例示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location = /php.php &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&#x27;精确匹配&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /php/ &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&#x27;标准匹配，仅前缀&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">location ~ \.(php) &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&#x27;区分大小写，小写&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">location ~ \.(pHp) &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&#x27;区分大小写，大写&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(php)$ &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&#x27;不区分大小写&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www quail]<span class="comment"># curl 192.168.249.132/php.php</span></span><br><span class="line">精确匹配</span><br><span class="line">[root@www quail]<span class="comment"># curl 192.168.249.132/php/php.php</span></span><br><span class="line">标准匹配，仅前缀</span><br><span class="line">[root@www quail]<span class="comment"># curl 192.168.249.132/pp.php</span></span><br><span class="line">区分大小写，小写</span><br><span class="line">[root@www quail]<span class="comment"># curl 192.168.249.132/pp.pHp</span></span><br><span class="line">区分大小写，大写</span><br><span class="line">[root@www quail]<span class="comment"># curl 192.168.249.132/php.pHP</span></span><br><span class="line">不区分大小写</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFalcon CentOS 7.2部署</title>
    <url>/OpenFalcon%20CentOS%207.2%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OpenFalcon是一款企业级、高可用、可扩展的开源监控解决方案。</p>
<img data-src="https://img.econow.cn/2018/1539584391262.png" width="1013"/>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>当前平台相关组件部署在OAM主机，其余主机均部署agent.</p>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y redis</span><br></pre></td></tr></table></figure>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y mysql-server</span><br></pre></td></tr></table></figure>
<h4 id="初始化MySQL表结构"><a href="#初始化MySQL表结构" class="headerlink" title="初始化MySQL表结构"></a>初始化MySQL表结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp/ &amp;&amp; git clone https://github.com/open-falcon/falcon-plus.git</span><br><span class="line">cd /tmp/falcon-plus/scripts/mysql/db_schema/</span><br><span class="line">mysql -h 127.0.0.1 -u root -pYmQwODk2Y2I0ZmVm &lt; 1_uic-db-schema.sql</span><br><span class="line">mysql -h 127.0.0.1 -u root -pYmQwODk2Y2I0ZmVm &lt; 2_portal-db-schema.sql</span><br><span class="line">mysql -h 127.0.0.1 -u root -pYmQwODk2Y2I0ZmVm &lt; 3_dashboard-db-schema.sql</span><br><span class="line">mysql -h 127.0.0.1 -u root -pYmQwODk2Y2I0ZmVm &lt; 4_graph-db-schema.sql</span><br><span class="line">mysql -h 127.0.0.1 -u root -pYmQwODk2Y2I0ZmVm &lt; 5_alarms-db-schema.sql</span><br><span class="line">rm -rf /tmp/falcon-plus/</span><br></pre></td></tr></table></figure>
<p>注意，请确保redis和MySQL已启动。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export FALCON_HOME=/usr/local</span><br><span class="line">export WORKSPACE=$FALCON_HOME/open-falcon</span><br><span class="line">mkdir -p $WORKSPAC</span><br><span class="line">tar -xzvf open-falcon-v0.2.0.tar.gz -C $WORKSPACE</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改所有组件的MySQL信息root:password</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $WORKSPACE</span><br><span class="line">./open-falcon start</span><br><span class="line"></span><br><span class="line"># 检查所有模块的启动状况</span><br><span class="line">./open-falcon check</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ./open-falcon [start|stop|restart|check|monitor|reload] module</span><br><span class="line">./open-falcon start agent</span><br><span class="line"></span><br><span class="line">./open-falcon check</span><br><span class="line">        falcon-graph         UP           53007</span><br><span class="line">          falcon-hbs         UP           53014</span><br><span class="line">        falcon-judge         UP           53020</span><br><span class="line">     falcon-transfer         UP           53026</span><br><span class="line">       falcon-nodata         UP           53032</span><br><span class="line">   falcon-aggregator         UP           53038</span><br><span class="line">        falcon-agent         UP           53044</span><br><span class="line">      falcon-gateway         UP           53050</span><br><span class="line">          falcon-api         UP           53056</span><br><span class="line">        falcon-alarm         UP           53063</span><br><span class="line"></span><br><span class="line">For debugging , You can check $WorkDir/$moduleName/log/logs/xxx.log</span><br></pre></td></tr></table></figure>
<h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>agent用于采集机器负载监控指标，比如cpu.idle、load.1min、disk.io.util等等，每隔60秒push给Transfer。agent与Transfer建立了长连接，数据发送速度比较快，agent提供了一个http接口&#x2F;v1&#x2F;push用于接收用户手工push的一些数据，然后通过长连接迅速转发给Transfer。</p>
<h3 id="部署说明"><a href="#部署说明" class="headerlink" title="部署说明"></a>部署说明</h3><p>agent需要部署到所有要被监控的机器上，比如公司有10万台机器，那就要部署10万个agent。agent本身资源消耗很少，不用担心。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;debug&quot;: true,  # 控制一些debug信息的输出，生产环境通常设置为false</span><br><span class="line">    &quot;hostname&quot;: &quot;&quot;, # agent采集了数据发给transfer，endpoint就设置为了hostname，默认通过`hostname`获取，如果配置中配置了hostname，就用配置中的</span><br><span class="line">    &quot;ip&quot;: &quot;&quot;, # agent与hbs心跳的时候会把自己的ip地址发给hbs，agent会自动探测本机ip，如果不想让agent自动探测，可以手工修改该配置</span><br><span class="line">    &quot;plugin&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: false, # 默认不开启插件机制</span><br><span class="line">        &quot;dir&quot;: &quot;./plugin&quot;,  # 把放置插件脚本的git repo clone到这个目录</span><br><span class="line">        &quot;git&quot;: &quot;https://github.com/open-falcon/plugin.git&quot;, # 放置插件脚本的git repo地址</span><br><span class="line">        &quot;logs&quot;: &quot;./logs&quot; # 插件执行的log，如果插件执行有问题，可以去这个目录看log</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;heartbeat&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: true,  # 此处enabled要设置为true</span><br><span class="line">        &quot;addr&quot;: &quot;127.0.0.1:6030&quot;, # hbs的地址，端口是hbs的rpc端口</span><br><span class="line">        &quot;interval&quot;: 60, # 心跳周期，单位是秒</span><br><span class="line">        &quot;timeout&quot;: 1000 # 连接hbs的超时时间，单位是毫秒</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;transfer&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: true,</span><br><span class="line">        &quot;addrs&quot;: [</span><br><span class="line">            &quot;127.0.0.1:18433&quot;</span><br><span class="line">        ],  # transfer的地址，端口是transfer的rpc端口, 可以支持写多个transfer的地址，agent会保证HA</span><br><span class="line">        &quot;interval&quot;: 60, # 采集周期，单位是秒，即agent一分钟采集一次数据发给transfer</span><br><span class="line">        &quot;timeout&quot;: 1000 # 连接transfer的超时时间，单位是毫秒</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;http&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: true,  # 是否要监听http端口</span><br><span class="line">        &quot;listen&quot;: &quot;:1988&quot;,</span><br><span class="line">        &quot;backdoor&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;collector&quot;: &#123;</span><br><span class="line">        &quot;ifacePrefix&quot;: [&quot;eth&quot;, &quot;em&quot;], # 默认配置只会采集网卡名称前缀是eth、em的网卡流量，配置为空就会采集所有的，lo的也会采集。可以从/proc/net/dev看到各个网卡的流量信息</span><br><span class="line">        &quot;mountPoint&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;default_tags&quot;: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ignore&quot;: &#123;  # 默认采集了200多个metric，可以通过ignore设置为不采集</span><br><span class="line">        &quot;cpu.busy&quot;: true,</span><br><span class="line">        &quot;df.bytes.free&quot;: true,</span><br><span class="line">        &quot;df.bytes.total&quot;: true,</span><br><span class="line">        &quot;df.bytes.used&quot;: true,</span><br><span class="line">        &quot;df.bytes.used.percent&quot;: true,</span><br><span class="line">        &quot;df.inodes.total&quot;: true,</span><br><span class="line">        &quot;df.inodes.free&quot;: true,</span><br><span class="line">        &quot;df.inodes.used&quot;: true,</span><br><span class="line">        &quot;df.inodes.used.percent&quot;: true,</span><br><span class="line">        &quot;mem.memtotal&quot;: true,</span><br><span class="line">        &quot;mem.memused&quot;: true,</span><br><span class="line">        &quot;mem.memused.percent&quot;: true,</span><br><span class="line">        &quot;mem.memfree&quot;: true,</span><br><span class="line">        &quot;mem.swaptotal&quot;: true,</span><br><span class="line">        &quot;mem.swapused&quot;: true,</span><br><span class="line">        &quot;mem.swapfree&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./open-falcon start agent  启动进程</span><br><span class="line">./open-falcon stop agent  停止进程</span><br><span class="line">./open-falcon monitor agent  查看日志</span><br><span class="line">./falcon-agent --check 健康检查，或者浏览器访问其1988端口</span><br></pre></td></tr></table></figure>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="克隆前端组件代码"><a href="#克隆前端组件代码" class="headerlink" title="克隆前端组件代码"></a>克隆前端组件代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $WORKSPACE</span><br><span class="line">git clone https://github.com/open-falcon/dashboard.git</span><br></pre></td></tr></table></figure>
<h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y python-virtualenv</span><br><span class="line">yum install -y python-devel</span><br><span class="line">yum install -y openldap-devel</span><br><span class="line">yum install -y mysql-devel</span><br><span class="line">yum groupinstall &quot;Development tools&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd $WORKSPACE/dashboard/</span><br><span class="line">virtualenv ./env</span><br><span class="line"></span><br><span class="line">./env/bin/pip install -r pip_requirements.txt -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dashboard的配置文件为： &#x27;rrd/config.py&#x27;，请根据实际情况修改</span><br><span class="line"></span><br><span class="line">## API_ADDR 表示后端api组件的地址</span><br><span class="line">API_ADDR = &quot;http://127.0.0.1:8080/api/v1&quot;</span><br><span class="line"></span><br><span class="line">## 根据实际情况，修改PORTAL_DB_*, 默认用户名为root，默认密码为&quot;&quot;</span><br><span class="line">## 根据实际情况，修改ALARM_DB_*, 默认用户名为root，默认密码为&quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><h4 id="开发者模式启动"><a href="#开发者模式启动" class="headerlink" title="开发者模式启动"></a>开发者模式启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./env/bin/python wsgi.py</span><br><span class="line"></span><br><span class="line">open http://127.0.0.1:8081 in your browser.</span><br></pre></td></tr></table></figure>
<h4 id="生产环境启动"><a href="#生产环境启动" class="headerlink" title="生产环境启动"></a>生产环境启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash control start</span><br><span class="line"></span><br><span class="line">open http://127.0.0.1:8081 in your browser.</span><br></pre></td></tr></table></figure>
<h3 id="停止dashboard运行"><a href="#停止dashboard运行" class="headerlink" title="停止dashboard运行"></a>停止dashboard运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash control stop</span><br></pre></td></tr></table></figure>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash control tail</span><br></pre></td></tr></table></figure>
<h3 id="dashbord用户管理"><a href="#dashbord用户管理" class="headerlink" title="dashbord用户管理"></a>dashbord用户管理</h3><p>dashbord没有默认创建任何账号包括管理账号，需要你通过页面进行注册账号。<br>想拥有管理全局的超级管理员账号，需要手动注册用户名为root的账号（第一个帐号名称为root的用户会被自动设置为超级管理员）。<br>超级管理员可以给普通用户分配权限管理。</p>
<blockquote>
<p>小提示：注册账号能够被任何打开dashboard页面的人注册，所以当给相关的人注册完账号后，需要去关闭注册账号功能。只需要去修改api组件的配置文件cfg.json，将signup_disable配置项修改为true，重启api即可。当需要给人开账号的时候，再将配置选项改回去，用完再关掉即可。</p>
</blockquote>
<h2 id="初次使用"><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h2><h3 id="注册管理员账号"><a href="#注册管理员账号" class="headerlink" title="注册管理员账号"></a>注册管理员账号</h3><p>访问dashboard主机8081端口，点击”sign up”<br><img data-src="https://img.econow.cn/2018/1539585168733.png" width="1229"/></p>
<p>用户名必须为root</p>
<img data-src="https://img.econow.cn/2018/1539585230624.png" width="397"/>

<h3 id="个人信息维护"><a href="#个人信息维护" class="headerlink" title="个人信息维护"></a>个人信息维护</h3><p>注意填写邮箱地址和IM信息，IM部分可以写微信号，这些信息为以后的报警通知使用。<br><img data-src="https://img.econow.cn/2018/1539585311738.png" width="1232"/></p>
<h3 id="Dashboard-使用介绍"><a href="#Dashboard-使用介绍" class="headerlink" title="Dashboard 使用介绍"></a>Dashboard 使用介绍</h3><ul>
<li>左边的侧边栏会显示所有加入的agent主机，或者自定义的endpoint。</li>
<li>右中间位置limit50表示显示50行内容，可以自行选择。</li>
<li>右下方是endpiont的监控项目，选中后点击看图即可画图。</li>
</ul>
<img data-src="https://img.econow.cn/2018/1539585454798.png" width="1229"/>
### 画图示例
1、选中监控项，点击选择看图视角
<img data-src="https://img.econow.cn/2018/1539585659674.png" width="794"/>
2、这样图就出来啦
<img data-src="https://img.econow.cn/2018/1539585675701.png" width="1226"/>

<p>另外还可以自定义screen，此处不再具体介绍</p>
<h2 id="hostgroup"><a href="#hostgroup" class="headerlink" title="hostgroup"></a>hostgroup</h2><p>简单说就是主机组，然后绑定模板<br>hostgroup-》Add host</p>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>Like this.</p>
<img data-src="https://img.econow.cn/2018/1539589162286.png" width="1222"/>

<h2 id="监控使用"><a href="#监控使用" class="headerlink" title="监控使用"></a>监控使用</h2><p>参考  <a href="http://book.open-falcon.org/zh_0_2/usage/getting-started.html">http://book.open-falcon.org/zh_0_2&#x2F;usage&#x2F;getting-started.html</a></p>
<h2 id="报警组件"><a href="#报警组件" class="headerlink" title="报警组件"></a>报警组件</h2><p>报警部分分为邮件和微信报警，其中微信报警。启动邮件报警部分有点特殊，因为阿里云机器默认是不允许开发25端口的，因此只能使用ssl的456端口。但是问题又来了，官方的组件不支持ssl。因此对于这个问题只能是重新编译。</p>
<h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><p><a href="https://github.com/GitHamburg/mail-provider.git">https://github.com/GitHamburg/mail-provider.git</a></p>
<h4 id="1-二进制安装-推荐"><a href="#1-二进制安装-推荐" class="headerlink" title="1.二进制安装(推荐)"></a>1.二进制安装(推荐)</h4><p>下载编译好的二进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://cactifans.hi-www.com/open-falcon/mail-provider.tar.gz</span><br><span class="line">mkdir -p mail-provider</span><br><span class="line">tar zxvf mail-provider.tar.gz  -C mail-provider</span><br><span class="line">cd mail-provider</span><br></pre></td></tr></table></figure>
<p>修改cfg.json文件相关信息，使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./control start</span><br></pre></td></tr></table></figure>
<h4 id="2-源码编译（如无科学上网方法，请勿尝试）"><a href="#2-源码编译（如无科学上网方法，请勿尝试）" class="headerlink" title="2.源码编译（如无科学上网方法，请勿尝试）"></a>2.源码编译（如无科学上网方法，请勿尝试）</h4><p>下载之后为源码，安装golang环境，环境配置参考golang环境配置 编译方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $GOPATH/src</span><br><span class="line">mkdir github.com/open-falcon/ -p</span><br><span class="line">cd github.com/open-falcon/</span><br><span class="line">git clone https://github.com/GitHamburg/mail-provider.git</span><br><span class="line">cd mail-provider</span><br><span class="line">go get ./...</span><br><span class="line">./control build</span><br></pre></td></tr></table></figure>
<p>编译成功之后，修改cfg.json文件相关信息，使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./control start</span><br></pre></td></tr></table></figure>
<h4 id="3、使用方法"><a href="#3、使用方法" class="headerlink" title="3、使用方法"></a>3、使用方法</h4><p>坐着说可以发送给多人，但是实际curl使用的时候发现并不可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://$ip:4000/sender/mail -d &quot;tos=a@a.com&amp;subject=xx&amp;content=yy&quot;</span><br></pre></td></tr></table></figure>
<h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><p><a href="https://github.com/Yanjunhui/chat.git">https://github.com/Yanjunhui/chat.git</a></p>
<h4 id="一-申请企业号"><a href="#一-申请企业号" class="headerlink" title="一.申请企业号"></a>一.申请企业号</h4><p>以个人邮箱申请就可以, 不通过企业认证的话,有200人的限制,一般足够用了</p>
<h4 id="二-获取对接权限"><a href="#二-获取对接权限" class="headerlink" title="二.获取对接权限"></a>二.获取对接权限</h4><h5 id="1、获取corpid"><a href="#1、获取corpid" class="headerlink" title="1、获取corpid"></a>1、获取corpid</h5><p>登录后,我的企业 —-&gt; 企业信息 –&gt; CorpID<br><img data-src="https://img.econow.cn/2018/1539593796324.png" width="901"/><br>将 CorpID 配置到配置文件 config.conf 内 的 CorpID</p>
<h5 id="2、开启回调模式获取key"><a href="#2、开启回调模式获取key" class="headerlink" title="2、开启回调模式获取key"></a>2、开启回调模式获取key</h5><p>登录后,顶部菜单[企业应用] —-&gt; 添加应用<br>进入新添加的应用<br>拿到 AgentId 和 Secret<br><img data-src="https://img.econow.cn/2018/1539593870748.png" width="536"/></p>
<h5 id="3、关注微信公众号"><a href="#3、关注微信公众号" class="headerlink" title="3、关注微信公众号"></a>3、关注微信公众号</h5><p>使用微信关注企业号才可以从微信收到信息,否则只能从微信企业号 APP 中收到信息<br><img data-src="https://img.econow.cn/2018/1539594107364.png" width="845"/></p>
<h4 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://www.github.com/yanjunhui/chat.git</span><br></pre></td></tr></table></figure>

<h4 id="修改chat配置文件"><a href="#修改chat配置文件" class="headerlink" title="修改chat配置文件"></a>修改chat配置文件</h4><img data-src="https://img.econow.cn/2018/1539594319320.png" width="479"/>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#http 服务端口</span><br><span class="line">[http]</span><br><span class="line">port = 4567</span><br><span class="line"></span><br><span class="line">#微信接口信息</span><br><span class="line">[weixin]</span><br><span class="line">CorpID = xxxxxx</span><br><span class="line">#ID 应用ID</span><br><span class="line">AgentId = 1   </span><br><span class="line"># Secret</span><br><span class="line">Secret = xxxxxxx</span><br><span class="line">#最后一个无所谓</span><br><span class="line">EncodingAESKey = wodH5dMSQtlfySHED5dkk6dF7saukFpPxlwhWRsVeEn</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开目录 cd chat</span><br><span class="line">启动 ./control.sh start</span><br><span class="line">停止 ./control.sh stop</span><br><span class="line">重启 ./control.sh restart</span><br><span class="line">状态 ./control.sh status</span><br></pre></td></tr></table></figure>

<p>但是更新了版本，不知道为啥不正常，发布了微信。</p>
<p>推荐另一种方式，更好调试。</p>
<h3 id="Falcon-wechat"><a href="#Falcon-wechat" class="headerlink" title="Falcon-wechat"></a>Falcon-wechat</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/falcon-wechat</span><br><span class="line">cd /usr/local/falcon-wechat</span><br><span class="line">wget https://dl.cactifans.com/open-falcon/falcon-wechat-0.0.1.tar.gz</span><br><span class="line">tar zxvf falcon-wechat-0.0.1.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;debug&quot;: true,</span><br><span class="line">&quot;http&quot;: &#123;</span><br><span class="line">&quot;listen&quot;: &quot;0.0.0.0:9527&quot;,</span><br><span class="line">&quot;token&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;wechat&quot;: &#123;</span><br><span class="line">&quot;corpid&quot;: &quot;wxa7c63522727b6bf0&quot;,</span><br><span class="line">&quot;secret&quot;: &quot;d5S-_XGVd-5HA0o9bkvMMK5Wh1qwCC-YQei4WcL9hSM&quot;,</span><br><span class="line">&quot;agentid&quot;: 1</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改alarm接口，重启即可，还能看日志。</p>
<p><a href="https://www.cactifans.org/open-falcon/1788.html">https://www.cactifans.org/open-falcon/1788.html</a></p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="http://book.open-falcon.org/zh_0_2/">http://book.open-falcon.org/zh_0_2&#x2F;</a><br><a href="https://github.com/open-falcon/falcon-plus">https://github.com/open-falcon/falcon-plus</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenVpn 最新版部署</title>
    <url>/OpenVpn%20%E6%9C%80%E6%96%B0%E7%89%88%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、yum方式（推荐）"><a href="#1、yum方式（推荐）" class="headerlink" title="1、yum方式（推荐）"></a>1、yum方式（推荐）</h3><p>推荐使用yum方式安装，因为之前曾经发生过莫名其妙服务自己停止的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install openvpn open-ssl -y</span><br><span class="line">yum install easy-rsa openssl  -y</span><br></pre></td></tr></table></figure>
<h3 id="2、编译安装"><a href="#2、编译安装" class="headerlink" title="2、编译安装"></a>2、编译安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install pam-devel open-ssl -y</span><br><span class="line"></span><br><span class="line">cd /usr/src</span><br><span class="line">wget http://www.oberhumer.com/opensource/lzo/download/lzo-2.06.tar.gz</span><br><span class="line">tar zxvf lzo-2.06.tar.gz</span><br><span class="line">cd lzo-2.06</span><br><span class="line">./configure --prefix=/usr/local/</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">cd /usr/src</span><br><span class="line">tar -zxvf openvpn-2.4.6.tar.gz</span><br><span class="line"> cd openvpn-2.4.6</span><br><span class="line">./configure --prefix=/usr/local/openvpn --with-lzo-lib=/usr/local/lzo/lib --with-lzo-headers=/usr/local/lzo/include/</span><br></pre></td></tr></table></figure>
<h2 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h2><p>当前配置是按照编译安装的目录，yum安装目录在&#x2F;etc&#x2F;openvpn</p>
<h3 id="创建-PKI-和-CA"><a href="#创建-PKI-和-CA" class="headerlink" title="创建 PKI 和 CA"></a>创建 PKI 和 CA</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost 3.0.3]# pwd</span><br><span class="line">/etc/openvpn/server</span><br><span class="line">[root@localhost 3.0.3]# cp -r  /usr/share/easy-rsa .</span><br><span class="line">[root@localhost 3.0.3]# rm 3 3.0 </span><br><span class="line">[root@localhost 3.0.3]# cd /etc/openvpn/server/easy-rsa/3.0.3</span><br><span class="line">[root@localhost 3.0.3]# ./easyrsa init-pki  #创建空的pki</span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: ./vars</span><br><span class="line"></span><br><span class="line">init-pki complete; you may now create a CA or requests.</span><br><span class="line">Your newly created PKI dir is: /etc/openvpn/easy-rsa/3.0.3/pki</span><br><span class="line"></span><br><span class="line">[root@localhost 3.0.3]# ./easyrsa build-ca nopass #创建新的CA，不使用密码</span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: ./vars</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">......................+++</span><br><span class="line">................................................+++</span><br><span class="line">writing new private key to &#x27;/etc/openvpn/easy-rsa/3.0.3/pki/private/ca.key.pClvaQ1GLD&#x27;</span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Common Name (eg: your user, host, or server name) [Easy-RSA CA]: 回车</span><br><span class="line"></span><br><span class="line">CA creation complete and you may now import and sign cert requests.</span><br><span class="line">Your new CA certificate file for publishing is at:</span><br><span class="line">/etc/openvpn/easy-rsa/3.0.3/pki/ca.crt</span><br></pre></td></tr></table></figure>
<h4 id="创建服务端证书"><a href="#创建服务端证书" class="headerlink" title="创建服务端证书"></a>创建服务端证书</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost 3.0.3]# ./easyrsa gen-req server nopass</span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: ./vars</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">...........................+++</span><br><span class="line">..............................................................................+++</span><br><span class="line">writing new private key to &#x27;/etc/openvpn/easy-rsa/3.0.3/pki/private/server.key.wy7Q0fuG6A&#x27;</span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Common Name (eg: your user, host, or server name) [server]: 回车</span><br><span class="line"></span><br><span class="line">Keypair and certificate request completed. Your files are:</span><br><span class="line">req: /etc/openvpn/easy-rsa/3.0.3/pki/reqs/server.req</span><br><span class="line">key: /etc/openvpn/easy-rsa/3.0.3/pki/private/server.key</span><br></pre></td></tr></table></figure>
<h4 id="签约服务端证书"><a href="#签约服务端证书" class="headerlink" title="签约服务端证书"></a>签约服务端证书</h4><p>注意操作目录是在server目录里的  <code>/etc/openvpn/server/easy-rsa/3.0.3</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost 3.0.3]# ./easyrsa sign server server</span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: ./vars</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You are about to sign the following certificate.</span><br><span class="line">Please check over the details shown below for accuracy. Note that this request</span><br><span class="line">has not been cryptographically verified. Please be sure it came from a trusted</span><br><span class="line">source or that you have verified the request checksum with the sender.</span><br><span class="line"></span><br><span class="line">Request subject, to be signed as a server certificate for 3650 days:</span><br><span class="line"></span><br><span class="line">subject=</span><br><span class="line">    commonName                = server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type the word &#x27;yes&#x27; to continue, or any other input to abort.</span><br><span class="line">  Confirm request details: yes</span><br><span class="line">Using configuration from ./openssl-1.0.cnf</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">The Subject&#x27;s Distinguished Name is as follows</span><br><span class="line">commonName            :ASN.1 12:&#x27;server&#x27;</span><br><span class="line">Certificate is to be certified until Apr  7 14:54:08 2028 GMT (3650 days)</span><br><span class="line"></span><br><span class="line">Write out database with 1 new entries</span><br><span class="line">Data Base Updated</span><br><span class="line"></span><br><span class="line">Certificate created at: /etc/openvpn/easy-rsa/3.0.3/pki/issued/server.crt</span><br></pre></td></tr></table></figure>
<h4 id="创建-Diffie-Hellman"><a href="#创建-Diffie-Hellman" class="headerlink" title="创建 Diffie-Hellman"></a>创建 Diffie-Hellman</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost 3.0.3]# ./easyrsa gen-dh</span><br><span class="line">............................................................</span><br><span class="line">DH parameters of size 2048 created at /etc/openvpn/easy-rsa/3.0.3/pki/dh.pem</span><br></pre></td></tr></table></figure>
<h3 id="创建客户端证书"><a href="#创建客户端证书" class="headerlink" title="创建客户端证书"></a>创建客户端证书</h3><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r /usr/share/easy-rsa/ /etc/openvpn/client/easy-rsa</span><br><span class="line">cd /etc/openvpn/client/easy-rsa/</span><br><span class="line">rm 3 3.0</span><br><span class="line">cd 3.0.3/</span><br><span class="line">find /usr/share/doc/easy-rsa-3.0.3/vars.example -type f -name &quot;vars.example&quot; | xargs -i cp &#123;&#125; . &amp;&amp; mv vars.example vars</span><br></pre></td></tr></table></figure>
<h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><p>操作目录 <code>/etc/openvpn/server/easy-rsa/3.0.3</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost 3.0.3]# pwd</span><br><span class="line">/etc/openvpn/client/easy-rsa/3.0.3</span><br><span class="line">[root@localhost 3.0.3]# ./easyrsa init-pki #创建新的pki</span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: ./vars</span><br><span class="line"></span><br><span class="line">init-pki complete; you may now create a CA or requests.</span><br><span class="line">Your newly created PKI dir is: /etc/openvpn/client/easy-rsa/3.0.3/pki</span><br><span class="line">[root@localhost 3.0.3]# ./easyrsa gen-req joy01 nopass  #客户证书名为joy01，木有密码</span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: ./vars</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">....................................................+++</span><br><span class="line">............+++</span><br><span class="line">writing new private key to &#x27;/etc/openvpn/client/easy-rsa/3.0.3/pki/private/joy01.key.FkrLzXH9Bm&#x27;</span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Common Name (eg: your user, host, or server name) [joy01]: 回车</span><br><span class="line"></span><br><span class="line">Keypair and certificate request completed. Your files are:</span><br><span class="line">req: /etc/openvpn/client/easy-rsa/3.0.3/pki/reqs/joy01.req</span><br><span class="line">key: /etc/openvpn/client/easy-rsa/3.0.3/pki/private/joy01.key</span><br></pre></td></tr></table></figure>
<h4 id="签约客户端证书"><a href="#签约客户端证书" class="headerlink" title="签约客户端证书"></a>签约客户端证书</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost 3.0.3]# cd /etc/openvpn/server/easy-rsa/3.0.3/</span><br><span class="line">[root@localhost 3.0.3]# pwd</span><br><span class="line">/etc/openvpn/server/easy-rsa/3.0.3</span><br><span class="line">[root@localhost 3.0.3]# ./easyrsa import-req /etc/openvpn/client/easy-rsa/3.0.3/pki/reqs/joy01.req joy01</span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: ./vars</span><br><span class="line"></span><br><span class="line">The request has been successfully imported with a short name of: joy01</span><br><span class="line">You may now use this name to perform signing operations on this request.</span><br><span class="line"></span><br><span class="line">[root@localhost 3.0.3]# ./easyrsa sign client joy01</span><br><span class="line"></span><br><span class="line">Note: using Easy-RSA configuration from: ./vars</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You are about to sign the following certificate.</span><br><span class="line">Please check over the details shown below for accuracy. Note that this request</span><br><span class="line">has not been cryptographically verified. Please be sure it came from a trusted</span><br><span class="line">source or that you have verified the request checksum with the sender.</span><br><span class="line"></span><br><span class="line">Request subject, to be signed as a client certificate for 3650 days:</span><br><span class="line"></span><br><span class="line">subject=</span><br><span class="line">    commonName                = joy01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type the word &#x27;yes&#x27; to continue, or any other input to abort.</span><br><span class="line">  Confirm request details: yes</span><br><span class="line">Using configuration from ./openssl-1.0.cnf</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">The Subject&#x27;s Distinguished Name is as follows</span><br><span class="line">commonName            :ASN.1 12:&#x27;joy01&#x27;</span><br><span class="line">Certificate is to be certified until Apr  8 01:54:57 2028 GMT (3650 days)</span><br><span class="line"></span><br><span class="line">Write out database with 1 new entries</span><br><span class="line">Data Base Updated</span><br><span class="line"></span><br><span class="line">Certificate created at: /etc/openvpn/easy-rsa/3.0.3/pki/issued/joy01.crt</span><br></pre></td></tr></table></figure>
<h3 id="整理证书"><a href="#整理证书" class="headerlink" title="整理证书"></a>整理证书</h3><h4 id="server-端证书"><a href="#server-端证书" class="headerlink" title="server 端证书"></a>server 端证书</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /etc/openvpn/certs</span><br><span class="line">[root@localhost ~]# cd /etc/openvpn/certs/</span><br><span class="line">[root@localhost certs]# cp /etc/openvpn/easy-rsa/3.0.3/pki/dh.pem .</span><br><span class="line">[root@localhost certs]# cp /etc/openvpn/easy-rsa/3.0.3/pki/ca.crt .</span><br><span class="line">[root@localhost certs]# cp /etc/openvpn/easy-rsa/3.0.3/pki/issued/server.crt .</span><br><span class="line">[root@localhost certs]# cp /etc/openvpn/easy-rsa/3.0.3/pki/private/server.key .</span><br><span class="line">[root@localhost certs]# ll</span><br><span class="line">总用量 20</span><br><span class="line">-rw-------. 1 root root 1172 4月  11 10:02 ca.crt</span><br><span class="line">-rw-------. 1 root root  424 4月  11 10:03 dh.pem</span><br><span class="line">-rw-------. 1 root root 4547 4月  11 10:03 server.crt</span><br><span class="line">-rw-------. 1 root root 1704 4月  11 10:02 server.key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost certs]# mkdir /etc/openvpn/client/joy01/</span><br><span class="line">[root@localhost certs]# cp /etc/openvpn/easy-rsa/3.0.3/pki/ca.crt /etc/openvpn/client/joy01/</span><br><span class="line">[root@localhost certs]# cp /etc/openvpn/easy-rsa/3.0.3/pki/issued/joy01.crt /etc/openvpn/client/joy01/</span><br><span class="line">[root@localhost certs]# cp /etc/openvpn/client/easy-rsa/3.0.3/pki/private/joy01.key /etc/openvpn/client/joy01/</span><br><span class="line">[root@localhost certs]# ll /etc/openvpn/client/joy01/</span><br><span class="line">总用量 16</span><br><span class="line">-rw-------. 1 root root 1172 4月  11 10:07 ca.crt</span><br><span class="line">-rw-------. 1 root root 4431 4月  11 10:08 joy01.crt</span><br><span class="line">-rw-------. 1 root root 1704 4月  11 10:08 joy01.key</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>一切操作只需要在服务器，client不需要！！！</p>
<h4 id="开启转发"><a href="#开启转发" class="headerlink" title="开启转发"></a>开启转发</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;net.ipv4.ip_forward = 1&#x27; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/2018/1544336390853.png" width="262"/> 

<h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><p>清空防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">ipatbles -Z</span><br></pre></td></tr></table></figure>
<p>接下来的配置之前需要先了解以下概念：</p>
<ul>
<li><p>NAT 的原理 简单的说就是当内网主机访问外网时，当内网主机的数据包要通过路由器时，路由器将数据包中的源内网 IP 地址改为路由器上的公网 IP 地址，同时记录下该数据包的消息；当外网服务器响应这次由内而外发出的请求或数据交换时，当外网服务器发出的数据包经过路由器时，原本是路由器上的公网 IP 地址被路由器改为内网 IP 。</p>
<ul>
<li>SNAT是source networkaddress translation的缩写，即源地址目标转换。比如，多个PC机使用ADSL路由器共享上网，每个PC机都配置了内网IP，PC机访问外部网络的时候，路由器将数据包的报头中的源地址替换成路由器的ip，当外部网络的服务器比如网站web服务器接到访问请求的时候，他的日志记录下来的是路由器的ip地址，而不是pc机的内网ip，这是因为，这个服务器收到的数据包的报头里边的“源地址”，已经被替换了，所以叫做SNAT，基于源地址的地址转换。  </li>
<li>DNAT是destination networkaddress translation的缩写，即目标网络地址转换，典型的应用是，有个web服务器放在内网配置内网ip，前端有个防火墙配置公网ip，互联网上的访问者使用公网ip来访问这个网站，当访问的时候，客户端发出一个数据包，这个数据包的报头里边，目标地址写的是防火墙的公网ip，防火墙会把这个数据包的报头改写一次，将目标地址改写成web服务器的内网ip，然后再把这个数据包发送到内网的web服务器上，这样，数据包就穿透了防火墙，并从公网ip变成了一个对内网地址的访问了，即DNAT，基于目标的网络地址转换。</li>
<li>MASQUERADE，地址伪装，属于nat的一种。算是snat中的一种特例，可以实现自动化的snat。MASQUERADE是用发送数据的网卡上的IP来替换源IP，因此，对于那些IP不固定的场合，比如拨号网络或者通过dhcp分配IP的情况下，就得用MASQUERADE。</li>
</ul>
</li>
<li><p>如果内网主机访问外网而经过路由时，源 IP 会发生改变，这种变更行为就是 SNAT；反之，当外网的数据经过路由发往内网主机时，数据包中的目的 IP (路由器上的公网 IP) 将修改为内网 IP，这种变更行为就是 DNAT 。与 SNAT 和 DNAT所对应的两个链分别是  POSTROUTING和PREROUTING。</p>
<ul>
<li>POSTROUTING是源地址转换，要把你的内网地址转换成公网地址才能让你上网。</li>
<li>PREROUTING是目的地址转换，要把别人的公网IP换成你们内部的IP，才让访问到你们内部受防火墙保护的机器</li>
</ul>
</li>
</ul>
<p>综上所述，简单理解就是从服务器网卡获取当前IP来做SNAT。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">iptables -A FORWARD -s 172.16.0.0/24 -j ACCEPT  </span><br><span class="line">iptables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT  </span><br><span class="line"></span><br><span class="line">#检查</span><br><span class="line">iptables  -t  nat  -nL</span><br><span class="line"></span><br><span class="line">#转发</span><br><span class="line">iptables -t nat -A POSTROUTING -s 172.16.0.0/24  -j MASQUERADE</span><br><span class="line">  or</span><br><span class="line">iptables -t nat -A POSTROUTING -s 172.16.0.0/24 -o eth0 -j MASQUERADE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>检查FORWARD<br><img data-src="https://img.econow.cn/2018/1544336486389.png" width="716"/></p>
<p>检查MASQUERADE<br><img data-src="https://img.econow.cn/2018/1544336462517.png" width="480"/>  </p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 1194</span><br><span class="line">proto udp</span><br><span class="line">dev tun</span><br><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key</span><br><span class="line">dh dh.pem</span><br><span class="line">server 172.16.0.0 255.255.255.0</span><br><span class="line">ifconfig-pool-persist ipp.txt</span><br><span class="line">client-config-dir ccd</span><br><span class="line">push &quot;redirect-gateway def1 bypass-dhcp&quot;</span><br><span class="line">push &quot;dhcp-option DNS 208.67.222.222&quot;</span><br><span class="line">push &quot;dhcp-option DNS 208.67.220.220&quot;</span><br><span class="line">client-to-client</span><br><span class="line">duplicate-cn</span><br><span class="line">keepalive 10 120</span><br><span class="line"></span><br><span class="line">;cipher BF-CBC</span><br><span class="line">;cipher AES-128-CBC</span><br><span class="line">;cipher DES-EDE3-CBC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">comp-lzo</span><br><span class="line">;max-clients 100</span><br><span class="line">log         openvpn.log</span><br><span class="line">status openvpn-status.log</span><br><span class="line">verb 3</span><br><span class="line">mute 20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“redirect-gateway def1 bypass-dhcp”的目的是在所有客戶端的默认网络都重定向到服务器,它的目的就是客户端在使用不同的私有地址时可以确保能连上OpenVPN服务器。<br>但是如果有时候客户端无法正常上网，那么就得换种方式。<code>push &quot;route 10.110.1.0 255.255.255.0&quot;</code>就像这样推送服务器的路由。  </p>
</blockquote>
<p>如果想使用固定IP，那么就开启<code>&quot;client-config-dir ccd&quot;</code></p>
<ul>
<li>在服务器端创建ccd目录</li>
<li>按照用户名创建文件，类似”ifconfig-push 10.8.0.18 255.255.255.0”</li>
</ul>
<h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto udp</span><br><span class="line">remote 服务器外网IP</span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">user nobody</span><br><span class="line">group nobody</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">ca ca.crt</span><br><span class="line">cert xiajie.crt</span><br><span class="line">key xiajie.key</span><br><span class="line">comp-lzo</span><br><span class="line">verb 3</span><br><span class="line">redirect-gateway def1</span><br></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl -f enable openvpn@server</span><br><span class="line">systemctl start openvpn@server</span><br></pre></td></tr></table></figure>
<h2 id="服务检查"><a href="#服务检查" class="headerlink" title="服务检查"></a>服务检查</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><img data-src="https://img.econow.cn/2018/1544337135904.png" width="668"/>
### 客户端（Windows）

<img data-src="https://img.econow.cn/2018/1544337254592.png" width="642"/>


<h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><ul>
<li>客户端直接无法访问，虚拟IP不通，内网不通<br>检查服务器端配置文件<code>client-to-client</code></li>
<li>如果还是不通，或者无法访问外网，检查<code>push &quot;redirect-gateway def1 bypass-dhcp&quot;</code>是否注释或者有没有推送路由。  </li>
<li>如果追求速度就选择UDP，如果选择可靠质量就选择TCP。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>远程办公工具配置</title>
    <url>/PPTP-VPN%20%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<blockquote>
<p>公司内网环境VPN有两种连接方式，PPTP和L2TP。其中PPTP连接较为简单，L2TP作为备用方式（OS X 系统只支持L2TP）</p>
</blockquote>
<h2 id="PPTP"><a href="#PPTP" class="headerlink" title="PPTP"></a>PPTP</h2><p>推荐使用该方式，操作简单</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>1 网络-》增加</p>
<img data-src="https://img.econow.cn/medivh/1553150666742.png" />


<p>2 选择VPN类型</p>
<img data-src="https://img.econow.cn/medivh/1553150619851.png" />

<p>3 填写信息<br><img data-src="https://img.econow.cn/medivh/1555220994661.png"  /></p>
<p>4 点击应用，选择存储配置<br><img data-src="https://img.econow.cn/medivh/1553150821150.png" /></p>
<p>5 点击连接</p>
<p>6 输入密码即可<br><img data-src="https://img.econow.cn/medivh/1553150930004.png" /></p>
<p>7 正常状态</p>
<img data-src="https://img.econow.cn/medivh/1555220885060.png"  />


<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>1 新建连接<br><img data-src="https://img.econow.cn/medivh/1553151087777.png" /><br>2 选择连接到工作区<br><img data-src="https://img.econow.cn/medivh/1553151118428.png" /><br>3 选择第一种<br><img data-src="https://img.econow.cn/medivh/1553151166006.png" /><br>4 填写IP地址，点击创建<br><img data-src="https://img.econow.cn/medivh/1555220947107.png"  /></p>
<p>5 连接</p>
<img data-src="https://img.econow.cn/medivh/1553151257736.png" />

<p>6 输入用户名和密码<br><img data-src="https://img.econow.cn/medivh/1553151297480.png" /></p>
<p>7 如果顺利，就会提示已连接<br><img data-src="https://img.econow.cn/medivh/1553151325810.png" /></p>
<h2 id="L2TP"><a href="#L2TP" class="headerlink" title="L2TP"></a>L2TP</h2><p>对于一些新款设备只支持该方式。</p>
<h3 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a>Mac</h3><p>对于windows系统来说可以直接配置，不需要修改一下文件。<br>准备工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ppp/options</span><br><span class="line"></span><br><span class="line">#在options文件中输入：</span><br><span class="line"></span><br><span class="line">plugin L2TP.ppp</span><br><span class="line">l2tpnoipsec</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1、新建<br><img data-src="https://img.econow.cn/medivh/1555221072317.png"  /></p>
<p>2、填写信息<br><img data-src="https://img.econow.cn/medivh/1555221109294.png"  /></p>
<p>3、密码<br>该部分分为用户密码和共享密钥(123456)<br><img data-src="https://img.econow.cn/medivh/1555221192662.png"  /></p>
<p>4、连接</p>
<img data-src="https://img.econow.cn/medivh/1555221249767.png"  />


<p>5、如果出现一下情况，请检查前面的修改配置文件。<br><img data-src="https://img.econow.cn/medivh/1555221742632.png"  /></p>
]]></content>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 文件/目录操作</title>
    <url>/Python%20%E6%96%87%E4%BB%B6:%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><h2 id="sqlite-日期"><a href="#sqlite-日期" class="headerlink" title="sqlite 日期"></a>sqlite 日期</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----昨天</span><br><span class="line">select * from 表 where Time&gt;=datetime(&#x27;now&#x27;,&#x27;start of day&#x27;,&#x27;-1 day&#x27;) and Time&lt;datetime(&#x27;now&#x27;,&#x27;start of day&#x27;,&#x27;+0 day&#x27;)</span><br><span class="line"></span><br><span class="line">----当天</span><br><span class="line">select * from 表 where Time&gt;=datetime(&#x27;now&#x27;,&#x27;start of day&#x27;,&#x27;+0 day&#x27;) and Time&lt;datetime(&#x27;now&#x27;,&#x27;start of day&#x27;,&#x27;+1 day&#x27;)</span><br><span class="line"></span><br><span class="line">----当周</span><br><span class="line">select  * from 表 where Time&gt;=datetime(&#x27;now&#x27;,&#x27;start of day&#x27;,&#x27;-7 day&#x27;,&#x27;weekday 1&#x27;) AND Time&lt;datetime(&#x27;now&#x27;,&#x27;start of day&#x27;,&#x27;+0 day&#x27;,&#x27;weekday 1&#x27;)</span><br><span class="line"></span><br><span class="line">----当月</span><br><span class="line">select * from 表 where Time&gt;=datetime(&#x27;now&#x27;,&#x27;start of month&#x27;,&#x27;+0 month&#x27;,&#x27;-0 day&#x27;) AND Time &lt; datetime(&#x27;now&#x27;,&#x27;start of month&#x27;,&#x27;+1 month&#x27;,&#x27;0 day&#x27;)</span><br><span class="line"></span><br><span class="line">----上月</span><br><span class="line">select * from 表 where Time&gt;=datetime(&#x27;now&#x27;,&#x27;start of month&#x27;,&#x27;-1 month&#x27;,&#x27;-0 day&#x27;) AND Time &lt;datetime(&#x27;now&#x27;,&#x27;start of month&#x27;,&#x27;+0 month&#x27;,&#x27;-1 day&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python+pycurl监控网站</title>
    <url>/Python-pycurl%E7%9B%91%E6%8E%A7%E7%BD%91%E7%AB%99.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>打算写个监控网站状态的小脚本，用到pycurl，但是提示找不到curl-config，那就手动安装吧。<br>Pycurl包是一个libcurl的Python接口，它是由C语言编写的。与urllib相比，pycurl的速度要快很多。</p>
<p>Libcurl 是一个支持FTP，FTPS，HTTP，HTTPS，GOPHER，TELNET，DICT，FILE 和 LDAP的客户端URL传输库。libcurl也支持HTTPS认证，HTTP、POST、HTTP PUT、FTP上传，代理，Cookies，基本身份验证，FTP文件断点继传，HTTP代理通道等等。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd src</span><br><span class="line">sudo wget http://curl.haxx.se/download/curl-7.24.0.tar.gz</span><br><span class="line">tar -zxvf curl-7.24.0.tar.gz</span><br><span class="line">cd curl-7.24.0</span><br><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>检查curl-config是否存在，如果存在则继续安装，pip3 或者下载安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">sudo wget http://pycurl.sourceforge.net/download/pycurl-7.19.0.tar.gz</span><br><span class="line">tar -zxvf pycurl-7.19.0.tar.gz</span><br><span class="line">cd pycurl-7.19.0</span><br><span class="line">python3 setup.py install --curl-config=/usr/local/bin/curl-config</span><br></pre></td></tr></table></figure>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c = pycurl.Curl()    #创建一个curl对象 </span><br><span class="line">c.setopt(pycurl.CONNECTTIMEOUT, 5)    #连接的等待时间，设置为0则不等待  </span><br><span class="line">c.setopt(pycurl.TIMEOUT, 5)           #请求超时时间  </span><br><span class="line">c.setopt(pycurl.NOPROGRESS, 0)        #是否屏蔽下载进度条，非0则屏蔽  </span><br><span class="line">c.setopt(pycurl.MAXREDIRS, 5)         #指定HTTP重定向的最大数  </span><br><span class="line">c.setopt(pycurl.FORBID_REUSE, 1)      #完成交互后强制断开连接，不重用  </span><br><span class="line">c.setopt(pycurl.FRESH_CONNECT,1)      #强制获取新的连接，即替代缓存中的连接  </span><br><span class="line">c.setopt(pycurl.DNS_CACHE_TIMEOUT,60) #设置保存DNS信息的时间，默认为120秒  </span><br><span class="line">c.setopt(pycurl.URL,&quot;http://www.baidu.com&quot;)      #指定请求的URL  </span><br><span class="line">c.setopt(pycurl.USERAGENT,&quot;Mozilla/5.2 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50324)&quot;)    #配置请求HTTP头的User-Agent</span><br><span class="line">c.setopt(pycurl.HEADERFUNCTION, getheader)   #将返回的HTTP HEADER定向到回调函数getheader</span><br><span class="line">c.setopt(pycurl.WRITEFUNCTION, getbody)      #将返回的内容定向到回调函数getbody</span><br><span class="line">c.setopt(pycurl.WRITEHEADER, fileobj)        #将返回的HTTP HEADER定向到fileobj文件对象</span><br><span class="line">c.setopt(pycurl.WRITEDATA, fileobj)          #将返回的HTML内容定向到fileobj文件对象</span><br><span class="line">c.getinfo(pycurl.HTTP_CODE)         #返回的HTTP状态码</span><br><span class="line">c.getinfo(pycurl.TOTAL_TIME)        #传输结束所消耗的总时间</span><br><span class="line">c.getinfo(pycurl.NAMELOOKUP_TIME)   #DNS解析所消耗的时间</span><br><span class="line">c.getinfo(pycurl.CONNECT_TIME)      #建立连接所消耗的时间</span><br><span class="line">c.getinfo(pycurl.PRETRANSFER_TIME)  #从建立连接到准备传输所消耗的时间</span><br><span class="line">c.getinfo(pycurl.STARTTRANSFER_TIME)    #从建立连接到传输开始消耗的时间</span><br><span class="line">c.getinfo(pycurl.REDIRECT_TIME)     #重定向所消耗的时间</span><br><span class="line">c.getinfo(pycurl.SIZE_UPLOAD)       #上传数据包大小</span><br><span class="line">c.getinfo(pycurl.SIZE_DOWNLOAD)     #下载数据包大小 </span><br><span class="line">c.getinfo(pycurl.SPEED_DOWNLOAD)    #平均下载速度</span><br><span class="line">c.getinfo(pycurl.SPEED_UPLOAD)      #平均上传速度</span><br><span class="line">c.getinfo(pycurl.HEADER_SIZE)       #HTTP头部大小</span><br></pre></td></tr></table></figure>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pycurl</span><br><span class="line">import io</span><br><span class="line">url=&#x27;www.baidu.com&#x27;</span><br><span class="line">c=pycurl.Curl()</span><br><span class="line">c.setopt(c.URL, url)</span><br><span class="line">b = io.StringIO()</span><br><span class="line">c.setopt(c.WRITEFUNCTION, b.write)</span><br><span class="line">#c.setopt(c.FOLLOWLOCATION, 1)</span><br><span class="line">#c.setopt(c.HEADER, True) </span><br><span class="line">c.perform()   </span><br><span class="line">print(b.getvalue())   </span><br><span class="line">b.close()</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pycurl</span><br><span class="line">import io</span><br><span class="line">import wechat_sms</span><br><span class="line">import time</span><br><span class="line">def check_status(url):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    检查网站状态</span><br><span class="line">    :param url:</span><br><span class="line">    :return: 异常信息,正常则不返回</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    c = pycurl.Curl()</span><br><span class="line">    #pycurl 实例</span><br><span class="line">    c.setopt(pycurl.URL, url)</span><br><span class="line">    c.setopt(pycurl.TIMEOUT,10)</span><br><span class="line">    #超时时间</span><br><span class="line">    b = io.BytesIO()</span><br><span class="line">    c.setopt(pycurl.WRITEFUNCTION, b.write)</span><br><span class="line">    c.perform()</span><br><span class="line">    code = c.getinfo(pycurl.HTTP_CODE)</span><br><span class="line">    #状态码</span><br><span class="line">    total_time = &#x27;%.2f&#x27;%c.getinfo(pycurl.TOTAL_TIME)</span><br><span class="line">    #总时间</span><br><span class="line">    dns = &#x27;%.2f&#x27;%c.getinfo(pycurl.NAMELOOKUP_TIME)</span><br><span class="line">    #DNS解析消耗</span><br><span class="line">    connet_time = &#x27;%.2f&#x27;%c.getinfo(pycurl.CONNECT_TIME)</span><br><span class="line">    #建立连接时间</span><br><span class="line">    PRETRANSFER_TIME = &#x27;%.2f&#x27;%c.getinfo(pycurl.PRETRANSFER_TIME)</span><br><span class="line">    #建立连接到准备传输数据时间</span><br><span class="line">    STARTTRANSFER_TIME = &#x27;%.2f&#x27;%c.getinfo(pycurl.STARTTRANSFER_TIME)</span><br><span class="line">    #建立连接到传输开始消耗的时间</span><br><span class="line">    download = c.getinfo(pycurl.SPEED_DOWNLOAD)</span><br><span class="line">    #平均下载速度</span><br><span class="line">    info = (&#x27;HTTP   Code: %s\nTotal time: %s ms\nDNS lookup time: %s ms\nCONNECT_TIME:  %s ms\nPRETRANSFER_TIME: %s ms\nSTARTTRANSFER_TIME: %s ms\nDownload Speed: %s byte/s&#x27; % (code, total_time, dns,connet_time,PRETRANSFER_TIME,STARTTRANSFER_TIME,download))</span><br><span class="line">    print(code)</span><br><span class="line">    if code &gt; 400 and connet_time &gt; 10:</span><br><span class="line">        #如果状态码大于400,或者消耗时间大于10秒,说明网站有问题,发送错误信息;否则不返回</span><br><span class="line">        return info</span><br><span class="line">    else:</span><br><span class="line">        return True</span><br><span class="line">def send_sms(url):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    发送信息</span><br><span class="line">    :param url:</span><br><span class="line">    :return:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    msm = check_status(url)</span><br><span class="line">    project = &#x27;网站状态&#x27;</span><br><span class="line">    #如果网站状态返回为True,则跳出,否则返回具体信息</span><br><span class="line">    while msm is True:</span><br><span class="line">        print(msm)</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        print(msm)</span><br><span class="line">        WeChat.sendMessage(&#x27;medivh&#x27;, project, msm)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    WeChat = wechat_sms.WeChat(&#x27;https://qyapi.weixin.qq.com/cgi-bin&#x27;)</span><br><span class="line">    #自定义网站列表,循环执行对网站的检测</span><br><span class="line">    url_list = [&#x27;http://wechat.xxx.com&#x27;,&#x27;http://www.xxx.com&#x27;,&#x27;http://xxx.com&#x27;]</span><br><span class="line">    while True:</span><br><span class="line">        for i in url_list:</span><br><span class="line">            msm = send_sms(i)</span><br><span class="line">        # 30秒检查一次</span><br><span class="line">        time.sleep(30)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中使用list的一些不常见的操作</title>
    <url>//Python%E4%B8%AD%E4%BD%BF%E7%94%A8list%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C</url>
    <content><![CDATA[<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>使用list之前先学习一下random的使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机整数：</span></span><br><span class="line"><span class="built_in">print</span> random.randint(<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机选取0到100间的偶数：</span></span><br><span class="line"><span class="built_in">print</span> random.randrange(<span class="number">0</span>, <span class="number">101</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机浮点数：</span></span><br><span class="line"><span class="built_in">print</span> random.random()</span><br><span class="line"><span class="built_in">print</span> random.uniform(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机字符：</span></span><br><span class="line"><span class="built_in">print</span> random.choice(<span class="string">&#x27;abcdefghijklmnopqrstuvwxyz!@#$%^&amp;*()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个字符中生成指定数量的随机字符：</span></span><br><span class="line"><span class="built_in">print</span> random.sample(<span class="string">&#x27;zyxwvutsrqponmlkjihgfedcba&#x27;</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从a-zA-Z0-9生成指定数量的随机字符：</span></span><br><span class="line">ran_str = <span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span> ran_str</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个字符中选取指定数量的字符组成新字符串：</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(random.sample([<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>], <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机选取字符串：</span></span><br><span class="line"><span class="built_in">print</span> random.choice([<span class="string">&#x27;剪刀&#x27;</span>, <span class="string">&#x27;石头&#x27;</span>, <span class="string">&#x27;布&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打乱排序</span></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> random.shuffle(items)</span><br></pre></td></tr></table></figure>

<h2 id="针对list的一些操作"><a href="#针对list的一些操作" class="headerlink" title="针对list的一些操作"></a>针对list的一些操作</h2><h3 id="判断两个list是否有重叠"><a href="#判断两个list是否有重叠" class="headerlink" title="判断两个list是否有重叠"></a>判断两个list是否有重叠</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_overlap_list</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断两个list是否重叠</span></span><br><span class="line"><span class="string">    1. 转为list</span></span><br><span class="line"><span class="string">    2. 判断最大元素是否属于第一个tuple，并且最小元素不在第一个tuple，返回True，否则False</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s1 = (<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line">    s2 = (<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    s = <span class="built_in">list</span>(s1 + s2)</span><br><span class="line">    s.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> s[<span class="number">0</span>] == s1[<span class="number">1</span>] <span class="keyword">and</span> s[<span class="number">1</span>] != s1[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">get_overlap_list()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 </span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_overlap_tuple</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断两个tuple是否重叠；</span></span><br><span class="line"><span class="string">    分别判断第0个元素和第1个元素是否在另外一个tuple元素范围内</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s2 = (<span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line">    s1 = (<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> s1[<span class="number">0</span>] &lt;= s2[<span class="number">0</span>] &lt;= s1[<span class="number">1</span>] <span class="keyword">or</span> s1[<span class="number">0</span>] &lt;= s2[<span class="number">1</span>] &lt;= s1[<span class="number">1</span>] <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此处判断的是list，其实换成tuple也是一样的。</p>
<h3 id="list去重"><a href="#list去重" class="headerlink" title="list去重"></a>list去重</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]</span><br><span class="line">sqlist = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> sqlist:</span><br><span class="line">        sqlist.append(i)</span><br><span class="line"><span class="built_in">print</span>(sqlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化后的写法</span></span><br><span class="line"></span><br><span class="line">animal = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]</span><br><span class="line">newlist = <span class="built_in">list</span>()</span><br><span class="line">sqlist = [newlist.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> animal <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> newlist]</span><br><span class="line"><span class="built_in">print</span>(newlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>遍历原始list，如果元素不属于新的list则插入</p>
<h3 id="生成26个小写字母的list"><a href="#生成26个小写字母的list" class="headerlink" title="生成26个小写字母的list"></a>生成26个小写字母的list</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chars = [<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>,<span class="number">123</span>)]</span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27; &#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>使用<code>chr(ASSII)</code> 来定位字母</p>
<h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_reverse_list</span>():</span><br><span class="line">    num_list = [random.choice(<span class="built_in">range</span>(random.randint(<span class="number">1</span>, <span class="number">100</span>))) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    tmp_list = <span class="built_in">list</span>()</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num_list)):</span><br><span class="line">        <span class="comment"># 从下标为0开始插入</span></span><br><span class="line">        tmp_list.insert(<span class="number">0</span>, num_list[i])</span><br><span class="line">    <span class="keyword">return</span> tmp_list</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">46</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">73</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">10</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">60</span>, <span class="number">35</span>, <span class="number">33</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">73</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">46</span>]</span><br></pre></td></tr></table></figure>

<p>主要逻辑是使用insert插入到下标为0的元素，相当于遍历一遍从头开始插入。</p>
<h3 id="判断对称"><a href="#判断对称" class="headerlink" title="判断对称"></a>判断对称</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_symmetry_list</span>():</span><br><span class="line">    num_list = [random.choice(<span class="built_in">range</span>(random.randint(<span class="number">1</span>, <span class="number">100</span>))) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> <span class="built_in">len</span>(num_list) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>此处判断是否对称主要取决于元素个数是否为奇数，也就是range的次数。</p>
<h3 id="取出字符串最长的单词"><a href="#取出字符串最长的单词" class="headerlink" title="取出字符串最长的单词"></a>取出字符串最长的单词</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_word_list</span>():</span><br><span class="line">    chars = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;ha&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;books&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(chars[<span class="number">0</span>]) &lt; <span class="built_in">len</span>(chars[i]):</span><br><span class="line">            chars[<span class="number">0</span>] = chars[i]</span><br><span class="line">    <span class="keyword">return</span> chars[<span class="number">0</span>]</span><br><span class="line">get_word_list()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h3 id="列表按绝对值排序"><a href="#列表按绝对值排序" class="headerlink" title="列表按绝对值排序"></a>列表按绝对值排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">1</span>, -<span class="number">6</span>, <span class="number">2</span>, -<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">20</span>, -<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num_list)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num_list) - <span class="number">1</span> - i):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(num_list[j]) &lt; <span class="built_in">abs</span>(num_list[j + <span class="number">1</span>]):</span><br><span class="line">            num_list[j], num_list[j + <span class="number">1</span>] = num_list[j + <span class="number">1</span>], num_list[j]</span><br><span class="line"><span class="keyword">return</span> num_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">[<span class="number">20</span>, <span class="number">9</span>, -<span class="number">6</span>, -<span class="number">5</span>, <span class="number">4</span>, -<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在冒泡的方式排序的过程使用<code>abs()</code>获取绝对值。</p>
<h3 id="生成列表解析式-1-10之间的偶数"><a href="#生成列表解析式-1-10之间的偶数" class="headerlink" title="生成列表解析式 1-10之间的偶数"></a>生成列表解析式 1-10之间的偶数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>元素除以2为0则是偶数。</p>
<h3 id="找出最大元素的下标"><a href="#找出最大元素的下标" class="headerlink" title="找出最大元素的下标"></a>找出最大元素的下标</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>():</span><br><span class="line">    num_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">88</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">33</span>]</span><br><span class="line">    tmp_list = num_list.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num_list)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num_list) - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> num_list[j] &lt; num_list[j + <span class="number">1</span>]:</span><br><span class="line">                num_list[j], num_list[j + <span class="number">1</span>] = num_list[j + <span class="number">1</span>], num_list[j]</span><br><span class="line">    <span class="keyword">return</span> tmp_list.index(num_list[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="list-组合为string"><a href="#list-组合为string" class="headerlink" title="list 组合为string"></a>list 组合为string</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> l]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">12356</span></span><br></pre></td></tr></table></figure>

<p>str.join(item) join 函数是一个字符串操作函数。item表示一个成员，且只能有一个。上述代码中<code>&#39;&#39;.join(xxx)</code>含义是将字符串中的xxx以字符&#96;&#96;分割后再拼接为一个字符串，代码中为空，因此输出字符串中也无间隔。</p>
<p>其他示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> l]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误示例</span></span><br><span class="line"><span class="string">&#x27;,&#x27;</span>.join(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">TypeError: <span class="built_in">str</span>.join() takes exactly one argument (<span class="number">2</span> given)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="合并两个list为dict"><a href="#合并两个list为dict" class="headerlink" title="合并两个list为dict"></a>合并两个list为dict</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">list2dict</span>():</span><br><span class="line">    a = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">    b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    s = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        s[a[i]] = b[i]</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>zip的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(a,b)))</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>zip 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成多个tuple，然后返回由这些tuple组成的list。但是要注意版本区别，Python 2.0 返回的是list，Python 3.0 返回的是一个对象，需要手动list()转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python 2.0+</span></span><br><span class="line">&gt;&gt;&gt; a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c = [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(a,b)     <span class="comment"># 打包为元组的列表</span></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(a,c)              <span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(*zipped)          <span class="comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span></span><br><span class="line">[(1, 2, 3), (4, 5, 6)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 3.0+</span></span><br><span class="line">&gt;&gt;&gt; a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c = [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(a,b)     <span class="comment"># 返回一个对象</span></span><br><span class="line">&gt;&gt;&gt; zipped</span><br><span class="line">&lt;zip object at 0x103abc288&gt;</span><br><span class="line">&gt;&gt;&gt; list(zipped)  <span class="comment"># list() 转换为列表</span></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; list(zip(a,c))              <span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br></pre></td></tr></table></figure>

<p>dict()函数用于创建一个字典。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">class dict(**kwarg) </span><br><span class="line"><span class="comment"># **kwargs -- 关键字。</span></span><br><span class="line">class dict(mapping, **kwarg)</span><br><span class="line"><span class="comment"># mapping -- 元素的容器，映射类型（Mapping Types）是一种关联式的容器类型，它存储了对象与对象之间的映射关系。</span></span><br><span class="line">class dict(iterable, **kwarg)</span><br><span class="line"><span class="comment"># iterable -- 可迭代对象。</span></span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;dict()                        <span class="comment"># 创建空字典</span></span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; dict(a=<span class="string">&#x27;a&#x27;</span>, b=<span class="string">&#x27;b&#x27;</span>, t=<span class="string">&#x27;t&#x27;</span>)     <span class="comment"># 传入关键字</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;t&#x27;</span>: <span class="string">&#x27;t&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt; dict(zip([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [1, 2, 3]))   <span class="comment"># 映射函数方式来构造字典</span></span><br><span class="line">&#123;<span class="string">&#x27;three&#x27;</span>: 3, <span class="string">&#x27;two&#x27;</span>: 2, <span class="string">&#x27;one&#x27;</span>: 1&#125; </span><br><span class="line">&gt;&gt;&gt; dict([(<span class="string">&#x27;one&#x27;</span>, 1), (<span class="string">&#x27;two&#x27;</span>, 2), (<span class="string">&#x27;three&#x27;</span>, 3)])    <span class="comment"># 可迭代对象方式来构造字典</span></span><br><span class="line">&#123;<span class="string">&#x27;three&#x27;</span>: 3, <span class="string">&#x27;two&#x27;</span>: 2, <span class="string">&#x27;one&#x27;</span>: 1&#125;</span><br></pre></td></tr></table></figure>


<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>这里来讲述一下深拷贝和浅拷贝。</p>
<p><strong>变量</strong>存储在栈内存，<strong>对象</strong>存储在堆内存。</p>
<p><img data-src="https://img.econow.cn/medivh/1660127290005.png" alt="1660127290005.png"></p>
<p>浅拷贝只对源对象的引用进行拷贝，对象的内容不进行操作。实现原理：</p>
<ol>
<li>对于源对象是可变数据类型，在堆内存中创建新空间；</li>
<li>对于源对象不是可变数据类型，则拷贝起引用。</li>
</ol>
<blockquote>
<p>可变数据类型包括：List、Dictionary、<br>不可变数据类型包括：String、Number、Tuple</p>
</blockquote>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ol>
<li>不拷贝子对象的内容，只拷贝子对象的引用</li>
<li>可以使用内置函数<code>copy()</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单层浅拷贝-源对象是可变数据类型</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">c = copy.copy(a)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),<span class="built_in">id</span>(c))  <span class="comment"># 地址不相同</span></span><br><span class="line"><span class="number">4543590848</span> <span class="number">4542857664</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于源对象是可变数据类型，在堆内存中创建新空间。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ol>
<li>会连子对象的内存全部拷贝一份，对子对象的修改不会影响资源对象</li>
<li>可以使用内置函数<code>deeocopy()</code></li>
</ol>
<p><img data-src="https://img.econow.cn/medivh/1660127456935.png" alt="1660127456935.png"></p>
<p>源对象是不可变数据类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单层浅拷贝-源对象是不可变数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">c = copy.copy(a)</span><br><span class="line">d = copy.copy(b)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),<span class="built_in">id</span>(c)) <span class="comment"># 地址相同</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b),<span class="built_in">id</span>(d)) <span class="comment"># 地址相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">4474448176</span> <span class="number">4474448176</span></span><br><span class="line"><span class="number">4541979776</span> <span class="number">4541979776</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.econow.cn/medivh/1660188093129.png" alt="1660188093129.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>深浅拷贝都是对源对象的复制。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">23</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">354</span>, <span class="number">56</span>, <span class="number">77</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num_list)):  <span class="comment"># 从第0个元素开始循环</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num_list) - i - <span class="number">1</span>):  <span class="comment"># range范围为 总长度-1-当前元素，因为元素下标从0开始</span></span><br><span class="line">        <span class="keyword">if</span> num_list[j] &lt; num_list[j + <span class="number">1</span>]:  <span class="comment"># 如果该元素小于 下一个元素</span></span><br><span class="line">            <span class="built_in">print</span>(num_list[j], num_list[j + <span class="number">1</span>])</span><br><span class="line">            num_list[j], num_list[j + <span class="number">1</span>] = num_list[j + <span class="number">1</span>], num_list[j]  <span class="comment"># 那么当前排序就为 该元素的位置就和下一个元素调换</span></span><br><span class="line">        <span class="built_in">print</span>(num_list)</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br></pre></td></tr></table></figure>

<ol>
<li>首先第一层循环list；<ol>
<li>第二层循环list，范围为list总长度-1-当前元素（元素下标都是从0开始）<ol>
<li>如果该元素小于下一个元素<ol>
<li>赋值 元素&#x3D;下一个元素，下一个元素&#x3D;该元素 （当前元素和下一个元素进行调换）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>最后输出新的list就是排序后的list，从大到小。并且该算法还有两个规律：</p>
<ol>
<li><strong>循环总次数等于元素个数之和</strong>，比如10个元素需要55次、11个元素需要66次等等。</li>
<li><strong>切换一下判断条件可以直接改为从小大排序</strong>，<code>if num_list[j] &gt; num_list[j + 1]:</code></li>
</ol>
<h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><p>所谓二分法查找针对的是一个有序的数据集合，每次通过跟区间中的元素对比，将待查找的区间缩小为之前的一半，知道找到要查找的元素，或者区间缩小为0.</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">47</span>, <span class="number">50</span>, <span class="number">54</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">66</span>, <span class="number">72</span>, <span class="number">77</span>, <span class="number">80</span>, <span class="number">91</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">110</span>, <span class="number">113</span>, <span class="number">118</span>, <span class="number">123</span>, <span class="number">126</span>, <span class="number">130</span>, <span class="number">142</span>, <span class="number">143</span>, <span class="number">144</span>, <span class="number">145</span>, <span class="number">148</span>, <span class="number">152</span>, <span class="number">158</span>, <span class="number">162</span>, <span class="number">177</span>, <span class="number">179</span>, <span class="number">184</span>, <span class="number">196</span>, <span class="number">198</span>, <span class="number">198</span>, <span class="number">200</span>, <span class="number">212</span>, <span class="number">212</span>, <span class="number">218</span>, <span class="number">236</span>, <span class="number">259</span>, <span class="number">266</span>, <span class="number">290</span>, <span class="number">298</span>, <span class="number">304</span>, <span class="number">310</span>, <span class="number">311</span>, <span class="number">338</span>, <span class="number">347</span>, <span class="number">349</span>, <span class="number">350</span>, <span class="number">365</span>, <span class="number">377</span>, <span class="number">381</span>, <span class="number">389</span>, <span class="number">389</span>, <span class="number">395</span>, <span class="number">404</span>, <span class="number">408</span>, <span class="number">431</span>, <span class="number">446</span>, <span class="number">466</span>, <span class="number">480</span>, <span class="number">496</span>, <span class="number">503</span>, <span class="number">521</span>, <span class="number">528</span>, <span class="number">531</span>, <span class="number">555</span>, <span class="number">570</span>, <span class="number">576</span>, <span class="number">593</span>, <span class="number">625</span>, <span class="number">681</span>, <span class="number">687</span>, <span class="number">723</span>, <span class="number">818</span>, <span class="number">835</span>, <span class="number">844</span>, <span class="number">853</span>, <span class="number">854</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#函数递归</span></span><br><span class="line"><span class="comment">#定义一个函数,给三个形参:低位值，高位值，查找值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">low,height,findNum</span>):</span><br><span class="line">    <span class="comment">#计算出中位数</span></span><br><span class="line">    middle = low+(height-low)//<span class="number">2</span></span><br><span class="line">    <span class="comment">#如果中位数小于查找值,则锁定后半段</span></span><br><span class="line">    <span class="keyword">if</span> findNum &gt;array[middle]:</span><br><span class="line">        <span class="comment">#重置低位数</span></span><br><span class="line">        low = middle +<span class="number">1</span></span><br><span class="line">    <span class="comment">#如果中位数大于查找值,则锁定前半段</span></span><br><span class="line">    <span class="keyword">elif</span> findNum&lt;array[middle]:</span><br><span class="line">        <span class="comment">#重置高位值</span></span><br><span class="line">        height = middle - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#找到该值并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;该值下标为:%s,值为:%s&#x27;</span>%(middle,array[middle])</span><br><span class="line">    <span class="comment">#没有找到则调用自身继续查找</span></span><br><span class="line">    <span class="keyword">return</span> binarySearch(low,height,findNum)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(binarySearch(array[<span class="number">0</span>],<span class="built_in">len</span>(array)-<span class="number">1</span>,<span class="number">19</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">该值下标为:<span class="number">14</span>,值为:<span class="number">19</span></span><br></pre></td></tr></table></figure>

<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>容易出错的地方：</p>
<ol>
<li>mid的取值，mid&#x3D;(low+high)&#x2F;2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。正确的方法可以改为 <code>middle=low+(height-low)//2</code> 或者 <code>middle=low+((height-low)&gt;&gt;1)</code> (除以2的1次方);</li>
<li>low和height的更新要使用<code>height = middle-1</code>和<code>low = middle+1</code>。</li>
</ol>
<blockquote>
<p><code>&gt;&gt;</code> 右移，右边的数字指定了移动的位数，除法 。print(a &gt;&gt; 3)  # 相当于a 除 2的3次方<br><code>&lt;&lt;</code> 左移，左边的数字指定了移动的位数，乘法。print(a &lt;&lt; 3)  # 相当于a 乘 2的3次方</p>
</blockquote>
<p>局限性：</p>
<ol>
<li>只能查找有序的数据集；</li>
<li>针对的是静态有序数据集；</li>
<li>不适合数据量太大或太小的场景。太大的情况会消耗太多内存，太小的场景和遍历差别不大。</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python常用整理</title>
    <url>/Python%E5%B8%B8%E7%94%A8%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<h3 id="logging-日志模块写入中文编码错误解决方法"><a href="#logging-日志模块写入中文编码错误解决方法" class="headerlink" title="logging 日志模块写入中文编码错误解决方法"></a>logging 日志模块写入中文编码错误解决方法</h3><p>在logging.FileHandler(path) 中添加指定编码方式 encoding&#x3D;’utf-8’ 即可，logging.FileHandler(path, encoding&#x3D;’utf-8’) 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 18/8/16 10:40</span><br><span class="line"># @Author  : Medivh</span><br><span class="line"></span><br><span class="line">import functools</span><br><span class="line">import logging</span><br><span class="line">import logging.handlers</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">LOG_FILE = os.path.join(os.path.dirname(os.path.realpath(__file__)), &#x27;logs&#x27;, &#x27;logger.log&#x27;)</span><br><span class="line">handler = logging.handlers.RotatingFileHandler(LOG_FILE, maxBytes=1024 * 1024, backupCount=10, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">fmt = &#x27;[%(levelname)s]: %(asctime)s - %(filename)s - %(funcName)s - %(threadName)s - %(message)s&#x27;</span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(fmt)</span><br><span class="line">handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(&#x27;logger&#x27;)</span><br><span class="line">logger.addHandler(handler)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        logging.info(&#x27;call %s():&#x27; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python批量转换HTML为PDF</title>
    <url>/Python%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2HTML%E4%B8%BAPDF.html</url>
    <content><![CDATA[<h2 id="wkhtmltopdf"><a href="#wkhtmltopdf" class="headerlink" title="wkhtmltopdf"></a>wkhtmltopdf</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line tools to render HTML into PDF and various image formats using the Qt WebKit rendering engine. These run entirely “headless” and do not require a display or display service.  </p>
</blockquote>
<p>wkhtmltopdf 和 wkhtmltoimage是一个开元的命令行工具，用来转换html为pdf和各种图像格式。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载地址：<a href="https://wkhtmltopdf.org/downloads.html">https://wkhtmltopdf.org/downloads.html</a><br>mac的话可以直接安装了，其他系统就看着办吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install Caskroom/cask/wkhtmltopdf</span><br></pre></td></tr></table></figure>

<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li>Download a precompiled binary or build from source</li>
<li>Create your HTML document that you want to turn into a PDF (or image)</li>
<li>Run your HTML document through the tool.</li>
<li>For example, if I really like the treatment Google has done to their logo today and want to capture it forever as a PDF:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wkhtmltopdf http://google.com google.pdf</span><br></pre></td></tr></table></figure>
下载安装-》创建HTML文件-》命令行执行</li>
</ul>
<h2 id="Pdfkit"><a href="#Pdfkit" class="headerlink" title="Pdfkit"></a>Pdfkit</h2><p>A JavaScript PDF generation library for Node and the browser.</p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>PDFKit is a PDF document generation library for Node and the browser that makes creating complex, multi-page, printable documents easy. It’s written in CoffeeScript, but you can choose to use the API in plain ‘ol JavaScript if you like. The API embraces chainability, and includes both low level functions as well as abstractions for higher level functionality. The PDFKit API is designed to be simple, so generating complex documents is often as simple as a few function calls.</p>
</blockquote>
<p>pdfkit 是 wkhtmltopdf 的Python封装包。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install pdfkit</span><br><span class="line">or </span><br><span class="line">pip install pdfkit</span><br></pre></td></tr></table></figure>
<h3 id="支持模块"><a href="#支持模块" class="headerlink" title="支持模块"></a>支持模块</h3><img data-src="https://img.econow.cn/medivh/1545302451080.png" /> 

<p>支持以下方式：</p>
<ul>
<li>URL</li>
<li>文件</li>
<li>字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pdfkit.from_url(&#x27;https://www.google.com.hk&#x27;,&#x27;out1.pdf&#x27;)   </span><br><span class="line">pdfkit.from_file(&#x27;123.html&#x27;,&#x27;out2.pdf&#x27;)  </span><br><span class="line">pdfkit.from_string(&#x27;Hello!&#x27;,&#x27;out3.pdf&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 _*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author:medivh</span><br><span class="line">@file: html_to_pdf.py</span><br><span class="line">@time: 2018/12/20</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import pdfkit</span><br><span class="line">import os</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">src = &#x27;/Users/medivh/Downloads/tmp/new/&#x27;</span><br><span class="line">desc = &#x27;/Users/medivh/Downloads/tmp/new-pdf/&#x27;</span><br><span class="line"># read file path and destination path</span><br><span class="line">sem = threading.Semaphore(10)</span><br><span class="line">#控制线程数量</span><br><span class="line">try:</span><br><span class="line">    os.mkdir(desc)</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line">def ToPdf(filename):</span><br><span class="line">    with  sem:</span><br><span class="line">        try:</span><br><span class="line">            with open(src + filename, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">                pdf_name = desc + filename[:-6] + &#x27;.pdf&#x27;</span><br><span class="line">                #拼接文件名</span><br><span class="line">                pdfkit.from_file(f, pdf_name)</span><br><span class="line">        except:</span><br><span class="line">            print(filename)</span><br><span class="line"></span><br><span class="line">threads = list()</span><br><span class="line">for i in os.listdir(src):</span><br><span class="line">    t = threading.Thread(target=ToPdf, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.setDaemon(True)</span><br><span class="line">        t.start()</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()</span><br><span class="line">    start = len(os.listdir(src))</span><br><span class="line">    end = len(os.listdir(desc))</span><br><span class="line">    print(start,end)</span><br><span class="line">    if start == end:</span><br><span class="line">        print(&#x27;ok&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;no&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ul>
<li><code>&#39;ascii&#39; codec can&#39;t decode byte 0xb4 in position 11: ordinal not in range(128）</code><ul>
<li>解决：加上encoding,<code>with open(src + filename, encoding=&quot;utf-8&quot;)</code></li>
</ul>
</li>
<li>注意文件数量，否则数量太大而且没设置线程数的话机器会卡死<ul>
<li>解决：使用<code>threading.Semaphore(10)</code></li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://pdfkit.org/">http://pdfkit.org/</a><br><a href="https://wkhtmltopdf.org/index.html">https://wkhtmltopdf.org/index.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python知识点总结</title>
    <url>//Python%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93</url>
    <content><![CDATA[<h2 id="常见知识点"><a href="#常见知识点" class="headerlink" title="常见知识点"></a>常见知识点</h2><h3 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h3><p>自省，也叫反射，是运行时判断一个对象类型的能力。用来检查某些事务以确定它是什么、知道什么和它能做什么。相关的方法如下:</p>
<ul>
<li><p>hasattr(object,name)检查对象是否有name属性，Boolean</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hi</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line"><span class="built_in">hasattr</span>(Hi,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>getattr(object,name,default)获取对象的name属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hi</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line"><span class="built_in">getattr</span>(Hi,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>setattr(object,name,default) 给对象设置name属性</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;class A(object):</span><br><span class="line">...     bar = 1</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; a = A()</span><br><span class="line">&gt;&gt;&gt; getattr(a, <span class="string">&#x27;bar&#x27;</span>)          <span class="comment"># 获取属性 bar 值</span></span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; setattr(a, <span class="string">&#x27;bar&#x27;</span>, 5)       <span class="comment"># 设置属性 bar 值</span></span><br><span class="line">&gt;&gt;&gt; a.bar</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
</li>
<li><p>delattr(object，name)给对象删除name属性</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coordinate</span>:</span><br><span class="line">z = <span class="number">0</span></span><br><span class="line">point1 = Coordinate()  </span><br><span class="line"><span class="built_in">delattr</span>(Coordinate, <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;z = &#x27;</span>,point1.z)</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="string">&#x27;Coordinate&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;z&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dir([object]) 获取对象大部分的属性</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coordinate</span>:</span><br><span class="line">z = <span class="number">0</span></span><br><span class="line">point1 = Coordinate()  </span><br><span class="line"><span class="built_in">dir</span>(Coordinate)</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__delattr__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__dict__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__dir__&#x27;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;z&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>isinstance(name,object)检查name是不是object对象</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span> (a,<span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>type(object) 查看对象的类型  <code>&gt;&gt;&gt; type(1) &lt;type &#39;int&#39;&gt;</code></p>
</li>
<li><p>callable(object)判断对象是否是可调用对象</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(add)             <span class="comment"># 函数返回 True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="args和-kwargs"><a href="#args和-kwargs" class="headerlink" title="*args和**kwargs"></a>*args和**kwargs</h3><p>*args可以被打包成tuple，**kwargs被打包成dict。<br>*args示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_multiple_args</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(args), args)</span><br><span class="line"> </span><br><span class="line">print_multiple_args(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># 通过将列表前加*打包成关键字参数，指明了接收值参数必须是*args</span></span><br><span class="line">print_multiple_args(*[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt; (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt; (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>**kwargs示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_multiple_args</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(kwargs), kwargs)</span><br><span class="line"><span class="comment"># 给字典前加**打包成关键字参数,指明接收值的参数必须是**kwargs</span></span><br><span class="line">print_multiple_args(**&#123;<span class="string">&#x27;foo&#x27;</span>:<span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt; &#123;<span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;bar&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常代码示例"><a href="#异常代码示例" class="headerlink" title="异常代码示例"></a>异常代码示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># func   # 可能会抛出异常的代码</span></span><br><span class="line"><span class="keyword">except</span> (Exception1, Exception2) <span class="keyword">as</span> e:  <span class="comment"># 可以捕获多个异常并处理</span></span><br><span class="line">    <span class="comment"># 异常处理的代码</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># pass  # 异常没有发生的时候代码逻辑</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">pass</span>     <span class="comment"># 无论异常有没有发生都会执行的代码，一般处理资源的关闭和释放</span></span><br></pre></td></tr></table></figure>

<h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>GIL，解释器中一种线程同步的方式。</p>
<p>每个解释器都有一个GIL，直接作用是限制单个解释器进程中多线程的并行执行，使即使在多核处理器上对于单个解释器来说，同一时刻运行的线程仅限一个。同时造成的问题就是：在一个解释器进程中通过多线程的方式无法利用多核处理器来实现真正的并行。因此，Python的多线程是伪多线程，无法利用多核资源，同一时刻只能一个线程在真正的运行。</p>
<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><img data-src="https://img.econow.cn/medivh/1660724977831.png" alt="1660724977831.png"></p>
<p>迭代器是一种对象，该对象包含值的可计数数字，意味着可以遍历所有值。list、tuple、dict、set都是可迭代的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">myit = <span class="built_in">iter</span>(mytuple)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"></span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">cherry</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要把对象或类创建为迭代器，必须为对象实现__iter__()和__next__（）方法。</p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器，一遍循环一边计算的机制，不会像迭代器一样占用大量内存，只会在使用next()函数时才会生成下一个变量。</p>
<p>创建生成器：</p>
<ol>
<li>把列表的[]改为()</li>
<li>如果函数中包含yield关键字，那么调用函数时就会创建一个生成器对象</li>
</ol>
<p>工作原理：<strong>通过重复调用next()方法，直到捕获一个异常。</strong></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addx</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> adder</span><br><span class="line"> </span><br><span class="line">c = addx(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))</span><br><span class="line"><span class="built_in">print</span>(c.__name__)</span><br><span class="line"><span class="built_in">print</span>(c(<span class="number">10</span>))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line">adder</span><br></pre></td></tr></table></figure>

<h3 id="classmethod和staticmethod区别"><a href="#classmethod和staticmethod区别" class="headerlink" title="classmethod和staticmethod区别"></a>classmethod和staticmethod区别</h3><ul>
<li>都可以通过Class.method()的方式调用</li>
<li>classmethod第一个参数是cls，可以引用类变量</li>
<li>staticmethod使用起来和普通函数一样，只不过放在类里去组织，完全可以放在类之外</li>
<li>classmethod是为了使用类变量</li>
</ul>
<h3 id="new-和-init-的区别"><a href="#new-和-init-的区别" class="headerlink" title="__new__和__init__的区别"></a>__new__和__init__的区别</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h4><p>new方法是一个内置的静态方法，主要作用：</p>
<ol>
<li>在内存中为对象分配空间</li>
<li>返回对象的引用，将引用作为第一个参数传递给__init__方法</li>
</ol>
<blockquote>
<p>重写__new__方法的代码是固定的，只能  <code>return super().__new__(cls)</code> 。否则Python解释器到不到分配了空间的对象引用，就不会调用对象的初试方法</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 如果不返回任何结果，</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化音乐播放对象&quot;</span>)</span><br><span class="line"></span><br><span class="line">player = MusicPlayer()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player)</span><br><span class="line"></span><br><span class="line">初始化音乐播放对象</span><br><span class="line">&lt;__main__.MusicPlayer <span class="built_in">object</span> at <span class="number">0x1108d38e0</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>new方法是静态方法，init方法是实例方法</li>
<li>new方法会返回一个床的实例，init方法什么都不返回</li>
<li>只有在new方法返回一个cls的实例后面的init方法才能被调用</li>
</ul>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h4><p>call方法使类实例对象可以像调用普通函数那样，以”对象名()“的形式使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="comment"># 定义__call__方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,name,add</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用__call__()方法&quot;</span>,name,add)</span><br><span class="line"></span><br><span class="line">clangs = CLanguage()</span><br><span class="line">clangs(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"></span><br><span class="line">调用__call__()方法 foo bar</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>深拷贝 <code>deepcopy()</code>是将一个对象拷贝到另一个对象中，意味着如果对一个对象的拷贝做出改变时，不会影响原对象。其本质是对象的一次序列化和一次返回序列化。<br>可能遇到的问题：</p>
<ol>
<li>一个对象如果直接或简介引用了自身，会导致无休止的递归拷贝。解决，可以通过memo字典来保存已经拷贝过的对象。</li>
<li>深拷贝可能对原本设计为多个对象共享的数据也进行拷贝。解决，通过pickle函数来定制指定类型对象的拷贝行为。</li>
</ol>
<p>浅拷贝 <code>copy()</code> 是将一个对象的引用拷贝到另一个对象上，如果在拷贝中改动，则会影响到原对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy </span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">a.append(<span class="number">6</span>)</span><br><span class="line">c = copy.copy(a)</span><br><span class="line"><span class="built_in">print</span>(a,b,c)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>为了确保某一个类只有一个实例存在。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p><strong>模块</strong>，Python模块是天然的单例模式。当模块在第一次导入时会生成<code>.pyc</code>文件，当第二次导入时就会直接加载<code>.pyc</code>文件。因此只需要把相关函数和数据定义在一个模块中，就可以获得一个单例对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Class Mysingleton:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">singleton_obj=Mysingleton()</span><br><span class="line"><span class="comment"># 保存文件，需要使用时直接在其他文件导入次文件中的对象即可。</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> singleton_obj</span><br></pre></td></tr></table></figure>

<p><strong>new方法</strong>，实例化一个对象时，都是先执行类的new方法，实例化对象，然后再执行init方法，对这个对象初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>():</span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,*args,**kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;new一个对象&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> cls.instance == <span class="literal">None</span>:</span><br><span class="line">            cls.instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">            <span class="keyword">return</span> cls.instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cls.instance</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;初始化对象&#x27;</span>)</span><br><span class="line">c1 = Test()</span><br><span class="line">c2 = Test()</span><br><span class="line">c3 = Test()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line"><span class="built_in">print</span>(c3)</span><br><span class="line"></span><br><span class="line">new一个对象</span><br><span class="line">初始化对象</span><br><span class="line">new一个对象</span><br><span class="line">初始化对象</span><br><span class="line">new一个对象</span><br><span class="line">初始化对象</span><br><span class="line">&lt;__main__.Test <span class="built_in">object</span> at <span class="number">0x110ad12e0</span>&gt;</span><br><span class="line">&lt;__main__.Test <span class="built_in">object</span> at <span class="number">0x110ad12e0</span>&gt;</span><br><span class="line">&lt;__main__.Test <span class="built_in">object</span> at <span class="number">0x110ad12e0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>结果可知实例化三个对象内存地址都是一样的，说明都是同一个对象。</p>
<p><strong>装饰器</strong>，任何一个类使用了该装饰器就会变成一个单例模式的类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">single_class</span>(<span class="params">cls</span>):</span><br><span class="line">    instance = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">single</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instance:</span><br><span class="line">            instance[cls] = cls(*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> instance[cls]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> instance[cls]</span><br><span class="line">    <span class="keyword">return</span> single</span><br><span class="line"></span><br><span class="line"><span class="meta">@single_class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c1 = Test()</span><br><span class="line">c2 = Test()</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line">    </span><br><span class="line">&lt;__main__.Test <span class="built_in">object</span> at <span class="number">0x1109172b0</span>&gt;</span><br><span class="line">&lt;__main__.Test <span class="built_in">object</span> at <span class="number">0x1109172b0</span>&gt;</span><br><span class="line">​        </span><br></pre></td></tr></table></figure>

<p>装饰器将所有的对象都存储到字典里，如果之前创建过的对象就直接返回，否则就new一个。</p>
<p>单例模式的优点：</p>
<ol>
<li>节约内存，实例化N个对象都实际指向同一个内存地址</li>
<li>多个地方创建的实例可以属性直接使用</li>
</ol>
<h3 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h3><ul>
<li>CPython，从官网下载下的就是C语言开发的Python，所以叫CPython，使用最广</li>
<li>IPython，是基于CPython之上的一个交互式解释器</li>
<li>PyPy，采用JIT技术，对Python代码动态编译，但和CPython执行结果可能不同</li>
<li>Jython，运行在Java平台上的Python解释器</li>
<li>IronPython，运行在.net平台的Python</li>
</ul>
<h3 id="Python是如何实现内存管理的"><a href="#Python是如何实现内存管理的" class="headerlink" title="Python是如何实现内存管理的"></a>Python是如何实现内存管理的</h3><p>Python提供了自动化的内存管理，也就是说内存空间的分配与释放都是由Python解释器运行时自动进行的。内存管理有三个关键点：</p>
<ol>
<li>引用计数</li>
<li>标记清理</li>
<li>分代收集</li>
</ol>
<p>引用计数，每个对象其实就是PyObject结构体，内部有一个ob——refcnt的引用计数器成员变量。程序在执行过程中，该变量会随之更新并反应引用有多少个变量引用到该对象。当该对象引用计数值为0时，它的内存就会被释放掉。</p>
<p>以下情况会导致引用计数加1：</p>
<ol>
<li>对象被创建</li>
<li>对象被引用</li>
<li>对象作为参数传入到一个函数中</li>
<li>对象作为元素存储到一个容器中</li>
</ol>
<p>以下情况会导致引用计数减1：</p>
<ol>
<li>使用del</li>
<li>对象引用被重新赋值其他对象</li>
<li>一个对象离开它所在的作用域</li>
<li>持有该对象的容器自身被销毁</li>
<li>持有该对象的容器删除该对象</li>
</ol>
<h3 id="lambda-函数的使用"><a href="#lambda-函数的使用" class="headerlink" title="lambda 函数的使用"></a>lambda 函数的使用</h3><p>功能是利用一行代码实现的小型函数。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">lambda</span> a : a + <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>语法：<code>lambda arguments : expression</code></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ 集群部署</title>
    <url>/RabbitMQ%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install erlang -y</span><br></pre></td></tr></table></figure>
<h3 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src/</span><br><span class="line">wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.4/rabbitmq-server-3.6.4-1.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum install rabbitmq-server-3.6.4-1.noarch.rpm -y</span><br></pre></td></tr></table></figure>

<h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动服务</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">#查看服务状态</span><br><span class="line">service rabbitmq-server status</span><br></pre></td></tr></table></figure>

<h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><h3 id="增加账号"><a href="#增加账号" class="headerlink" title="增加账号"></a>增加账号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#增加</span><br><span class="line">rabbitmqctl  add_user  admin  &#x27;admin&#x27;</span><br><span class="line">#角色分配</span><br><span class="line">rabbitmqctl  set_user_tags admin administrator</span><br></pre></td></tr></table></figure>
<h3 id="vhost"><a href="#vhost" class="headerlink" title="vhost"></a>vhost</h3><p>运行多个vhost，以便于适用不同的业务需要，这样做既可以满足权限配置的要求，避免不同业务之间队列、交换机的命名冲突问题，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#vhost </span><br><span class="line">rabbitmqctl add_vhost personas</span><br><span class="line">rabbitmqctl set_permissions -p personas joy &#x27;.*&#x27; &#x27;.*&#x27; &#x27;.*&#x27;</span><br></pre></td></tr></table></figure>


<h3 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>RabbitMQ 的 Cluster 集群模式一般分为两种，普通模式和镜像模式。</p>
<p>普通模式：默认的集群模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于 Queue 来说，消息实体只存在于其中一个节点 rabbit01（或者 rabbit02），rabbit01 和 rabbit02 两个节点仅有相同的元数据，即队列的结构。当消息进入 rabbit01 节点的 Queue 后，consumer 从 rabbit02 节点消费时，RabbitMQ 会临时在 rabbit01、rabbit02 间进行消息传输，把 A 中的消息实体取出并经过 B 发送给 consumer。所以 consumer 应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 Queue。否则无论 consumer 连 rabbit01 或 rabbit02，出口总在 rabbit01，会产生瓶颈。当 rabbit01 节点故障后，rabbit02 节点无法取到 rabbit01 节点中还未消费的消息实体。如果做了消息持久化，那么得等 rabbit01 节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。<br>镜像模式：将需要消费的队列变为镜像队列，存在于多个节点，这样就可以实现 RabbitMQ 的 HA 高可用性。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在 consumer 消费数据时临时读取。缺点就是，集群内部的同步通讯会占用大量的网络带宽。</p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li>RAM node：内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速。</li>
<li>Disk node：将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启 RabbitMQ 的时候，丢失系统的配置信息。<blockquote>
<p>RabbitMQ 要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作（增删改查），直到节点恢复。<br>解决方案：设置两个磁盘节点，至少有一个是可用的，可以保存元数据的更改。</p>
</blockquote>
</li>
</ul>
<h3 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h3><p>通过Erlang Cookie，相当于共享秘钥的概念，长度任意，只要所有节点都一致即可。rabbitmq server在启动的时候，erlang VM会自动创建一个随机的cookie文件。cookie文件的位置： &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie 或者&#x2F;root&#x2F;.erlang.cookie。我们的为保证cookie的完全一致，采用从一个节点copy的方式，实现各个节点的cookie文件一致。</p>
<p>注意该文件默认是400权限，修改后需要还原回去400。</p>
<h3 id="集群组建"><a href="#集群组建" class="headerlink" title="集群组建"></a>集群组建</h3><p>首先保证所有节点都可以正常启动服务。</p>
<h4 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h4><p>在所有节点执行以下操作，停止服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service rabbitmq-server stop</span><br></pre></td></tr></table></figure>
<h4 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h4><p>1、所有节点执行以下操作，启动集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-detached<br>Start the server process in the background. Note that this will cause the pid not to be written to the pid file.</p>
</blockquote>
<blockquote>
<p>For example, runs RabbitMQ AMQP server in the background:<br>rabbitmq-server -detached</p>
</blockquote>
<p>该参数简单说就是后台启动，始终没理解和<code>service rabbitmq-server sart</code>的区别</p>
<p>2、修改统一hosts文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.1.233 r0</span><br><span class="line">192.168.1.234 r1</span><br><span class="line">192.168.1.232 r2</span><br><span class="line">192.168.1.229 r3</span><br></pre></td></tr></table></figure>

<p>3、同步.erlang.cookie文件<br>所有节点从r0机器分发 <code>/var/lib/rabbitmq/.erlang.cookie </code>。</p>
<p>4、在其他节点服务器操作加入集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//默认是磁盘节点，如果是内存节点的话，需要加--ram参数</span><br><span class="line"></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@r0</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl join_cluster rabbit@r0</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h4><p>1、节点加入集群，此处使用的主机名意义和hosts中一个意义。<br><img data-src="https://img.econow.cn/medivh/1553065925609.png" /></p>
<p>2、加入集群后，检查集群状态<br><img data-src="https://img.econow.cn/medivh/1553065954361.png" /></p>
<img data-src="https://img.econow.cn/medivh/1553069420891.png" />

<h4 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h4><ul>
<li><p>之前加入集群的时候总提示错误<code>rror: unable to connect to node rabbit@test_229: nodedown</code></p>
<img data-src="https://img.econow.cn/medivh/1553066819130.png" />
原因：在集群的所有机器都需要先执行`rabbitmq-server -detached`
</li>
<li><p>unable to connect to epmd (port 4369) on base_233: nxdomain (non-existing domain)</p>
</li>
</ul>
<p>原因：未启用管理插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<h4 id="集群节点操作"><a href="#集群节点操作" class="headerlink" title="集群节点操作"></a>集群节点操作</h4><p>节点恢复过程中把数据删掉很重要，恢复一单结点，再清数据<br>节点增加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. rabbitmq-server -detached   --- .erlang.cooike的权限，400 属主rabbitmq</span><br><span class="line">2. rabbitmqctl stop_app</span><br><span class="line">3. rabbitmqctl join_cluster --ram rabbit@rabbitmq1</span><br><span class="line">4. rabbitmqctl start_app</span><br><span class="line">5. rabbitmqctl  cluster_status</span><br></pre></td></tr></table></figure>
<p>节点删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  rabbitmq-server -detached</span><br><span class="line">以上为基础，正常运行的mq节点直接进行2、3两步；4可省略或更改为rabbitmqctl stop</span><br><span class="line">2. rabbitmqctl stop_app</span><br><span class="line">3. rabbitmqctl reset </span><br><span class="line">4. rabbitmqctl start_app</span><br></pre></td></tr></table></figure>
<p>硬删除：<br>直接删掉集群中的某个节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl forget_cluster_node   node_name</span><br></pre></td></tr></table></figure>
<p>由disc–&gt;ram</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.节点删除     rabbitmq-server -detached ---rabbitctl stop_app----    rabbitmqctl reset  （（--2.清除原数据（暂时备份到其他地方）--rabbitmqctl join_cluster --ram rabbit@rabbitmq1 ------------    rabbitmqctl start_app））</span><br><span class="line">2.清除原数据（暂时备份到其他地方）</span><br><span class="line">3.节点增加</span><br></pre></td></tr></table></figure>
<p>由disc–&gt;ram<br>先恢复到单结点，重启，清数据<br>加集群 </p>
<h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><p>1、在管理界面配置<br><img data-src="https://img.econow.cn/medivh/1553134452790.png" /></p>
<ul>
<li><p>Virtual host： 可选参数，针对指定vhost下的queue进行设置</p>
</li>
<li><p>Name: policy的名称</p>
</li>
<li><p>Pattern: queue的匹配模式(正则表达式)</p>
</li>
<li><p>Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</p>
<ul>
<li>ha-mode:指明镜像队列的模式，有效值为 all&#x2F;exactly&#x2F;nodes<ul>
<li>all：表示在集群中所有的节点上进行镜像</li>
<li>exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</li>
<li>nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</li>
</ul>
</li>
<li>ha-params：ha-mode模式需要用到的参数</li>
<li>ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</li>
</ul>
</li>
<li><p>priority：可选参数，policy的优先级</p>
</li>
</ul>
<p>2、任意节点命令行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">// 命令行方式添加策略</span><br><span class="line">// 策略名称为ha-allqueue,策略模式为 all 即复制到所有节点，包含新增节点，策略正则表达式为 “^” 表示所有匹配所有队列名称。</span><br><span class="line">rabbitmqctl set_policy -p &lt;vhost&gt; ha-allqueue&quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时候就变成多个节点了。<br><img data-src="https://img.econow.cn/medivh/1553135352884.png" /></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>AProxy 是一个免费的负载均衡软件，可以运行于大部分主流的 Linux 操作系统上。</p>
<p>HAProxy 提供了 L4(TCP) 和 L7(HTTP) 两种负载均衡能力，具备丰富的功能。HAProxy 的社区非常活跃，版本更新快速（最新稳定版 1.7.2 于 2017&#x2F;01&#x2F;13 推出）。最关键的是，HAProxy 具备媲美商用负载均衡器的性能和稳定性。它当前不仅仅是免费负载均衡软件的首选，更几乎成为了唯一选择。</p>
<p>因为 RabbitMQ 本身不提供负载均衡，下面我们就搭建 HAProxy，用作 RabbitMQ 集群的负载均衡。    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install haproxy</span><br><span class="line">cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak</span><br><span class="line">vim /etc/haproxy/haproxy.cfg</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>haproxy配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    log     127.0.0.1  local0 info</span><br><span class="line">    log     127.0.0.1  local1 notice</span><br><span class="line">    daemon</span><br><span class="line">    maxconn 4096</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log     global</span><br><span class="line">    mode    tcp</span><br><span class="line">    option  tcplog</span><br><span class="line">    option  dontlognull</span><br><span class="line">    retries 3</span><br><span class="line">    option  abortonclose</span><br><span class="line">    maxconn 4096</span><br><span class="line">    timeout connect  5000ms</span><br><span class="line">    timeout client  3000ms</span><br><span class="line">    timeout server  3000ms</span><br><span class="line">    balance roundrobin</span><br><span class="line"></span><br><span class="line">listen private_monitoring</span><br><span class="line">    bind    0.0.0.0:8100</span><br><span class="line">    mode    http</span><br><span class="line">    option  httplog</span><br><span class="line">    stats   refresh  5s</span><br><span class="line">    stats   uri  /stats</span><br><span class="line">    stats   realm   Haproxy</span><br><span class="line">    stats   auth  admin:admin</span><br><span class="line"></span><br><span class="line">listen rabbitmq_admin</span><br><span class="line">    bind    0.0.0.0:8102</span><br><span class="line">    server  r0 r0:15672</span><br><span class="line">    server  r3 r3:15672</span><br><span class="line"></span><br><span class="line">listen rabbitmq_cluster</span><br><span class="line">    bind    0.0.0.0:8101</span><br><span class="line">    mode    tcp</span><br><span class="line">    option  tcplog</span><br><span class="line">    balance roundrobin</span><br><span class="line">    timeout client  3h</span><br><span class="line">    timeout server  3h</span><br><span class="line">    server  r0  r0:5672  check  inter  5000  rise  2  fall  3</span><br><span class="line">    server  r3  r3:5672  check  inter  5000  rise  2  fall  3</span><br></pre></td></tr></table></figure>

<p>启动 haproxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">haproxy -f /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure>
<p>HAProxy 配置了三个地址：</p>
<ul>
<li><a href="http://r0:8100/stats%EF%BC%9AHAProxy">http://r0:8100/stats：HAProxy</a> 负载均衡信息地址，账号密码：admin&#x2F;admin。</li>
<li><a href="http://r0:8101：RabbitMQ">http://r0:8101：RabbitMQ</a> Server Web 管理界面（基于负载均衡）。</li>
<li><a href="http://r0:8102：RabbitMQ">http://r0:8102：RabbitMQ</a> Server 服务地址（基于负载均衡）。<br>通过访问<a href="http://r0:8100/stats%EF%BC%8C%E6%9F%A5%E7%9C%8B">http://r0:8100/stats，查看</a> HAProxy 负载均衡信息：</li>
</ul>
<p>实际程序访问的端口为8101</p>
<p>这样，haproxy就可以使用啦。<br><img data-src="https://img.econow.cn/medivh/1553075635396.png" /></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群技术演变</title>
    <url>/Redis%E9%9B%86%E7%BE%A4%E6%8A%80%E6%9C%AF%E6%BC%94%E5%8F%98.html</url>
    <content><![CDATA[<p>按照需求来分，将实例区分为单机和集群两种类型。</p>
<ul>
<li>单机适合容量和性能要求不高的小型存储</li>
<li>集群应对性能和容量要求较高的场景</li>
</ul>
<h2 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h2><h3 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command FLUSHDB  &quot;&quot;</span><br><span class="line">rename-command CONFIG   &quot;&quot;</span><br><span class="line">rename-command KEYS     &quot;&quot;</span><br><span class="line">rename-command SHUTDOWN &quot;&quot;</span><br><span class="line">rename-command DEL &quot;&quot;</span><br><span class="line">rename-command EVAL &quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是注意是否和以下故障切换是否冲突“config”</p>
<h3 id="原生主从（master-slave"><a href="#原生主从（master-slave" class="headerlink" title="原生主从（master-slave)"></a>原生主从（master-slave)</h3><p>实现高可用，暴露master节点。支持Redis所有指令。<br>使用Redis 自带的哨兵（Sentinel）集群对实例进行状态监控与 Failover。Sentinel 是 Redis 自带的高可用组件，将 Redis 注册到由多个 Sentinel 组成的 Sentinel 集群后，Sentinel 会对 Redis 实例进行健康检查，当 Redis 发生故障后，Sentinel 会通过 Gossip 协议进行故障检测，确认宕机后会通过一个简化的 Raft 协议来提升 Slave 成为新的 Master。</p>
<img data-src="https://img.econow.cn/medivh/1562750986206.png"  />

<p>通常情况仅使用1 个 Slave 节点进行冷备，如果有读写分离请求，可以建立多个Read only slave 来进行读写分离。</p>
<ul>
<li>只读Slave 节点可以按照需求设置 slave-priority 参数为0，防止故障切换时选择了只读节点而不是热备 Slave 节点；</li>
<li>Sentinel 进行故障切换后会执行 CONFIG REWRITE 命令将SLAVEOF 配置落地，如果 Redis 配置中禁用了 CONFIG 命令，切换时会发生错误，可以通过修改 Sentinel 代码来替换 CONFIG 命令；</li>
<li>Sentinel Group 监控的节点不宜过多，实测超过 500 个切换过程偶尔会进入 TILT 模式，导致Sentinel 工作不正常，推荐部署多个 Sentinel 集群并保证每个集群监控的实例数量小于 300 个；</li>
<li>Master 节点应与 Slave 节点跨机器部署，有能力的使用方可以跨机架部署，不推荐跨机房部署 Redis 主从实例；</li>
<li>Sentinel 切换功能主要依赖 down-after-milliseconds 和failover-timeout 两个参数，down-after-milliseconds 决定了Sentinel 判断 Redis 节点宕机的超时，知乎使用 30000 作为阈值。而 failover-timeout 则决定了两次切换之间的最短等待时间，如果对于切换成功率要求较高，可以适当缩短failover-timeout 到秒级保证切换成功，具体详见Redis 官方文档[2]；</li>
<li>单机网络故障等同于机器宕机，但如果机房全网发生大规模故障会造成主从多次切换，此时资源发现服务可能更新不够及时，需要人工介入。</li>
</ul>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>优点：</p>
<ul>
<li>基于主从模式，所有主从的优点，sentinel都有</li>
<li>主从可以切换，故障可以转移，系统可用性好</li>
<li>是主从模式的升级，系统更健壮，可用性更高</li>
</ul>
<p>缺点：</p>
<ul>
<li>较难支持在线扩容</li>
<li>在集群容量达到上限时只能升级机器内存，而不能实现水平扩容</li>
</ul>
<p>主从同步可能会遇到的问题：</p>
<ul>
<li>端口不通</li>
<li>认证失败</li>
</ul>
<table>
<thead>
<tr>
<th>角色</th>
<th>IP</th>
<th>端口</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>Master,Sentinel1</td>
<td>192.168.1.233</td>
<td>6379,26379</td>
<td></td>
</tr>
<tr>
<td>slave01,Sentinel2</td>
<td>192.168.1.234</td>
<td>6379,26379</td>
<td></td>
</tr>
<tr>
<td>slave02,Sentinel3</td>
<td>192.168.1.235</td>
<td>6379,26379</td>
<td></td>
</tr>
</tbody></table>
<h4 id="配置redis文件"><a href="#配置redis文件" class="headerlink" title="配置redis文件"></a>配置redis文件</h4><ul>
<li>在3台服务器上分别安装Redis。需要注意的是，如果要给Redis设置密码，需要在3个Redis的配置文件中设置相同的密码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#master</span><br><span class="line">requirepass &quot;Redis-Password&quot;</span><br><span class="line">#slave </span><br><span class="line">masterauth  &quot;Redis-Password&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>在2个SlaveRedis的配置文件中声明所从属的主数据库。<code>slaveof 192.168.1.233 6379</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize                   yes    </span><br><span class="line">pidfile                     /var/run/redis.pid</span><br><span class="line">port                        6379     </span><br><span class="line">bind                        192.168.1.233</span><br><span class="line">timeout                     120     </span><br><span class="line">tcp-keepalive               60     </span><br><span class="line">loglevel                    notice  </span><br><span class="line">logfile                     /var/log/redis/redis.log</span><br><span class="line">syslog-enabled              no</span><br><span class="line">databases                   16     </span><br><span class="line">stop-writes-on-bgsave-error no</span><br><span class="line">rdbcompression              yes</span><br><span class="line">rdbchecksum                 yes</span><br><span class="line">dbfilename                  dump.rdb</span><br><span class="line">dir                         /var/lib/redis</span><br><span class="line">save                        7200    100000</span><br><span class="line">maxclients                  10000    </span><br><span class="line">maxmemory                   1GB</span><br><span class="line">maxmemory-policy            volatile-lru</span><br><span class="line">maxmemory-samples           5</span><br><span class="line">appendonly                  no</span><br><span class="line">appendfilename              appendonly.aof    </span><br><span class="line">hash-max-ziplist-entries    512     </span><br><span class="line">hash-max-ziplist-value      64</span><br><span class="line">list-max-ziplist-entries    512</span><br><span class="line">list-max-ziplist-value      64</span><br><span class="line">set-max-intset-entries      512</span><br><span class="line">zset-max-ziplist-entries    128</span><br><span class="line">zset-max-ziplist-value      64</span><br><span class="line">activerehashing             yes     </span><br><span class="line">client-output-buffer-limit  normal                      0      0     0</span><br><span class="line">client-output-buffer-limit  slave                       256mb  64mb  60</span><br><span class="line">client-output-buffer-limit  pubsub                      256mb  64b   120</span><br><span class="line">hz                          10</span><br><span class="line">requirepass                 &quot;alkq2caiAmq82s&quot;</span><br><span class="line">masterauth                  &quot;alkq2caiAmq82s&quot;</span><br><span class="line">rename-command              flushall   &quot;&quot;</span><br><span class="line">rename-command              flushdb    &quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三台机器启动后检查主从状态，数量和状态对的上就没啥问题了。<br><img data-src="https://img.econow.cn/medivh/1562755390514.png"  /><br><img data-src="https://img.econow.cn/medivh/1562755494148.png"  /></p>
<h4 id="配置sentinel"><a href="#配置sentinel" class="headerlink" title="配置sentinel"></a>配置sentinel</h4><p>注意加上认证部分。<br>配置项解释：</p>
<ul>
<li><code>sentinel monitor mymaster 192.168.1.233 6379 2</code>给master取名叫mymaster，2代表集群中有两个sentinel认为master死了的时候，才能真正认为master死了。sentinel集群中通过gossip协互相通信。</li>
<li><code>down-after-milliseconds</code> sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了(subjectively down, 也简称为SDOWN)。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。</li>
<li><code>parallel-syncs</code>不过需要注意的是，这个时候sentinel并不会马上进行failover主备切换，这个sentinel还需要参考sentinel集群中其他sentinel的意见，如果超过某个数量的sentinel也主观地认为该master死了，那么这个master就会被客观地(注意哦，这次不是主观，是客观，与刚才的subjectively down相对，这次是objectively down，简称为ODOWN)认为已经死了。需要一起做出决定的sentinel数量在上一条配置中进行配置。</li>
<li>在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave处于不能处理命令请求的状态。</li>
</ul>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">bind 192.168.1.233</span><br><span class="line">logfile &quot;/var/log/redis/sentinel.log&quot;</span><br><span class="line">dir &quot;/var/lib/redis&quot;</span><br><span class="line">sentinel monitor mymaster 192.168.1.233 6379 2</span><br><span class="line">sentinel auth-pass mymaster alkq2caiAmq82s</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">bind 192.168.1.234</span><br><span class="line">logfile &quot;/var/log/redis/sentinel.log&quot;</span><br><span class="line">dir &quot;/var/lib/redis&quot;</span><br><span class="line">sentinel monitor mymaster 192.168.1.233 6379 2</span><br><span class="line">sentinel auth-pass mymaster alkq2caiAmq82s</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">bind 192.168.1.235</span><br><span class="line">logfile &quot;/var/log/redis/sentinel.log&quot;</span><br><span class="line">dir &quot;/var/lib/redis&quot;</span><br><span class="line">sentinel monitor mymaster 192.168.1.233 6379 2</span><br><span class="line">sentinel auth-pass mymaster alkq2caiAmq82s</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>然后依次启动，之后检查状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-sentinel sentinel.conf</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">redis-server sentinel.conf --sentinel</span><br><span class="line"></span><br><span class="line">[root@base_233 ~]# redis-cli -h 192.168.1.233 -p 26379</span><br><span class="line">192.168.1.233:26379&gt; info Sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=mymaster,status=ok,address=192.168.1.233:6379,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure>
<h5 id="检查配置文件的变化"><a href="#检查配置文件的变化" class="headerlink" title="检查配置文件的变化"></a>检查配置文件的变化</h5><img data-src="https://img.econow.cn/medivh/1562756643624.png"  />
<img data-src="https://img.econow.cn/medivh/1562756689621.png"  />

<p>发现slave机器上会自动增加其他两个节点的信息。</p>
<p>启动日志<br><img data-src="https://img.econow.cn/medivh/1562756729219.png"  /></p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><ul>
<li>PING ：返回 PONG 。</li>
<li>SENTINEL masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。</li>
<li>SENTINEL slaves <master name> ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。</li>
<li>SENTINEL get-master-addr-by-name <master name> ： 返回给定名字的主服务器的 IP 地址和端口号。 如果这个主服务器正在执行故障转移操作， 或者针对这个主服务器的故障转移操作已经完成， 那么这个命令返回新的主服务器的 IP 地址和端口号。</li>
<li>SENTINEL reset <pattern> ： 重置所有名字和给定模式 pattern 相匹配的主服务器。 pattern 参数是一个 Glob 风格的模式。 重置操作清楚主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel 。</li>
<li>SENTINEL failover <master name> ： 当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移 （不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。</li>
</ul>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>一次故障转移操作由以下步骤组成：</p>
<ul>
<li>发现主服务器已经进入客观下线状态。</li>
<li>对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选。</li>
<li>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤。</li>
<li>选出一个从服务器，并将它升级为主服务器。</li>
<li>向被选中的从服务器发送 SLAVEOF NO ONE 命令，让它转变为主服务器。</li>
<li>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。</li>
<li>向已下线主服务器的从服务器发送 SLAVEOF 命令， 让它们去复制新的主服务器。</li>
<li>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。</li>
</ul>
<blockquote>
<p>每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。</p>
</blockquote>
<p>日志说明：</p>
<ul>
<li>+sdown 表示哨兵主观认为数据库下线</li>
<li>+odown 表示哨兵客观认为数据库下线</li>
<li>+try-failover 表示哨兵开始进行故障恢复</li>
<li>+failover-end 表示哨兵完成故障修复，其中包括了领头哨兵的选举、备选从数据库的选择等等较为复杂的过程</li>
<li>+switch-master表示主数据库从51服务器迁移到52服务器</li>
<li>+slave列出了新的主数据库的2个从数据库，而哨兵并没有彻底清除51服务器的实力信息，这是因为停止的实例有可能会在将来恢复，哨兵会让其重新加入进来</li>
</ul>
<p>故障转移过程：</p>
<ul>
<li>观察slave节点日志：master故障了<img data-src="https://img.econow.cn/medivh/1562816515954.png"  />
  * 发现master故障，
  * 选举出来233为master
  * 切换master
  * 更新sentinel配置文件
  * 将原来的master切换为slave，并且定义为down</li>
<li>观察sentinel配置文件，master已经切换为新的地址<img data-src="https://img.econow.cn/medivh/1562837169421.png"  /></li>
</ul>
<p>之前一直不成功主要的原因就是配置了<code>rename-command &quot;RENAMECONFIG&quot;</code>,导致失败的，这个要多注意一下。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>slave不能写<img data-src="https://img.econow.cn/medivh/1562837656576.png"  /></li>
</ul>
<h4 id="访问sentinel集群"><a href="#访问sentinel集群" class="headerlink" title="访问sentinel集群"></a>访问sentinel集群</h4><p>以Python为例，程序通过sentinel提供的端口进行访问，获取master地址进行写操作，读操作默认是轮询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 2.6.6 (r266:84292, Jan 22 2014, 09:42:36) </span><br><span class="line">[GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; from redis.sentinel import Sentinel #加载redis模块</span><br><span class="line">&gt;&gt;&gt; sentinel = Sentinel([(&#x27;192.168.221.160&#x27;, 26379),</span><br><span class="line">...                      (&#x27;192.168.221.161&#x27;, 26379)],</span><br><span class="line">...                     socket_timeout=0.1) #连接哨兵服务器</span><br><span class="line">&gt;&gt;&gt; sentinel.discover_master(&#x27;mymaster&#x27;) #获取主redis服务器地址</span><br><span class="line">(&#x27;192.168.221.161&#x27;, 6379)</span><br><span class="line">&gt;&gt;&gt; sentinel.discover_slaves(&#x27;mymaster&#x27;)#获取从redis服务区地址</span><br><span class="line">[(&#x27;192.168.221.160&#x27;, 6379)]</span><br><span class="line">&gt;&gt;&gt; master = sentinel.master_for(&#x27;mymaster&#x27;, socket_timeout=0.1) </span><br><span class="line">&gt;&gt;&gt; master.set(&#x27;foo&#x27;,&#x27;bar&#x27;) #获取主redis服务器并进行写入</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; slave = sentinel.slave_for(&#x27;mymaster&#x27;, socket_timeout=0.1)</span><br><span class="line">&gt;&gt;&gt; slave.get(&#x27;foo&#x27;)#获取从redis服务器进行获取</span><br><span class="line">&#x27;bar&#x27;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群(Cluster)"></a>集群(Cluster)</h2><p>cluster的出现是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。对cluster的一些理解：</p>
<ul>
<li>cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。</li>
<li>因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。这种模式适合数据量巨大的缓存要求，当数据量不是很大使用sentinel即可。</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis集群是一个可以在多个Redis节点之间进行数据共享的设施。</p>
<p>Redis集群不支持需要同时处理多个键的命令，因为在执行这些命令的时候需要在多个Redis节点之间移动数据，会降低集群性能。<br>Redis集群通过分区来提供一定程度的可用性：即使集群中有一部分节点失效，集群也可以继续处理命令请求。</p>
<p>优点：</p>
<ul>
<li>将数据自动切分到多个节点的能力</li>
<li>当部分节点失效的时候，集群仍然可以继续处理命令请求</li>
</ul>
<h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p>一个集群包含16384个哈希槽，数据库中的每个键都属于这16384个哈希槽的其中一个。<br>每个节点负责处理一部分哈希槽，比如一个集群有三个节点，就均分为3大块哈希槽。</p>
<p>这种哈希槽的处理方式使用处更容易或者更快的添加删除节点。比如</p>
<ul>
<li>增加节点。ABC只需要将部分哈希槽移动到新的D就可以了</li>
<li>删除节点，ABCD只需要将要删除的D节点的哈希槽移动到ABC就可以了</li>
</ul>
<h3 id="集群中的主从复制"><a href="#集群中的主从复制" class="headerlink" title="集群中的主从复制"></a>集群中的主从复制</h3><p>集群中的主从复制功能：集群中的每个节点都有N个复制品，其中一个复制品为主节点，其余的为从节点。<br>比如之前的B节点下线了，那么集群中会丢失部分哈希槽。但是如果创建集群的时候为B节点添加了从节点B1，那么在B下线的时候，B1就会为新的主节点，取代处理之前对应的哈希槽。这样集群就会正常运作了。</p>
<h3 id="集群一致性保证"><a href="#集群一致性保证" class="headerlink" title="集群一致性保证"></a>集群一致性保证</h3><p>集群不保证数据的强一致性，在特定条件下，集群可能会丢失已经被执行过的写命令。</p>
<p>使用异步复制是丢失写命令的一个原因，示例如下：</p>
<ul>
<li>客户端向主节点B发送写的命令</li>
<li>主节点B执行写命令，并向客户端放回命令回复</li>
<li>主机点B</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>创建三个目录，然后依次修改端口，之后发送到其他节点机器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize                   yes    </span><br><span class="line">pidfile                     /var/run/redis7000.pid</span><br><span class="line">port                        6379     </span><br><span class="line">bind                        192.168.1.233</span><br><span class="line">timeout                     120     </span><br><span class="line">tcp-keepalive               60     </span><br><span class="line">loglevel                    notice  </span><br><span class="line">logfile                     /var/log/redis/redis7000.log</span><br><span class="line">syslog-enabled              no</span><br><span class="line">databases                   16     </span><br><span class="line">stop-writes-on-bgsave-error no</span><br><span class="line">rdbcompression              yes</span><br><span class="line">rdbchecksum                 yes</span><br><span class="line">dbfilename                  dump.rdb</span><br><span class="line">dir                         /usr/local/redis_cluster/7000</span><br><span class="line">save                        7200    100000</span><br><span class="line">maxclients                  10000    </span><br><span class="line">maxmemory                   1GB</span><br><span class="line">maxmemory-policy            volatile-lru</span><br><span class="line">maxmemory-samples           5</span><br><span class="line">appendonly                  no</span><br><span class="line">appendfilename              appendonly.aof    </span><br><span class="line">hash-max-ziplist-entries    512     </span><br><span class="line">hash-max-ziplist-value      64</span><br><span class="line">list-max-ziplist-entries    512</span><br><span class="line">list-max-ziplist-value      64</span><br><span class="line">set-max-intset-entries      512</span><br><span class="line">zset-max-ziplist-entries    128</span><br><span class="line">zset-max-ziplist-value      64</span><br><span class="line">activerehashing             yes     </span><br><span class="line">client-output-buffer-limit  normal                      0      0     0</span><br><span class="line">client-output-buffer-limit  slave                       256mb  64mb  60</span><br><span class="line">client-output-buffer-limit  pubsub                      256mb  64b   120</span><br><span class="line">hz                          10</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file  nodes.conf   </span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7000/bin/redis-server 7000/cluster.conf</span><br><span class="line">7001/bin/redis-server 7001/cluster.conf</span><br><span class="line">7002/bin/redis-server 7002/cluster.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-创建集群"><a href="#1-创建集群" class="headerlink" title="1 创建集群"></a>1 创建集群</h4><p>对于5.0以前的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/redis_cluster/7000/bin/redis-trib.rb create --replicas 2 192.168.1.233:7000 192.168.1.233:7001 192.168.1.233:7002 192.168.1.234:7000 192.168.1.234:7001 192.168.1.234:7002 192.168.1.235:7000  192.168.1.235:7001 192.168.1.235:7002</span><br></pre></td></tr></table></figure>
<p>对于5.0的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/redis_cluster/7000/bin/redis-cli --cluster  create --cluster-replicas 2   192.168.1.233:7000 192.168.1.233:7001 192.168.1.233:7002 192.168.1.234:7000 192.168.1.234:7001 192.168.1.234:7002 192.168.1.235:7000  192.168.1.235:7001 192.168.1.235:7002</span><br></pre></td></tr></table></figure>

<p>如果使用了错误的版本命令，会有下面的警告信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@base_233 redis_cluster]# /usr/local/redis_cluster/7000/bin/redis-trib.rb create --replicas 2 192.168.1.233:7000 192.168.1.233:7001 192.168.1.233:7002 192.168.1.234:7000 192.168.1.234:7001 192.168.1.234:7002 192.168.1.235:7000  192.168.1.235:7001 192.168.1.235:7002</span><br><span class="line">WARNING: redis-trib.rb is not longer available!</span><br><span class="line">You should use redis-cli instead.</span><br><span class="line"></span><br><span class="line">All commands and features belonging to redis-trib.rb have been moved</span><br><span class="line">to redis-cli.</span><br><span class="line">In order to use them you should call redis-cli with the --cluster</span><br><span class="line">option followed by the subcommand name, arguments and options.</span><br><span class="line"></span><br><span class="line">Use the following syntax:</span><br><span class="line">redis-cli --cluster SUBCOMMAND [ARGUMENTS] [OPTIONS]</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">redis-cli --cluster create 192.168.1.233:7000 192.168.1.233:7001 192.168.1.233:7002 192.168.1.234:7000 192.168.1.234:7001 192.168.1.234:7002 192.168.1.235:7000 192.168.1.235:7001 192.168.1.235:7002 --cluster-replicas 2</span><br><span class="line"></span><br><span class="line">To get help about all subcommands, type:</span><br><span class="line">redis-cli --cluster help</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>redis 5.0 放弃redis-trib.rb，使用<code>redis-cli --cluster create</code>创建集群。也就是说5.0以后所有的集群操作都是通过<code>redis-cli --cluster</code> 来执行的。</p>
</blockquote>
<p>创建集群后会提示是否能更新以上的配置？选择yes</p>
<h4 id="修复集群"><a href="#修复集群" class="headerlink" title="修复集群"></a>修复集群</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/redis_cluster/7000/bin/redis-cli --cluster check  192.168.1.233:7001</span><br></pre></td></tr></table></figure>

<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><a href="https://github.com/ZhuoRoger/redismon">https://github.com/ZhuoRoger/redismon</a><br>or<br><a href="https://github.com/iambocai/falcon-monit-scripts">https://github.com/iambocai/falcon-monit-scripts</a></p>
<h2 id="备份机制"><a href="#备份机制" class="headerlink" title="备份机制"></a>备份机制</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>每秒或者每次写操作，安全，速度不够快，也存在丢失1秒的可能。可以在从机器上开启。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>快照，定时，或者数量改变时，存储到一个二进制文件。容易恢复，文件小，但是存在不完整的可能。</p>
<p>主库开启RDB，每天<br>从库开启AOF，</p>
<p>如果只配置AOF,重启时加载AOF文件恢复数据；<br>如果同时 配置了RBD和AOF,启动是只加载AOF文件恢复数据;<br>如果只配置RBD,启动是讲加载dump文件恢复数据。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://doc.redisfans.com/topic/sentinel.html">http://doc.redisfans.com/topic/sentinel.html</a><br><a href="https://redis.io/topics/sentinel-clients">sentinel客户端使用参考</a><br><a href="https://www.cnblogs.com/yiwangzhibujian/p/7047458.html">sentinel和cluster的对比</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Rsync+Inotify 实时同步</title>
    <url>/Rsync+Inotify%20%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5.html</url>
    <content><![CDATA[<blockquote>
<p>需求：实时同步A机器文件到B机器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A 192.168.1.225</span><br><span class="line">B 192.168.1.226</span><br></pre></td></tr></table></figure>

<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><img data-src="https://img.econow.cn/2018/1540378473281.png" width="924"/>

<h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p>A</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install rsync</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后修改配置文件<br>&#x2F;etc&#x2F;rsyncd.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pid file = /var/run/rsync.pid</span><br><span class="line">log file = /var/log/rsync.log</span><br><span class="line">lock file=/var/run/rsync.lock</span><br><span class="line">secrets file = /etc/rsync.pwss</span><br><span class="line">transfer logging = yes</span><br><span class="line">address=192.168.1.226</span><br><span class="line">[data]</span><br><span class="line">path = /home/joy/imkefu/apache-tomcat-8.0.45/webapps/ROOT/WEB-INF/classes</span><br><span class="line">comment = data</span><br><span class="line">port = 873</span><br><span class="line">uid = root</span><br><span class="line">gid = root</span><br><span class="line">timeout = 600</span><br><span class="line">max connections = 200</span><br><span class="line">use chroot = no</span><br><span class="line">read only = no</span><br><span class="line">hosts allow = 192.168.1.225</span><br></pre></td></tr></table></figure>
<p>设置验证文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/etc/rsync.pass</span><br><span class="line">123456</span><br><span class="line"></span><br><span class="line">#chmod 600 /etc/rsync.pass</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start rsyncd</span><br></pre></td></tr></table></figure>

<p>B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install rsync</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置验证文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/etc/rsync.pass</span><br><span class="line">123456</span><br><span class="line"></span><br><span class="line">#chmod 600 /etc/rsync.pass</span><br></pre></td></tr></table></figure>
<h3 id="Inotify"><a href="#Inotify" class="headerlink" title="Inotify"></a>Inotify</h3><h4 id="安装inotify"><a href="#安装inotify" class="headerlink" title="安装inotify"></a>安装inotify</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz</span><br><span class="line">tar zxf inotify-tools-3.14.tar.gz</span><br><span class="line">cd inotify-tools-3.14</span><br><span class="line">./configure –prefix=/usr/local/inotify-3.14</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h4 id="同步脚本"><a href="#同步脚本" class="headerlink" title="同步脚本"></a>同步脚本</h4><p>A</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#currentdate=`date +%Y%m%d%H%M`</span><br><span class="line"></span><br><span class="line">src=/home/joy/imkefu/apache-tomcat-8.0.45/webapps/ROOT/WEB-INF/classes/</span><br><span class="line">des=data</span><br><span class="line">user=root</span><br><span class="line">host=192.168.1.226</span><br><span class="line">/usr/local/inotify/bin/inotifywait -mrq --timefmt &#x27;%d/%m/%y %H:%M&#x27; --format &#x27;%T %w%f%e&#x27; -e modify,delete,create,attrib $src | while read files</span><br><span class="line">do</span><br><span class="line">/usr/bin/rsync -vzrtopg  --progress --delete --password-file=/etc/rsyncd.pass $src $user@$host::$des</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>然后执行该脚本。。。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul>
<li>可以先拿无关目录测试</li>
<li>检查pass文件权限必须是600</li>
<li>module名字必须保持一致</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot日志收集输出到ELK</title>
    <url>/SpringBoot%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E8%BE%93%E5%87%BA%E5%88%B0ELK.html</url>
    <content><![CDATA[<blockquote>
<p>注意logstash启动的时候有个坑，如果启动指定目录，那么必须保证该目录下都是配置文件，否则就会误以为都是配置文件。</p>
</blockquote>
<h2 id="配置pom文件"><a href="#配置pom文件" class="headerlink" title="配置pom文件"></a>配置pom文件</h2><h2 id="配置logback"><a href="#配置logback" class="headerlink" title="配置logback"></a>配置logback</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration debug=&quot;false&quot;&gt; </span><br><span class="line">  &lt;springProperty scope=&quot;context&quot; name=&quot;logPath&quot; source=&quot;joy.logback.path&quot;/&gt;  </span><br><span class="line">  &lt;springProperty scope=&quot;context&quot; name=&quot;logName&quot; source=&quot;spring.application.name&quot;/&gt;  </span><br><span class="line">  &lt;property name=&quot;LOG_HOME&quot; value=&quot;$&#123;logPath&#125;/logs&quot;/&gt;  </span><br><span class="line">  &lt;property name=&quot;LOG_NAME&quot; value=&quot;$&#123;logName&#125;&quot;/&gt;  </span><br><span class="line">  &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; </span><br><span class="line">    &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; </span><br><span class="line">      &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; </span><br><span class="line">    &lt;/encoder&gt; </span><br><span class="line">  &lt;/appender&gt;  </span><br><span class="line"> </span><br><span class="line">  &lt;appender name=&quot;stash&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt; </span><br><span class="line">    &lt;destination&gt;172.16.16.13:4568&lt;/destination&gt;  </span><br><span class="line">    &lt;encoder charset=&quot;UTF-8&quot; class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;/&gt; </span><br><span class="line">  &lt;/appender&gt;  </span><br><span class="line">  &lt;root level=&quot;INFO&quot;&gt; </span><br><span class="line">    &lt;appender-ref ref=&quot;stash&quot;/&gt;  </span><br><span class="line">    &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; </span><br><span class="line">  &lt;/root&gt; </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>此处定义的level是指程序里的INFO，代表INFO级别的日志都输出至logstash。</p>
<h2 id="配置logstash"><a href="#配置logstash" class="headerlink" title="配置logstash"></a>配置logstash</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">        tcp &#123;</span><br><span class="line">        	add_field =&gt; &#123; &quot;serverType&quot; =&gt; &quot;collect&quot;&#125;</span><br><span class="line">                mode =&gt; &quot;server&quot;</span><br><span class="line">                host =&gt; &quot;0.0.0.0&quot;</span><br><span class="line">                port =&gt; 4568</span><br><span class="line">        	codec =&gt; json &#123; charset =&gt; &quot;UTF-8&quot;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">filter&#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match =&gt; &#123;</span><br><span class="line">            &quot;message&quot; =&gt; &quot;(?&lt;datetime&gt;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;\s\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;.\d&#123;3&#125;)  INFO %&#123;NUMBER:thread&#125; --- %&#123;SYSLOG5424SD:task&#125; %&#123;JAVACLASS:javaclass&#125;\s*: %&#123;SYSLOG5424SD:module&#125;\s*%&#123;GREEDYDATA:msg&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">        convert =&gt; [&quot;[geoip][coordinates]&quot;, &quot;float&quot;]</span><br><span class="line">        remove_field =&gt; [&quot;tags&quot;, &quot;offset&quot;, &quot;host&quot;, &quot;beat&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">    if [serverType] == &quot;collect&quot; &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">            hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">            index =&gt; &quot;collcet-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper 实践</title>
    <url>/Zookeeper%20%E5%AE%9E%E8%B7%B5.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p> ZooKeeper 是一个开源的分布式协调服务，由雅虎创建，是 Google Chubby 的开源实现。<br>分布式应用程序可以基于 ZooKeeper 实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协<br>调&#x2F;通知、集群管理、Master 选举、配置维护，名字服务、分布式同步、分布式锁和分布式队列<br>等功能。</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>一个 ZooKeeper 集群同一时刻只会有一个 Leader，其他都是 Follower 或 Observer。</p>
<p>ZooKeeper 配置很简单，每个节点的配置文件(zoo.cfg)都是一样的，只有 myid 文件不一样。myid 的值必须是 zoo.cfg中server.{数值} 的{数值}部分。<br>在装有 ZooKeeper 的机器的终端执行 zookeeper-server status 可以看当前节点的 ZooKeeper是什么角色（Leader or Follower）。<br><img data-src="https://img.econow.cn/medivh/1547261347782.png" /><br>ZooKeeper 默认只有 Leader 和 Follower 两种角色，没有 Observer 角色。为了使用 Observer 模式，在任何想变成Observer的节点的配置文件中加入:peerType&#x3D;observer 并在所有 server 的配置文件中，配置成 observer 模式的 server 的那行配置追加 :observer 。</p>
<h3 id="读写分工"><a href="#读写分工" class="headerlink" title="读写分工"></a>读写分工</h3><ul>
<li>ZooKeeper 集群的所有机器通过一个 Leader 选举过程来选定一台被称为『Leader』的机器，Leader服务器为客户端提供读和写服务。</li>
<li>Follower 和 Observer 都能提供读服务，不能提供写服务。两者唯一的区别在于，Observer机器不参与 Leader 选举过程，也不参与写操作的『过半写成功』策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>ZooKeeper 是一个高可用的分布式数据管理与协调框架。基于对ZAB算法的实现，该框架能够很好地保证分布式环境中数据的一致性。也是基于这样的特性，使得 ZooKeeper 成为了解决分布式一致性问题的利器。</p>
<h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>配置jdk</li>
<li>配置hosts</li>
<li>配置 myid</li>
</ul>
<p><a href="http://archive.apache.org/dist/zookeeper/">http://archive.apache.org/dist/zookeeper/</a><br>另外一家CDH版本的<br><a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataDir=/opt/zookeeper/data</span><br><span class="line">dataLogDir=/opt/zookeeper/log</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=c1:2888:3888</span><br><span class="line">server.2=c2:2888:3888</span><br><span class="line">server.3=c3:2888:3888</span><br></pre></td></tr></table></figure>

<h4 id="配置文件解读"><a href="#配置文件解读" class="headerlink" title="配置文件解读"></a>配置文件解读</h4><ul>
<li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000&#x3D;10 秒</li>
<li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000&#x3D;4 秒</li>
<li>server.A&#x3D;B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</li>
</ul>
<h4 id="两台部署三台的伪集群示例"><a href="#两台部署三台的伪集群示例" class="headerlink" title="两台部署三台的伪集群示例"></a>两台部署三台的伪集群示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### z1</span><br><span class="line"></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/home/joy/zookeeper/data</span><br><span class="line">dataLogDir=/home/joy/zookeeper/log</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=10.252.1.15:2888:3888</span><br><span class="line">server.2=10.252.4.11:2888:3888</span><br><span class="line">server.3=10.252.4.11:2899:3899</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### z2</span><br><span class="line"></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/home/joy/zookeeper/data</span><br><span class="line">dataLogDir=/home/joy/zookeeper/log</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=10.252.1.15:2888:3888</span><br><span class="line">server.2=10.252.4.11:2888:3888</span><br><span class="line">server.3=10.252.4.11:2899:3899</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### z3</span><br><span class="line"></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/home/joy/zookeeper3/data</span><br><span class="line">dataLogDir=/home/joy/zookeeper3/log</span><br><span class="line">clientPort=2182</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=10.252.1.15:2888:3888</span><br><span class="line">server.2=10.252.4.11:2888:3888</span><br><span class="line">server.3=10.252.4.11:2899:3899</span><br></pre></td></tr></table></figure>

<h3 id="myid"><a href="#myid" class="headerlink" title="myid"></a>myid</h3><p>集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。</p>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/zkServer.sh start conf/zoo.cfg</span><br></pre></td></tr></table></figure>
<h3 id="分别检查节点状态"><a href="#分别检查节点状态" class="headerlink" title="分别检查节点状态"></a>分别检查节点状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zookeeper bin/zkServer.sh status conf/zoo.cfg</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1561278792094.png"  />
<img data-src="https://img.econow.cn/medivh/1561278810493.png"  />
<img data-src="https://img.econow.cn/medivh/1561278829368.png"  />
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-dump 迁移es数据 （elasticdump）</title>
    <url>/elasticsearch-dump%20%E8%BF%81%E7%A7%BBes%E6%95%B0%E6%8D%AE%20%EF%BC%88elasticdump%EF%BC%89.html</url>
    <content><![CDATA[<h3 id="elasticsearch-部分查询语句"><a href="#elasticsearch-部分查询语句" class="headerlink" title="elasticsearch 部分查询语句"></a>elasticsearch 部分查询语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取集群的节点列表：</span><br><span class="line">curl &#x27;localhost:9200/_cat/nodes?v&#x27;</span><br><span class="line"></span><br><span class="line"># 列出所有索引：</span><br><span class="line">curl &#x27;localhost:9200/_cat/indices?v&#x27;</span><br><span class="line"></span><br><span class="line">创建一个名为“customer”的索引，然后再查看所有的索引：</span><br><span class="line">curl -X PUT &#x27;localhost:9200/customer?pretty&#x27;</span><br><span class="line">curl &#x27;localhost:9200/_cat/indices?v&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="elasticsearch-dump"><a href="#elasticsearch-dump" class="headerlink" title="elasticsearch-dump"></a>elasticsearch-dump</h3><p><a href="https://github.com/taskrabbit/elasticsearch-dump">https://github.com/taskrabbit/elasticsearch-dump</a></p>
<h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><h5 id="npm-环境准备"><a href="#npm-环境准备" class="headerlink" title="npm 环境准备"></a>npm 环境准备</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Installing</span><br><span class="line">(local)</span><br><span class="line">wget https://nodejs.org/dist/v8.11.2/node-v8.11.2-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">tar xf node-v8.11.2-linux-x64.tar.xz </span><br><span class="line"></span><br><span class="line">mv node-v8.11.2-linux-x64 /usr/local</span><br><span class="line"></span><br><span class="line">ln -s /usr/local/node-v8.11.2-linux-x64/bin/npm /usr/local/bin/npm</span><br><span class="line"></span><br><span class="line">ln -s /usr/local/node-v8.11.2-linux-x64/bin/node /usr/local/bin/node</span><br></pre></td></tr></table></figure>
<h5 id="继续安装"><a href="#继续安装" class="headerlink" title="继续安装"></a>继续安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init -f</span><br><span class="line"></span><br><span class="line">#全局或者局部</span><br><span class="line"></span><br><span class="line">npm install elasticdump</span><br><span class="line">./bin/elasticdump</span><br><span class="line">(global)</span><br><span class="line"></span><br><span class="line">npm install elasticdump -g</span><br><span class="line">elasticdump</span><br></pre></td></tr></table></figure>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;#拷贝analyzer分词</span><br><span class="line">elasticdump \</span><br><span class="line">  --input=http://production.es.com:9200/my_index \</span><br><span class="line">  --output=http://staging.es.com:9200/my_index \</span><br><span class="line">  --type=analyzer</span><br><span class="line">&#x27;#拷贝映射</span><br><span class="line">elasticdump \</span><br><span class="line">  --input=http://production.es.com:9200/my_index \</span><br><span class="line">  --output=http://staging.es.com:9200/my_index \</span><br><span class="line">  --type=mapping</span><br><span class="line">&#x27;#拷贝数据</span><br><span class="line">elasticdump \</span><br><span class="line">  --input=http://production.es.com:9200/my_index \</span><br><span class="line">  --output=http://staging.es.com:9200/my_index \</span><br><span class="line">  --type=data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 注意 elasticdump 提供给了--httpAuthFile 参数来做认证</span><br><span class="line">--httpAuthFile      When using http auth provide credentials in ini file in form</span><br><span class="line">                    `user=&lt;username&gt;</span><br><span class="line">                    password=&lt;password&gt;`</span><br><span class="line"></span><br><span class="line"># 只需要写一个ini文件 ，文件中写入用户名和密码就可以了</span><br><span class="line"># 这里其实还有另外一个好的方法</span><br><span class="line"># 在--input参数和--output参数的的url中添加账号密码</span><br><span class="line"># 例如</span><br><span class="line"></span><br><span class="line">elasticdump \</span><br><span class="line">  --input=http://prod-username:prod-passowrd@production.es.com:9200/my_index \</span><br><span class="line">  --output=http://stage-username:stage-password@staging.es.com:9200/my_index \</span><br><span class="line">  --type=data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 备份索引数据到文件里:</span><br><span class="line">elasticdump \</span><br><span class="line">  --input=http://production.es.com:9200/my_index \</span><br><span class="line">  --output=/data/my_index_mapping.json \</span><br><span class="line">  --type=mapping</span><br><span class="line">elasticdump \</span><br><span class="line">  --input=http://production.es.com:9200/my_index \</span><br><span class="line">  --output=/data/my_index.json \</span><br><span class="line">  --type=data</span><br><span class="line"></span><br><span class="line"># 备份到标准输出，且进行压缩（这里有一个需要注意的地方，我查询索引信息有6.4G，用下面的方式备份后得到一个789M的压缩文件，这个压缩文件解压后有19G）:</span><br><span class="line">elasticdump \</span><br><span class="line">  --input=http://production.es.com:9200/my_index \</span><br><span class="line">  --output=$ \</span><br><span class="line">  | gzip &gt; /data/my_index.json.gz</span><br><span class="line"></span><br><span class="line"># 把一个查询结果备份到文件中</span><br><span class="line">elasticdump \</span><br><span class="line">  --input=http://production.es.com:9200/my_index \</span><br><span class="line">  --output=query.json \</span><br><span class="line">  --searchBody &#x27;&#123;&quot;query&quot;:&#123;&quot;term&quot;:&#123;&quot;username&quot;: &quot;admin&quot;&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将备份文件的数据导入ES</span><br><span class="line">elasticdump \</span><br><span class="line">  --input=./data.json \</span><br><span class="line">  --output=http://es.com:9200 </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch使用经验</title>
    <url>/elasticsearch%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C.html</url>
    <content><![CDATA[<h2 id="设定副本和切片数量"><a href="#设定副本和切片数量" class="headerlink" title="设定副本和切片数量"></a>设定副本和切片数量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">number_of_replicas 是数据备份数，如果只有一台机器，设置为0</span><br><span class="line">number_of_shards  是数据分片数，默认为5，有时候设置为3</span><br></pre></td></tr></table></figure>
<p>默认情况下每个索引都会生成5个切片，当然会占用大量磁盘空间。如果是对于安全性要求一般的情况下可以通过设置模板来改变数量。</p>
<h3 id="配置模板文件"><a href="#配置模板文件" class="headerlink" title="配置模板文件"></a>配置模板文件</h3><ul>
<li>index的名字必须要和指定的json文件中的templete名相匹配，定义的mapping才会生效。logstash的output配置的template_name名可以随便。</li>
<li>对于按照日期生成的规则解决办法，就是将template名末尾加一个*号通配符即可：<code> &quot;template&quot;:&quot;logstash-nginx_joy_app*&quot;</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/elk/logstash/config/es_nginx.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	&quot;template&quot;:&quot;logstash-nginx_joy_app*&quot;,</span><br><span class="line">	&quot;settings&quot;:</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;index.number_of_shards&quot;: 2,</span><br><span class="line">		&quot;number_of_replicas&quot;: 1</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置logstash文件"><a href="#配置logstash文件" class="headerlink" title="配置logstash文件"></a>配置logstash文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  if [fields][service] == &quot;nginx_joy_app&quot;&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;10.110.1.19:9200&quot;]</span><br><span class="line">        index =&gt; &quot;logstash-nginx_joy_app-%&#123;+YYYY.MM.dd.HH&#125;&quot;</span><br><span class="line">        document_type =&gt; &quot;logstash-nginx_joy_app&quot;</span><br><span class="line">		manage_template =&gt; true</span><br><span class="line">		template_overwrite =&gt; true</span><br><span class="line">		template_name =&gt; &quot;logstash-nginx_joy_app*&quot;</span><br><span class="line">		template =&gt; &quot;/usr/local/elk/logstash/config/es_nginx.json&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样就按照模板规则来生成对应索引了。<br><img data-src="https://img.econow.cn/medivh/1562138906913.png"  /></p>
<h2 id="日常语法"><a href="#日常语法" class="headerlink" title="日常语法"></a>日常语法</h2><h3 id="按照字段搜索"><a href="#按照字段搜索" class="headerlink" title="按照字段搜索"></a>按照字段搜索</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名: 值</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1562139077948.png"  />

<h3 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h3><p>查询一个或者多个的短语</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;短语&quot;</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1562139426035.png"  />

<h3 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status: 50*</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1562139875229.png"  />

<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>允许一个字段值在某个区间。[] 包含该值，{}不包含。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status: &#123;200 TO *&#125;</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1562140194294.png"  />

<h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔运算符（AND，OR，NOT）允许通过逻辑运算符组合多个子查询。</p>
<p>运算符AND&#x2F;OR&#x2F;NOT必须大写。</p>
<p>NOT type: mysql</p>
<p>mysql.method: SELECT AND mysql.size: [10000 TO *]</p>
<p>(mysql.method: INSERT OR mysql.method: UPDATE) AND responsetime: [30 TO *]</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Logstash中的 logstash-filter-useragent 插件可以帮助我们过滤出浏览器版本、型号以及系统版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [user_ua] != &quot;-&quot; &#123;</span><br><span class="line">      useragent &#123;</span><br><span class="line">         target =&gt; &quot;agent&quot;   #agent将过来出的user agent的信息配置到了单独的字段中</span><br><span class="line">         source =&gt; &quot;user_ua&quot;   #这个表示对message里面的哪个字段进行分析</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="跨多个es节点的负载均衡"><a href="#跨多个es节点的负载均衡" class="headerlink" title="跨多个es节点的负载均衡"></a>跨多个es节点的负载均衡</h2><p>如果想使用kibana访问es集群，那么只需要按照如下操作即可：</p>
<ul>
<li>安装Elasticsearch</li>
<li>将节点配置为仅协调节点。在配置文件中配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">＃3。您希望此节点既不是主节点，也不是数据节点，也不是摄取节点，但是</span><br><span class="line">＃充当“搜索负载均衡器”（从节点获取数据，</span><br><span class="line">＃聚合结果等）</span><br><span class="line">＃</span><br><span class="line">node.master：false</span><br><span class="line">node.data：false</span><br><span class="line">node.ingest：false</span><br></pre></td></tr></table></figure></li>
<li>配置es节点加入集群<code>cluster.name:xxxx</code>，注意保持一致</li>
<li>将该节点启动后使用kibana调用当前es地址</li>
<li>kibana.yml 配置多个es地址：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearch.hosts：</span><br><span class="line">  -  http：// elasticsearch1：9200</span><br><span class="line">  -  http：// elasticsearch2：9200</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/_search：所有索引，所有type下的所有数据都搜索出来</span><br><span class="line">/index1/_search：指定一个index，搜索其下所有type的数据</span><br><span class="line">/index1,index2/_search：同时搜索两个index下的数据</span><br><span class="line">/*1,*2/_search：按照通配符去匹配多个索引</span><br><span class="line">/index1/type1/_search：搜索一个index下指定的type的数据</span><br><span class="line">/index1/type1,type2/_search：可以搜索一个index下多个type的数据</span><br><span class="line">/index1,index2/type1,type2/_search：搜索多个index下的多个type的数据</span><br><span class="line">/_all/type1,type2/_search：_all，可以代表搜索所有index下的指定type的数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  ruby &#123;</span><br><span class="line">       code =&gt; &quot;event.set(&#x27;index_day&#x27;, event.timestamp.time.localtime.strftime(&#x27;%Y.%m.%d.%H&#x27;))&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  ....</span><br><span class="line">  index =&gt; &quot;logstash-nginx_joy_app-%&#123;index_day&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="状态检查"><a href="#状态检查" class="headerlink" title="状态检查"></a>状态检查</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. elasticsearch启动后查看是否启动成功：</span><br><span class="line">curl -XGET&quot;http://$(hostname):9200/_cluster/health?pretty=true&quot;</span><br><span class="line">2. 停止elasticsearch应用：</span><br><span class="line">curl -XPOST &quot;http:// $(hostname):9200/_shutdown&quot;</span><br><span class="line">3. 查看集群健康：</span><br><span class="line">curl $(hostname):9200/_cluster/health?pretty</span><br><span class="line">4. 检查集群状态：</span><br><span class="line">curl $(hostname):9200/_cluster/stats?pretty</span><br><span class="line">5. 节点状态：</span><br><span class="line">curl $(hostname):9200/_nodes/process?pretty</span><br><span class="line">curl $(hostname):9200/_nodes/node1/process?pretty</span><br><span class="line">6. 当你不知道有那些属性可以查看时：</span><br><span class="line">curl &#x27;$(hostname):9200/_cat/&#x27;，会返回可以查看的属性</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="磁盘扩容流程重启节点机器的流程"><a href="#磁盘扩容流程重启节点机器的流程" class="headerlink" title="磁盘扩容流程重启节点机器的流程"></a>磁盘扩容流程重启节点机器的流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path.data : /opt/data1,/opt/data2</span><br></pre></td></tr></table></figure>

<p>关闭自动平衡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPUT &quot;http://xxxx:9200/_cluster/settings&quot; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;transient&quot; : &#123; </span><br><span class="line">      &quot;cluster.routing.allocation.enable&quot; : &quot;none&quot; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>重启节点</p>
<p>开启平衡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPUT &quot;http://xxxx.52:9200/_cluster/settings&quot; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;transient&quot;: &#123;</span><br><span class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;all&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>freeswitch部署文档</title>
    <url>/freeswitch%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3.html</url>
    <content><![CDATA[<h3 id="一、freeswitch"><a href="#一、freeswitch" class="headerlink" title="一、freeswitch"></a>一、freeswitch</h3><p>注意区分CentOS 6&#x2F;7，不同版本编译的时候会有些差别。比如6上不会提示opus-devel，但是7必须安装。</p>
<h3 id="二、Libshout"><a href="#二、Libshout" class="headerlink" title="二、Libshout"></a>二、Libshout</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y http://mirror.centos.org/centos/7/os/x86_64/Packages/libshout-2.2.2-11.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<h3 id="三、执行命令："><a href="#三、执行命令：" class="headerlink" title="三、执行命令："></a>三、执行命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y http://files.freeswitch.org/freeswitch-release-1-6.noarch.rpm</span><br></pre></td></tr></table></figure>
<h3 id="四、按照依赖"><a href="#四、按照依赖" class="headerlink" title="四、按照依赖"></a>四、按照依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y git alsa-lib-devel autoconf automake bison broadvoice-devel bzip2 curl-devel libmpg123-devel libmp3lame-devel db-devel e2fsprogs-devel flite-devel g722_1-devel gcc-c++ gdbm-devel gnutls-devel ilbc2-devel ldns-devel libcodec2-devel libcurl-devel libedit-devel libidn-devel libjpeg-devel libmemcached-devel libogg-devel libsilk-devel libsndfile-devel libtheora-devel libtiff-devel libtool libuuid-devel libvorbis-devel libxml2-devel lua-devel lzo-devel mongo-c-driver-devel ncurses-devel net-snmp-devel openssl-devel opus-devel pcre-devel perl perl-ExtUtils-Embed pkgconfig portaudio-devel postgresql-devel python26-devel python-devel soundtouch-devel speex-devel sqlite-devel unbound-devel unixODBC-devel wget which yasm zlib-devel opus-devel libvorbis libvorbis-devel libogg libogg-devel</span><br></pre></td></tr></table></figure>

<h3 id="五、下载"><a href="#五、下载" class="headerlink" title="五、下载"></a>五、下载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">git clone -b v1.6 https://freeswitch.org/stash/scm/fs/freeswitch.git freeswitch</span><br></pre></td></tr></table></figure>

<h3 id="六、编译"><a href="#六、编译" class="headerlink" title="六、编译"></a>六、编译</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/freeswitch</span><br><span class="line">./bootstrap.sh -j</span><br><span class="line"></span><br><span class="line">./configure  --enable-core-odbc-support --enable-zrtp \</span><br><span class="line">            --enable-core-pgsql-support \</span><br><span class="line">            --enable-static-v8 --disable-parallel-build-v8</span><br><span class="line"></span><br><span class="line">#或者执行命令：</span><br><span class="line">./configure -C --enable-core-odbc-support --enable-zrtp \</span><br><span class="line">            --enable-core-pgsql-support \</span><br><span class="line">            --enable-static-v8 --disable-parallel-build-v8</span><br></pre></td></tr></table></figure>
<h3 id="七、-编辑modoul-xml"><a href="#七、-编辑modoul-xml" class="headerlink" title="七、 编辑modoul.xml"></a>七、 编辑modoul.xml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 #applications/mod_callcenter 、 #formats/mod_shout 、 #say/mod_say_zh  #applications/mod_curl 的&quot;#&quot;给去掉并，保存</span><br><span class="line">如果make的时候抛错，吧 #formats/mod_shout的注释重新加上。</span><br></pre></td></tr></table></figure>

<h3 id="八、继续编译安装"><a href="#八、继续编译安装" class="headerlink" title="八、继续编译安装"></a>八、继续编译安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make -j install</span><br><span class="line"></span><br><span class="line">#以下命令执行时下载文件的时间会很久</span><br><span class="line">make -j cd-sounds-install</span><br><span class="line">make -j cd-moh-install</span><br></pre></td></tr></table></figure>
<h4 id="九、相关配置文件"><a href="#九、相关配置文件" class="headerlink" title="九、相关配置文件"></a>九、相关配置文件</h4><p>线路参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conf/sip_profiles/external/uckefu.xml</span><br><span class="line">&lt;include&gt;</span><br><span class="line">    &lt;gateway name=&quot;uckef&quot;&gt;</span><br><span class="line">        &lt;param name=&quot;proxy&quot; value=&quot;59.110.14.46:6060&quot;/&gt;</span><br><span class="line">	&lt;param name=&quot;from-user&quot; value=&quot;3000001&quot;/&gt;</span><br><span class="line">	&lt;param name=&quot;register&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;/gateway&gt;</span><br><span class="line">&lt;/include&gt;</span><br></pre></td></tr></table></figure>
<p>电话号码</p>
<p>资料：<a href="https://blog.csdn.net/tcscy/article/details/71169688">https://blog.csdn.net/tcscy/article/details/71169688</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>influxdb基本使用</title>
    <url>/influxdb%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">brew install influxdb</span><br><span class="line"></span><br><span class="line">ln -sfv /usr/local/opt/influxdb/*.plist ~/Library/LaunchAgents</span><br><span class="line"></span><br><span class="line"># 配置文件在/etc/influxdb/influxdb.conf ，如果没有就将/usr/local/etc/influxdb.conf 拷一个过去</span><br><span class="line"></span><br><span class="line">配置缓存：cache-max-memory-size</span><br><span class="line"></span><br><span class="line">#启动服务</span><br><span class="line"></span><br><span class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.influxdb.plist</span><br><span class="line"></span><br><span class="line">#停止服务</span><br><span class="line"></span><br><span class="line">launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.influxdb.plist</span><br><span class="line"></span><br><span class="line">#前台启动</span><br><span class="line"></span><br><span class="line">influxd -config /usr/local/etc/influxdb.conf</span><br><span class="line"></span><br><span class="line">查看influxdb运行配置</span><br><span class="line"></span><br><span class="line">influxd config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动客户端</span><br><span class="line"></span><br><span class="line">influx -precision rfc3339</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、创建数据库</span><br><span class="line"></span><br><span class="line">create database mydb</span><br><span class="line"></span><br><span class="line">2、删除数据库</span><br><span class="line"></span><br><span class="line">drop database mydb</span><br><span class="line"></span><br><span class="line">3、使用数据库</span><br><span class="line"></span><br><span class="line">use mydb</span><br><span class="line"></span><br><span class="line">4、插入数据库</span><br><span class="line"></span><br><span class="line">insert mt,type=item,sensor=sensor01 value=3,is_delete=0</span><br><span class="line"></span><br><span class="line">注意：第一次插入数据会确定数据类型，之后的插入不能换数据类型。</span><br><span class="line"></span><br><span class="line">插入同一时间的数据会覆盖旧的，时间是主键。可以乱序插入。</span><br><span class="line"></span><br><span class="line">5、查询</span><br><span class="line"></span><br><span class="line">select * from mt</span><br><span class="line"></span><br><span class="line">where 中对字符串的过滤必须用单引号，tag默认为字符串类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>influxdb</tag>
      </tags>
  </entry>
  <entry>
    <title>kibana权限管理——SearchGuard</title>
    <url>/kibana%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94SearchGuard.html</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先根据es版本来选择search-guard,当前环境为5.4.1，因此选择对应版本。其他5.x参考 <a href="https://docs.search-guard.com/v5/search-guard-versions">https://docs.search-guard.com/v5/search-guard-versions</a></p>
<p><a href="https://docs.search-guard.com/v5/search-guard-installation">https://docs.search-guard.com/v5/search-guard-installation</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[joy@es_a2_1_19 elasticsearch]$ bin/elasticsearch-plugin install -b  com.floragunn:search-guard-5:5.4.1-15</span><br><span class="line">-&gt; Downloading com.floragunn:search-guard-5:5.4.1-15 from maven central</span><br><span class="line">[=================================================] 100%</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@     WARNING: plugin requires additional permissions     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">* java.io.FilePermission /proc/sys/net/core/somaxconn read</span><br><span class="line">* java.lang.RuntimePermission accessClassInPackage.sun.misc</span><br><span class="line">* java.lang.RuntimePermission accessClassInPackage.sun.nio.ch</span><br><span class="line">* java.lang.RuntimePermission accessClassInPackage.sun.security.x509</span><br><span class="line">* java.lang.RuntimePermission accessDeclaredMembers</span><br><span class="line">* java.lang.RuntimePermission getClassLoader</span><br><span class="line">* java.lang.RuntimePermission loadLibrary.*</span><br><span class="line">* java.lang.RuntimePermission setContextClassLoader</span><br><span class="line">* java.lang.RuntimePermission shutdownHooks</span><br><span class="line">* java.lang.reflect.ReflectPermission suppressAccessChecks</span><br><span class="line">* java.security.SecurityPermission getProperty.ssl.KeyManagerFactory.algorithm</span><br><span class="line">* java.security.SecurityPermission setProperty.ocsp.enable</span><br><span class="line">* java.util.PropertyPermission com.sun.security.enableCRLDP write</span><br><span class="line">* java.util.PropertyPermission es.set.netty.runtime.available.processors write</span><br><span class="line">* java.util.PropertyPermission java.security.debug write</span><br><span class="line">* java.util.PropertyPermission java.security.krb5.conf write</span><br><span class="line">* java.util.PropertyPermission javax.security.auth.useSubjectCredsOnly write</span><br><span class="line">* java.util.PropertyPermission sun.nio.ch.bugLevel write</span><br><span class="line">* java.util.PropertyPermission sun.security.krb5.debug write</span><br><span class="line">* java.util.PropertyPermission sun.security.spnego.debug write</span><br><span class="line">* javax.security.auth.AuthPermission doAs</span><br><span class="line">* javax.security.auth.AuthPermission modifyPrivateCredentials</span><br><span class="line">* javax.security.auth.kerberos.ServicePermission * accept</span><br><span class="line">See http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html</span><br><span class="line">for descriptions of what these permissions allow and the associated risks.</span><br><span class="line">-&gt; Installed search-guard-5</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[joy@es_a2_1_19 tools]$ sh install_demo_configuration.sh</span><br><span class="line">## Search Guard Demo Installer ##</span><br><span class="line">Warning: Do not use on production or public reachable systems</span><br><span class="line">Continue? [y/N] y</span><br><span class="line">Elasticsearch install type: .tar.gz</span><br><span class="line">Elasticsearch config dir: /home/joy/elasticsearch/config</span><br><span class="line">Detected Elasticsearch Version: 5.4.1</span><br><span class="line">Detected Search Guard Version: 5.4.1-15</span><br><span class="line"></span><br><span class="line">### Success</span><br><span class="line">### Execute this script now on all your nodes and then start all nodes</span><br><span class="line">### After the whole cluster is up execute:</span><br><span class="line">/home/joy/elasticsearch/plugins/search-guard-5/tools/sgadmin.sh -cd /home/joy/elasticsearch/plugins/search-guard-5/sgconfig -cn searchguard_demo -ks /home/joy/elasticsearch/config/kirk.jks -ts /home/joy/elasticsearch/config/truststore.jks -nhnv</span><br><span class="line">### or run ./sgadmin_demo.sh</span><br><span class="line">### Then open https://localhost:9200 an login with admin/admin</span><br><span class="line">### (Just ignore the ssl certificate warning because we installed a self signed demo certificate)</span><br></pre></td></tr></table></figure>
<p>elasticsearch.yml将会自动增加下列内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">######## Start Search Guard Demo Configuration ########</span><br><span class="line">searchguard.ssl.transport.keystore_filepath: keystore.jks</span><br><span class="line">searchguard.ssl.transport.truststore_filepath: truststore.jks</span><br><span class="line">searchguard.ssl.transport.enforce_hostname_verification: false</span><br><span class="line">searchguard.ssl.http.enabled: true</span><br><span class="line">searchguard.ssl.http.keystore_filepath: keystore.jks</span><br><span class="line">searchguard.ssl.http.truststore_filepath: truststore.jks</span><br><span class="line">searchguard.authcz.admin_dn:</span><br><span class="line">  - CN=kirk,OU=client,O=client,L=test, C=de</span><br><span class="line"></span><br><span class="line">cluster.name: searchguard_demo</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">######## End Search Guard Demo Configuration ########</span><br></pre></td></tr></table></figure>

<p>但是最终还是失败了，以后再看</p>
<p><a href="https://my.oschina.net/huangweibin/blog/820858">https://my.oschina.net/huangweibin/blog/820858</a><br><a href="https://www.cnblogs.com/marility/p/9392645.html">https://www.cnblogs.com/marility/p/9392645.html</a><br><a href="http://xiaoqiangge.com/aritcle/1536058241842.html">http://xiaoqiangge.com/aritcle/1536058241842.html</a><br><a href="https://blog.csdn.net/sinat_39562444/article/details/88235809">https://blog.csdn.net/sinat_39562444&#x2F;article&#x2F;details&#x2F;88235809</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/floragunncom/search-guard">https://github.com/floragunncom/search-guard</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>kubadm 高可用</title>
    <url>/kubadm%E9%AB%98%E5%8F%AF%E7%94%A8.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用kubeadm搭建一套kubernetes集群很简单，但是一个单节点的master并不能满足我们在生产环境的需求。因此必须得解决单点的问题后才能考虑在生产环境大面积推广应用。</p>
<p>实践目标</p>
<ol>
<li>至少2个以上的master节点可以同时管理集群;</li>
<li>集群的所有功能正常可用；</li>
<li>支持后续扩展；</li>
</ol>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>参考master单节点安装，此处不再具体描述。<br><strong>系统参数</strong> 修改系统内核参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenforce 0 </span><br><span class="line">sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27;</span> /etc/selinux/config  </span><br><span class="line">systemctl stop firewalld &amp;&amp; systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">swapoff -a </span><br><span class="line">sed -i <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab </span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/sysctl.conf &lt;&lt;<span class="string">eof</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">vm.swappiness=0</span></span><br><span class="line"><span class="string">eof</span></span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line">lsmod | grep ip</span><br></pre></td></tr></table></figure>

<p><strong>docker相关</strong> 安装docker。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br><span class="line">                  </span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum makecache fast</span><br><span class="line">yum -y install docker-ce</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">docker --version</span><br></pre></td></tr></table></figure>

<p><strong>安装相关组件</strong> 安装kubeadm必须组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装其他组件</span></span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以指定版本</span></span><br><span class="line">yum install -y kubelet-1.23.4 kubeadm-1.23.4 kubectl-1.23.4 --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure>

<h3 id="配置NGINX代理"><a href="#配置NGINX代理" class="headerlink" title="配置NGINX代理"></a>配置NGINX代理</h3><p>kube-apiserver高可用可以直接起多个节点，很多使用keepalive，haproxy来进行高可用配置，但是在大部分的公有云上无法使用vip。公有云上可以使用公有云提供的LoadBalance,这里我们使用nginx来代替.<br>nginx stream 四层协议的转发、代理或者负载均衡.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nginx nginx-mod-stream</span><br><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">  log_format  main  <span class="string">&#x27;$remote_addr [$time_local]&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;$protocol $status $bytes_sent $bytes_received&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;$session_time&#x27;</span>;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 16443;</span><br><span class="line">    proxy_pass kubeapi;</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">  &#125;</span><br><span class="line">  upstream kubeapi &#123;</span><br><span class="line">    server 192.168.1.109:6443;</span><br><span class="line">    server 192.168.1.217:6443;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="部署集群"><a href="#部署集群" class="headerlink" title="部署集群"></a>部署集群</h3><p><strong>获取默认配置文件</strong> 导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm-config.yaml</span><br></pre></td></tr></table></figure>

<p><strong>根据实际情况修改配置文件</strong> 注意修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- <span class="built_in">groups</span>:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef <span class="comment"># 自定义token</span></span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.1.109 <span class="comment"># master节点ip</span></span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /var/run/dockershim.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: node</span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controlPlaneEndpoint: 192.168.1.109:16443 <span class="comment"># 集群apiserver地址和端口</span></span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd: </span><br><span class="line">  <span class="built_in">local</span>:</span><br><span class="line">    dataDir: /var/lib/etcd   <span class="comment"># 修改etcd数据目录，也可以修改为外部etcd</span></span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers <span class="comment"># 仓库地址</span></span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.23.4 <span class="comment"># 版本</span></span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">cgroupDriver: cgroupfs</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">mode: ipvs</span><br></pre></td></tr></table></figure>

<p>配置说明：</p>
<ul>
<li>controlPlaneEndpoint：为集群apiserver监听端口16443</li>
<li>imageRepository:由于国内无法访问google镜像仓库k8s.gcr.io，这里指定为私有仓库地址  registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers</li>
<li>podSubnet:指定的IP地址段与后续部署的网络插件相匹配</li>
</ul>
<h4 id="执行初始化"><a href="#执行初始化" class="headerlink" title="执行初始化"></a>执行初始化</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --config=kubeadm-config.yaml --upload-certs | <span class="built_in">tee</span> kubeadm-init.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该命令指定了初始化时需要使用的配置文件，其中添加–upload-certs参数可以在后续执行加入节点时自动分发证书文件。<br>低版本注意使用–experimental-upload-certs。</p>
</blockquote>
<p><img data-src="evernotecid://2D277EDE-88BA-4DB6-AE12-A2B952C4D28E/appyinxiangcom/3119051/ENResource/p3036" alt="c6e534cbec32dfef14cfc2bb8f027c9e.png"></p>
<p>kubeadm init主要执行了以下操作：</p>
<ol>
<li>[init]：指定版本进行初始化操作</li>
<li>[preflight] ：初始化前的检查和下载所需要的Docker镜像文件</li>
<li>[kubelet-start]：生成kubelet的配置文件”&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml”，没有这个文件kubelet无法启动，所以初始化之前的kubelet实际上启动失败。</li>
<li>[certificates]：生成Kubernetes使用的证书，存放在&#x2F;etc&#x2F;kubernetes&#x2F;pki目录中。</li>
<li>[kubeconfig] ：生成 KubeConfig 文件，存放在&#x2F;etc&#x2F;kubernetes目录中，组件之间通信需要使用对应文件。</li>
<li>[control-plane]：使用&#x2F;etc&#x2F;kubernetes&#x2F;manifest目录下的YAML文件，安装 Master 组件。</li>
<li>[etcd]：使用&#x2F;etc&#x2F;kubernetes&#x2F;manifest&#x2F;etcd.yaml安装Etcd服务。</li>
<li>[wait-control-plane]：等待control-plan部署的Master组件启动。</li>
<li>[apiclient]：检查Master组件服务状态。</li>
<li>[uploadconfig]：更新配置</li>
<li>[kubelet]：使用configMap配置kubelet。</li>
<li>[patchnode]：更新CNI信息到Node上，通过注释的方式记录。</li>
<li>[mark-control-plane]：为当前节点打标签，打了角色Master，和不可调度标签，这样默认就不会使用Master节点来运行Pod。</li>
<li>[bootstrap-token]：生成token记录下来，后边使用kubeadm join往集群中添加节点时会用到</li>
<li>[addons]：安装附加组件CoreDNS和kube-proxy</li>
</ol>
<blockquote>
<p>无论是初始化失败或者集群已经完全搭建成功，你都可以直接执行kubeadm reset命令清理集群或节点，然后重新执行kubeadm init或kubeadm join相关操作即可。<br>注意清理<code>.kube</code>目录</p>
</blockquote>
<p><strong>配置网络插件</strong> calico</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.21/manifests/calico.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="其他节点加入集群"><a href="#其他节点加入集群" class="headerlink" title="其他节点加入集群"></a>其他节点加入集群</h3><p><strong>master</strong> join</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 192.168.1.109:16443 --token abcdef.0123456789abcdef \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:b9852b8ec72c5f26988763325e9da155de6136a3c3a62f48749bb4b6e09c37c0 \</span><br><span class="line">	--control-plane</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行后会自动生成相关文件和目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-node-217 kubernetes]<span class="comment"># ll</span></span><br><span class="line">total 28</span><br><span class="line">-rw------- 1 root root 5638 Feb 22 17:07 admin.conf</span><br><span class="line">-rw------- 1 root root 5673 Feb 22 17:07 controller-manager.conf</span><br><span class="line">-rw------- 1 root root 1955 Feb 22 17:07 kubelet.conf</span><br><span class="line">drwx------ 2 root root   96 Feb 22 17:07 manifests</span><br><span class="line">drwxr-xr-x 2 root root  288 Feb 22 17:07 pki</span><br><span class="line">-rw------- 1 root root 5621 Feb 22 17:07 scheduler.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在某些特殊情况下需要手动上传的话，注意传输以下文件即可：<br>admin.conf<br>pki&#x2F;ca.*<br>pki&#x2F;front-proxy*<br>pki&#x2F;sa*</p>
</blockquote>
<p><strong>worker</strong> 新node</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 192.168.1.109:16443 --token abcdef.0123456789abcdef \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:b9852b8ec72c5f26988763325e9da155de6136a3c3a62f48749bb4b6e09c37c0</span><br></pre></td></tr></table></figure>

<p>无论在master节点或node节点，要能够执行kubectl命令必须进行以下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<p><strong>检查集群</strong><br>两台master节点展示信息一致。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@uat-109 ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME            STATUS   ROLES                  AGE    VERSION</span><br><span class="line">k8s-node-217    Ready    control-plane,master   8m2s   v1.23.4</span><br><span class="line">master          Ready    control-plane,master   30h    v1.23.4</span><br><span class="line">test-216-tips   Ready    &lt;none&gt;                 27h    v1.23.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@k8s-node-217 ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME            STATUS   ROLES                  AGE    VERSION</span><br><span class="line">k8s-node-217    Ready    control-plane,master   8m9s   v1.23.4</span><br><span class="line">master          Ready    control-plane,master   30h    v1.23.4</span><br><span class="line">test-216-tips   Ready    &lt;none&gt;                 27h    v1.23.4</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>删除节点</strong><br>在master节点上执行：<br><code>kubectl drain node-xxx --delete-local-data --force --ignore-daemonsets</code></p>
<p>当节点变成不可调度状态时候 SchedulingDisabled，执行<br><code>kubectl delete node node-xxx</code></p>
<p><strong>ipvs</strong></p>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/89f126b241db">https://www.jianshu.com/p/89f126b241db</a></p>
</blockquote>
<p>IPVS简介：</p>
<p>尽管 Kubernetes 在版本v1.6中已经支持5000个节点，但使用 iptables 的 kube-proxy 实<br>际上是将集群扩展到5000个节点的瓶颈。 在5000节点集群中使用 NodePort 服务，如<br>果有2000个服务并且每个服务有10个 pod，这将在每个工作节点上至少产生20000个<br>iptable 记录，这可能使内核非常繁忙。</p>
<p>ipvs (IP Virtual Server) 实现了传输层负载均衡，也就是我们常说的4层LAN交换，作为<br>Linux 内核的一部分。ipvs运行在主机上，在真实服务器集群前充当负载均衡器。ipvs<br>可以将基于TCP和UDP的服务请求转发到真实服务器上，并使真实服务器的服务在单个<br>IP 地址上显示为虚拟服务。</p>
<p>我们知道kube-proxy支持 iptables 和 ipvs 两种模式， 在kubernetes v1.8 中引入了 ipvs<br>模式，在 v1.9 中处于 beta 阶段，在 v1.11 中已经正式可用了。iptables 模式在 v1.1 中<br>就添加支持了，从 v1.2版本开始 iptables 就是 kube-proxy 默认的操作模式，ipvs 和<br>iptables 都是基于netfilter的。ipvs 会使用 iptables 进行包过滤、SNAT、masquared。<br>具体来说，ipvs 将使用ipset来存储需要DROP或masquared的流量的源或目标地址，<br>以确保 iptables 规则的数量是恒定的，这样我们就不需要关心我们有多少服务了。</p>
<p>启动ipvs的要求：</p>
<p>k8s版本 &gt;&#x3D; v1.11<br>使用ipvs需要安装相应的工具来处理”yum install ipset ipvsadm -y“<br>确保 ipvs已经加载内核模块， ip_vs、ip_vs_rr、ip_vs_wrr、ip_vs_sh、<br>nf_conntrack_ipv4。如果这些内核模块不加载，当kube-proxy启动后，会退回到iptables模式。</p>
<p>先前基于iptables规则表的DNAT-&gt;SNAT方式来处理外部客户端到k8s集群pod内的流量<br>和集群内部流量(cluster-ip到pod ip)，无需在宿主机上管理cluster-ip都由iptables来进行<br>管理。</p>
<p>使用IPVS后是需要对vs(虚拟服务也就是vip)进行管理，由于IPVS的DNAT钩子挂在<br>INPUT链上，因此必须要让内核识别 VIP(cluster-ip) 是本机的 IP。k8s 通过设置将<br>service cluster ip 绑定到虚拟网卡kube-ipvs0，其中下面的10.96.x.x都是VIP，也就<br>是cluster-ip。</p>
<p><img data-src="evernotecid://2D277EDE-88BA-4DB6-AE12-A2B952C4D28E/appyinxiangcom/3119051/ENResource/p3037" alt="9b5302edcad44e440bbb8dbb5ccb128e.png"></p>
<p>kube-proxy 开启 ipvs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ipset ipvsadm -y</span><br></pre></td></tr></table></figure>

<p>修改ConfigMap的kube-system&#x2F;kube-proxy中的config.conf，mode: “ipvs”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master k8s]<span class="comment"># kubectl edit cm kube-proxy -n kube-system</span></span><br><span class="line">...</span><br><span class="line">    ipvs:</span><br><span class="line">      excludeCIDRs: null</span><br><span class="line">      minSyncPeriod: 0s</span><br><span class="line">      scheduler: <span class="string">&quot;&quot;</span></span><br><span class="line">      strictARP: <span class="literal">false</span></span><br><span class="line">      syncPeriod: 30s</span><br><span class="line">    kind: KubeProxyConfiguration</span><br><span class="line">    metricsBindAddress: 127.0.0.1:10249</span><br><span class="line">    mode: <span class="string">&quot;ipvs&quot;</span></span><br><span class="line">    nodePortAddresses: null</span><br><span class="line">    oomScoreAdj: -999</span><br><span class="line">    portRange: <span class="string">&quot;&quot;</span></span><br><span class="line">    resourceContainer: /kube-proxy</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">configmap/kube-proxy edited</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Kubernetes来说，可以直接将这三个Pod删除之后，会自动重建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master k8s]<span class="comment"># kubectl get pods -n kube-system|grep proxy</span></span><br><span class="line">kube-proxy-fn68r                           1/1     Running             0             75s</span><br><span class="line">kube-proxy-hrjls                           1/1     Running             0             78s</span><br><span class="line">kube-proxy-ltbqk                           1/1     Running             0             77s</span><br></pre></td></tr></table></figure>

<p>批量删除 kube-proxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system | grep kube-proxy | awk <span class="string">&#x27;&#123;system(&quot;kubectl delete pod &quot;$1&quot; -n kube-system&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于你已经通过ConfigMap修改了kube-proxy的配置，所以后期增加的Node节点，会直接使用ipvs模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment">#  kubectl logs kube-proxy-hrjls -n kube-system</span></span><br><span class="line">I0222 09:25:27.699369       1 node.go:163] Successfully retrieved node IP: 192.168.1.109</span><br><span class="line">I0222 09:25:27.699464       1 server_others.go:138] <span class="string">&quot;Detected node IP&quot;</span> address=<span class="string">&quot;192.168.1.109&quot;</span></span><br><span class="line">I0222 09:25:27.774905       1 server_others.go:269] <span class="string">&quot;Using ipvs Proxier&quot;</span></span><br><span class="line">I0222 09:25:27.774932       1 server_others.go:271] <span class="string">&quot;Creating dualStackProxier for ipvs&quot;</span></span><br><span class="line">I0222 09:25:27.775016       1 server_others.go:491] <span class="string">&quot;Detect-local-mode set to ClusterCIDR, but no IPv6 cluster CIDR defined, , defaulting to no-op detect-local for IPv6&quot;</span></span><br><span class="line">E0222 09:25:27.775284       1 proxier.go:379] <span class="string">&quot;Can&#x27;t set sysctl, kernel version doesn&#x27;t satisfy minimum version requirements&quot;</span> sysctl=<span class="string">&quot;net/ipv4/vs/conn_reuse_mode&quot;</span> minimumKernelVersion=<span class="string">&quot;4.1&quot;</span></span><br><span class="line">I0222 09:25:27.775454       1 proxier.go:438] <span class="string">&quot;IPVS scheduler not specified, use rr by default&quot;</span></span><br><span class="line">E0222 09:25:27.775637       1 proxier.go:379] <span class="string">&quot;Can&#x27;t set sysctl, kernel version doesn&#x27;t satisfy minimum version requirements&quot;</span> sysctl=<span class="string">&quot;net/ipv4/vs/conn_reuse_mode&quot;</span> minimumKernelVersion=<span class="string">&quot;4.1&quot;</span></span><br><span class="line">I0222 09:25:27.775756       1 proxier.go:438] <span class="string">&quot;IPVS scheduler not specified, use rr by default&quot;</span></span><br><span class="line">I0222 09:25:27.775850       1 ipset.go:113] <span class="string">&quot;Ipset name truncated&quot;</span> ipSetName=<span class="string">&quot;KUBE-6-LOAD-BALANCER-SOURCE-CIDR&quot;</span> truncatedName=<span class="string">&quot;KUBE-6-LOAD-BALANCER-SOURCE-CID&quot;</span></span><br><span class="line">I0222 09:25:27.775890       1 ipset.go:113] <span class="string">&quot;Ipset name truncated&quot;</span> ipSetName=<span class="string">&quot;KUBE-6-NODE-PORT-LOCAL-SCTP-HASH&quot;</span> truncatedName=<span class="string">&quot;KUBE-6-NODE-PORT-LOCAL-SCTP-HAS&quot;</span></span><br><span class="line">I0222 09:25:27.776321       1 server.go:656] <span class="string">&quot;Version info&quot;</span> version=<span class="string">&quot;v1.23.4&quot;</span></span><br><span class="line">I0222 09:25:27.783258       1 conntrack.go:52] <span class="string">&quot;Setting nf_conntrack_max&quot;</span> nf_conntrack_max=131072</span><br><span class="line">I0222 09:25:27.783815       1 config.go:317] <span class="string">&quot;Starting service config controller&quot;</span></span><br><span class="line">I0222 09:25:27.783883       1 shared_informer.go:240] Waiting <span class="keyword">for</span> caches to <span class="built_in">sync</span> <span class="keyword">for</span> service config</span><br><span class="line">I0222 09:25:27.783942       1 config.go:226] <span class="string">&quot;Starting endpoint slice config controller&quot;</span></span><br><span class="line">I0222 09:25:27.783963       1 shared_informer.go:240] Waiting <span class="keyword">for</span> caches to <span class="built_in">sync</span> <span class="keyword">for</span> endpoint slice config</span><br><span class="line">I0222 09:25:27.884501       1 shared_informer.go:247] Caches are synced <span class="keyword">for</span> endpoint slice config</span><br><span class="line">I0222 09:25:27.884570       1 shared_informer.go:247] Caches are synced <span class="keyword">for</span> service config</span><br></pre></td></tr></table></figure>

<p>日志中打印出了Using ipvs Proxier，说明ipvs模式已经开启。</p>
<p>使用ipvsadm测试，可以查看之前创建的Service已经使用LVS创建了集群。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># ipvsadm</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  master:https rr</span><br><span class="line">  -&gt; master:sun-sr-https         Masq    1      0          13</span><br><span class="line">  -&gt; master1:sun-sr-https   Masq    1      0          14</span><br><span class="line">TCP  master:domain rr</span><br><span class="line">TCP  master:9153 rr</span><br><span class="line">UDP  master:domain rr</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 常见问题的探讨</title>
    <url>/kubernetes%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%A2%E8%AE%A8.html</url>
    <content><![CDATA[<p>关于kubernetes 部署复杂是其特点之一，而网络问题则是最为常见的类型之一。</p>
<h3 id="场景-a-b-c-node上的pod互通，但是对d-node无法访问"><a href="#场景-a-b-c-node上的pod互通，但是对d-node无法访问" class="headerlink" title="场景 a&#x2F;b&#x2F;c node上的pod互通，但是对d node无法访问"></a>场景 a&#x2F;b&#x2F;c node上的pod互通，但是对d node无法访问</h3><blockquote>
<ul>
<li>个别服务出现无法访问另一个服务的情况；</li>
<li>测试判断无法ping通;</li>
<li>080端口无法访问;</li>
<li>经测试其他node上的pod均无法访问该node上的pod。</li>
</ul>
</blockquote>
<p>根据以上背景，初步断定是网络问题。</p>
<h4 id="通讯链路"><a href="#通讯链路" class="headerlink" title="通讯链路"></a>通讯链路</h4><img data-src="https://img.econow.cn/medivh/1630319238909.png"  />

<p>详细示例</p>
<img data-src="https://img.econow.cn/medivh/1630319277207.png"  />

<ul>
<li><p>数据从源容器中发出，经所在主机的docker0网卡转发到flannel网卡；</p>
</li>
<li><p>flannel通过etcd维护的路由表将数据发送给目的主机；</p>
</li>
<li><p>源主机的flanneld服务将原数据内容UDP封装和根据自己的路由表传递给目的地节点的flanneld服务；</p>
</li>
<li><p>数据到达后解包，然后直接进入目的节点的flannel网卡；</p>
</li>
<li><p>之后转发到目的主机的docker0网卡；</p>
</li>
<li><p>最后docker0路由到目标容器。</p>
</li>
</ul>
<h4 id="检查网卡"><a href="#检查网卡" class="headerlink" title="检查网卡"></a>检查网卡</h4><p>首先查看a&#x2F;b&#x2F;c网卡，检查docker0和flannel是否在同一网段。<br><img data-src="https://img.econow.cn/medivh/1630317106237.png"  /><br>检查结果正常。<br>检查d节点网卡<br><img data-src="https://img.econow.cn/medivh/1630317240889.png"  /><br>检查结果正常。</p>
<h4 id="检查路由表"><a href="#检查路由表" class="headerlink" title="检查路由表"></a>检查路由表</h4><p>查看a&#x2F;b&#x2F;c路由表<br><img data-src="https://img.econow.cn/medivh/1630317434299.png"/></p>
<blockquote>
<p>10.100.0.0 指向flannel<br>10.100.54.0 指向docker0<br>192.168.1.0 指向 ens3，局域网地址</p>
</blockquote>
<p>查看d路由表<br><img data-src="https://img.econow.cn/medivh/1630317458997.png"  /></p>
<blockquote>
<p>10.100.0.0 指向flannel<br>10.100.41.0 指向docker0<br>192.168.1.0 指向 ens3，局域网地址</p>
</blockquote>
<p>路由表无异常。<br>也可以使用下列命令，效果一样：<code>route -n</code></p>
<h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>

<h4 id="ip-forwad"><a href="#ip-forwad" class="headerlink" title="ip forwad"></a>ip forwad</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@test_243 ~]#  sysctl -a|grep ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv4.ip_forward_use_pmtu = 0</span><br></pre></td></tr></table></figure>
<p>如果没有打开转发，则使用以下方式。</p>
<h5 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h5><blockquote>
<p>临时生效的配置方式，在系统重启，或对系统的网络服务进行重启后都会失效。这种方式可用于临时测试、或做实验时使用。</p>
</blockquote>
<p>方案一<br>sysctl 命令的 -w 参数可以实时修改Linux的内核参数，并生效。所以使用如下命令可以开发Linux的路由转发功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>
<p>方案二<br>内核参数在Linux文件系统中的映射出的文件：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward中记录了Linux系统当前对路由转发功能的支持情况。文件中的值为0,说明禁止进行IP转发；如果是1,则说明IP转发功能已经打开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>


<h5 id="永久"><a href="#永久" class="headerlink" title="永久"></a>永久</h5><p>在sysctl.conf配置文件中有一项名为<code>net.ipv4.ip_forward</code>的配置项，用于配置Linux内核中的<code>net.ipv4.ip_forward</code>参数。其值为0,说明禁止进行IP转发；如果是1,则说明IP转发功能已经打开。</p>
<p>需要注意的是，修改sysctl.conf文件后需要执行指令<code>sysctl -p </code>后新的配置才会生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.d/99-sysctl.conf </span><br><span class="line">...</span><br><span class="line"># 结尾添加：</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">:wq</span><br><span class="line">[root@CentOS ~]# sysctl -p</span><br><span class="line">net.ipv4.ip_forward = 1   //查看修改结果.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><blockquote>
<p>检查etcd数据是否正常</p>
</blockquote>
<img data-src="https://img.econow.cn/medivh/1630321077720.png"  />
核对网段和Mac地址是否一致。
<img data-src="https://img.econow.cn/medivh/1630321154640.png"  />
事实证明`10.100.41.0`的网卡和实际的网卡Mac地址并不一致，所以导致源主机没有找到真实的目的主机。

<img data-src="https://img.econow.cn/medivh/1630321352642.png"  />

<p>最后发现，原<code>10.100.41.0</code>的网卡对应的是另外一台历史机器，造成的网卡冲突导致的这一后果。</p>
<h5 id="etcd的基本使用"><a href="#etcd的基本使用" class="headerlink" title="etcd的基本使用"></a>etcd的基本使用</h5><p>etcd是一个分布式的、可靠的k-v存储系统，它用于存储分布式系统中的关键数据。在kubernetes中保存集群所有的网络配置和对象的状态信息。在集群中共有两个服务需要用到etcd来协同和存储配置：</p>
<ul>
<li>flannel，对于其他网络差价也需要用到etcd;</li>
<li>kubernetes本身，包括各种对象的状态和元信息配置</li>
</ul>
<p>获取 集群网络配置<br><img data-src="https://img.econow.cn/medivh/1630462961875.png"  /></p>
<p>获取子网列表<br><img data-src="https://img.econow.cn/medivh/1630463028275.png"  /></p>
<p>获取主机网卡信息<br><img data-src="https://img.econow.cn/medivh/1630463053579.png"  /></p>
<p>帮助信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME:</span><br><span class="line">   etcdctl - A simple command line client for etcd.</span><br><span class="line"></span><br><span class="line">WARNING:</span><br><span class="line">   Environment variable ETCDCTL_API is not set; defaults to etcdctl v2.</span><br><span class="line">   Set environment variable ETCDCTL_API=3 to use v3 API or ETCDCTL_API=2 to use v2 API.</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   etcdctl [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   3.2.22</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">     backup          backup an etcd directory</span><br><span class="line">     cluster-health  check the health of the etcd cluster</span><br><span class="line">     mk              make a new key with a given value</span><br><span class="line">     mkdir           make a new directory</span><br><span class="line">     rm              remove a key or a directory</span><br><span class="line">     rmdir           removes the key if it is an empty directory or a key-value pair</span><br><span class="line">     get             retrieve the value of a key</span><br><span class="line">     ls              retrieve a directory</span><br><span class="line">     set             set the value of a key</span><br><span class="line">     setdir          create a new directory or update an existing directory TTL</span><br><span class="line">     update          update an existing key with a given value</span><br><span class="line">     updatedir       update an existing directory</span><br><span class="line">     watch           watch a key for changes</span><br><span class="line">     exec-watch      watch a key for changes and exec an executable</span><br><span class="line">     member          member add, remove and list subcommands</span><br><span class="line">     user            user add, grant and revoke subcommands</span><br><span class="line">     role            role add, grant and revoke subcommands</span><br><span class="line">     auth            overall auth controls</span><br><span class="line">     help, h         Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --debug                          output cURL commands which can be used to reproduce the request</span><br><span class="line">   --no-sync                        don&#x27;t synchronize cluster information before sending request</span><br><span class="line">   --output simple, -o simple       output response in the given format (simple, `extended` or `json`) (default: &quot;simple&quot;)</span><br><span class="line">   --discovery-srv value, -D value  domain name to query for SRV records describing cluster endpoints</span><br><span class="line">   --insecure-discovery             accept insecure SRV records describing cluster endpoints</span><br><span class="line">   --peers value, -C value          DEPRECATED - &quot;--endpoints&quot; should be used instead</span><br><span class="line">   --endpoint value                 DEPRECATED - &quot;--endpoints&quot; should be used instead</span><br><span class="line">   --endpoints value                a comma-delimited list of machine addresses in the cluster (default: &quot;http://127.0.0.1:2379,http://127.0.0.1:4001&quot;)</span><br><span class="line">   --cert-file value                identify HTTPS client using this SSL certificate file</span><br><span class="line">   --key-file value                 identify HTTPS client using this SSL key file</span><br><span class="line">   --ca-file value                  verify certificates of HTTPS-enabled servers using this CA bundle</span><br><span class="line">   --username value, -u value       provide username[:password] and prompt if password is not supplied.</span><br><span class="line">   --timeout value                  connection timeout per request (default: 2s)</span><br><span class="line">   --total-timeout value            timeout for the command execution (except watch) (default: 5s)</span><br><span class="line">   --help, -h                       show help</span><br><span class="line">   --version, -v                    print the version</span><br></pre></td></tr></table></figure>

<h5 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h5><ul>
<li>set 指定某个键的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xxx ~]# etcdctl set t1 &quot;v1&quot;</span><br><span class="line">v1</span><br><span class="line">[root@xxx ~]# etcdctl ls /</span><br><span class="line">/t1</span><br></pre></td></tr></table></figure>

<ul>
<li>get获取指定键的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xxx ~]# etcdctl get t1</span><br><span class="line">v1</span><br></pre></td></tr></table></figure>

<ul>
<li>rm&#x2F;rmdir  删除键</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@scm ~]# etcdctl rm t1</span><br><span class="line">PrevNode.Value: v1</span><br><span class="line">[root@scm ~]# etcdctl get t1</span><br><span class="line">Error:  100: Key not found (/t1) [127844346]</span><br></pre></td></tr></table></figure>

<h3 id="网卡地址不在一个网段"><a href="#网卡地址不在一个网段" class="headerlink" title="网卡地址不在一个网段"></a>网卡地址不在一个网段</h3><p>在kubernetes集群中某些服务启动顺序是特定的，必须是先启动flannel然后再启动docker。</p>
<p>flannel服务启动时主要做了以下几步的工作：</p>
<ul>
<li>从etcd中获取network的配置信息；</li>
<li>划分subnet，并在etcd中进行注册；</li>
<li>将子网信息记录到&#x2F;run&#x2F;flannel&#x2F;subnet.env中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xxx ~]# cat /run/flannel/subnet.env</span><br><span class="line">FLANNEL_NETWORK=10.100.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.100.28.1/24</span><br><span class="line">FLANNEL_MTU=1450</span><br><span class="line">FLANNEL_IPMASQ=false</span><br></pre></td></tr></table></figure>
<p>之后将会有一个脚本将subnet.env转写成一个docker的环境变量文件&#x2F;run&#x2F;flannel&#x2F;docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xxx ~]# cat /run/flannel/docker</span><br><span class="line">DOCKER_OPT_BIP=&quot;--bip=10.100.28.1/24&quot;</span><br><span class="line">DOCKER_OPT_IPMASQ=&quot;--ip-masq=true&quot;</span><br><span class="line">DOCKER_OPT_MTU=&quot;--mtu=1450&quot;</span><br><span class="line">DOCKER_NETWORK_OPTIONS=&quot; --bip=10.100.28.1/24 --ip-masq=true --mtu=1450&quot;</span><br></pre></td></tr></table></figure>

<p>然后是Docker服务</p>
<p>Docker服务会根据flannel拿到的网段然后把pod启动在这些网段，这样kubernetes在寻址pod的时候就会找到相应的宿主机，进行通讯。如果Docker服务和Flannel服务没有这种关联关系的化，很可能Docker先用原来的ip段启动，而这个段并没有写到etcd中，导致寻址失败。</p>
<h3 id="kubernetes的高可用"><a href="#kubernetes的高可用" class="headerlink" title="kubernetes的高可用"></a>kubernetes的高可用</h3><p>首先简单介绍一下常见的负载均衡类型，主要分为两类：四层和七层。<br>四层负载均衡是指负载均衡器用IP+Port的方式接收请求，再直接转发到后端对应的服务器上。工作在传输层。客户端和服务器之间建立一次TCP连接，而负载均衡设备至少起类似路由器的转发动作。常见的软件比如LVS。<br>七层负载均衡是根据虚拟的URL或者主机名来接收请求，经过处理后再转向响应的后端服务器上。工作在应用层，且建立两次连接。</p>
<ul>
<li>客户端到负载均衡器，负载均衡根据消息中的内容来做出负载均衡的决定；</li>
<li>然后建立负载均衡器到后端服务器的连接；</li>
</ul>
<p>负载均衡器需要先代理最终的服务器和客户端建立TCP连接后，才可能接收到客户端发送的真正应用层内容的保温，再根据报文中的特定字段，再加上负载均衡设备的服务器选择方式，决定最终选的服务器。常见的软件比如NGINX。</p>
<p>kubernetes部署架构</p>
<img data-src="https://img.econow.cn/medivh/1630476462885.png"  />

<p>kubernetes集群的高可用实际是各个核心组件的高可用。<br><img data-src="https://img.econow.cn/medivh/1630476228212.png"  /></p>
<ul>
<li>apiserver 通过 keepalived+haproxy 实现高可用，当某个节点故障时触发 keepalived vip 转移，haproxy 负责将流量负载到 apiserver 节点；</li>
<li>controller-manager k8s 内部通过选举方式产生领导者(由 –leader-elect 选型控制，默认为 true)，同一时刻集群内只有一个 controller-manager 组件运行，其余处于 backup 状态；</li>
<li>scheduler k8s 内部通过选举方式产生领导者(由 –leader-elect 选型控制，默认为 true)，同一时刻集群内只有一个scheduler组件运行，其余处于 backup 状态；</li>
<li>etcd 通过运行 kubeadm 方式自动创建集群来实现高可用，部署的节点数为奇数，3节点方式最多容忍一台机器宕机。</li>
</ul>
<p>多节点的核心点就是需要指向一个核心的地址或者VIP。node请求apiserver时不时直接指向master服务器，而是通过一个虚拟地址来分发到某个master。</p>
<h4 id="常规高可用"><a href="#常规高可用" class="headerlink" title="常规高可用"></a>常规高可用</h4><p>方案一、</p>
<ul>
<li>haproxy，提供高可用性，负载均衡，基于 TCP 和 HTTP 的代理，支持数以万记的并发连接</li>
<li>keepalived，是以 VRRP(虚拟路由冗余协议)协议为基础, 包括一个 master 和多个 backup。 master 劫持 vip 对外提供服务。master 发送组播，backup 节点收不到 vrrp 包时认为 master 宕机，此时选出剩余优先级最高的节点作为新的 master, 劫持 vip。keepalived 是保证高可用的重要组件。</li>
</ul>
<p>haproxy 提供代理后端apiserver的功能，keepalived提供健康检查和切换IP的用途。</p>
<p>方案二、</p>
<ul>
<li>nginx</li>
<li>keepalived</li>
</ul>
<p>该方案和方案一类似，也是使用代理功能，只不过使用的是NGINX提供的四层转发。</p>
<h4 id="阿里云环境的负载均衡"><a href="#阿里云环境的负载均衡" class="headerlink" title="阿里云环境的负载均衡"></a>阿里云环境的负载均衡</h4><p>阿里云云服务器不支持再单独购买 IP，无法安装配置 keepalived，进行负载均衡。如果需要配置负载均衡，可以直接购买负载均衡，进行负载均衡配置。这样就可以省略代理和keepalived的配置，只需要使用slb即可，注意后端服务指向的是master的apiserver的地址和端口。</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
  </entry>
  <entry>
    <title>kubernetes最新部署文档</title>
    <url>/kubernetes%E6%9C%80%E6%96%B0%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3.html</url>
    <content><![CDATA[<p>CentOS</p>
<p>Caution: This guide was originally written for Kubernetes 1.1.0 and is deprecated and is replaced by kubeadm.<br>Prerequisites</p>
<p>To configure Kubernetes with CentOS, you’ll need a machine to act as a master, and one or more CentOS 7 hosts to act as cluster nodes.<br>Starting a clusteru</p>
<p>This is a getting started guide for CentOS. It is a manual configuration so you understand all the underlying packages &#x2F; services &#x2F; ports, etc…<br>The Kubernetes package provides a few services: kube-apiserver, kube-scheduler, kube-controller-manager, kubelet, kube-proxy. These services are managed by systemd and the configuration resides in a central location: &#x2F;etc&#x2F;kubernetes. We will break the services up between the hosts. The first host, centos-master, will be the Kubernetes master. This host will run the kube-apiserver, kube-controller-manager and kube-scheduler. In addition, the master will also run etcd. The remaining hosts, centos-minion-n will be the nodes and run kubelet, proxy, cadvisor and docker.<br>All of them run flanneld as networking overlay.<br>System Information:<br>Hosts:<br>Please replace host IP with your environment.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">centos-master = 192.168.121.9</span><br><span class="line">centos-minion-1 = 192.168.121.65</span><br><span class="line">centos-minion-2 = 192.168.121.66</span><br><span class="line">centos-minion-3 = 192.168.121.67</span><br></pre></td></tr></table></figure>
<p>Prepare the hosts:</p>
<ul>
<li>Create a &#x2F;etc&#x2F;yum.repos.d&#x2F;virt7-docker-common-release.repo on all hosts - centos-{master,minion-n} with following information.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[virt7-docker-common-release]</span><br><span class="line">name=virt7-docker-common-release</span><br><span class="line">baseurl=http://cbs.centos.org/repos/virt7-docker-common-release/x86_64/os/</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure></li>
<li>Install Kubernetes, etcd and flannel on all hosts - centos-{master,minion-n}. This will also pull in docker and cadvisor.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install --enablerepo=virt7-docker-common-release kubernetes etcd flannel</span><br></pre></td></tr></table></figure></li>
<li>Add master and node to &#x2F;etc&#x2F;hosts on all machines (not needed if hostnames already in DNS)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;192.168.121.9    centos-master</span><br><span class="line">192.168.121.65    centos-minion-1</span><br><span class="line">192.168.121.66  centos-minion-2</span><br><span class="line">192.168.121.67  centos-minion-3&quot; &gt;&gt; /etc/hosts</span><br><span class="line">```  </span><br><span class="line">* Edit /etc/kubernetes/config which will be the same on all hosts to contain:</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="logging-to-stderr-means-we-get-it-in-the-systemd-journal"><a href="#logging-to-stderr-means-we-get-it-in-the-systemd-journal" class="headerlink" title="logging to stderr means we get it in the systemd journal"></a>logging to stderr means we get it in the systemd journal</h1><p>KUBE_LOGTOSTDERR&#x3D;”–logtostderr&#x3D;true”</p>
<h1 id="journal-message-level-0-is-debug"><a href="#journal-message-level-0-is-debug" class="headerlink" title="journal message level, 0 is debug"></a>journal message level, 0 is debug</h1><p>KUBE_LOG_LEVEL&#x3D;”–v&#x3D;0”</p>
<h1 id="Should-this-cluster-be-allowed-to-run-privileged-docker-containers"><a href="#Should-this-cluster-be-allowed-to-run-privileged-docker-containers" class="headerlink" title="Should this cluster be allowed to run privileged docker containers"></a>Should this cluster be allowed to run privileged docker containers</h1><p>KUBE_ALLOW_PRIV&#x3D;”–allow-privileged&#x3D;false”</p>
<h1 id="How-the-replication-controller-and-scheduler-find-the-kube-apiserver"><a href="#How-the-replication-controller-and-scheduler-find-the-kube-apiserver" class="headerlink" title="How the replication controller and scheduler find the kube-apiserver"></a>How the replication controller and scheduler find the kube-apiserver</h1><p>KUBE_MASTER&#x3D;”–master&#x3D;<a href="http://centos-master:8080/">http://centos-master:8080</a>“</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Disable the firewall on the master and all the nodes, as docker does not play well with other firewall rule managers. CentOS won’t let you disable the firewall as long as SELinux is enforcing, so that needs to be disabled first.</span><br><span class="line">* If you disable SELinux, make sure you reboot your machine before continuing to more steps.</span><br></pre></td></tr></table></figure>
<p>setenforce 0<br>systemctl disable iptables-services firewalld<br>systemctl stop iptables-services firewalld</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Configure the Kubernetes services on the master.</span><br><span class="line">* Edit /etc/etcd/etcd.conf to appear as such:</span><br></pre></td></tr></table></figure>
<h1 id="member"><a href="#member" class="headerlink" title="[member]"></a>[member]</h1><p>ETCD_NAME&#x3D;default<br>ETCD_DATA_DIR&#x3D;”&#x2F;var&#x2F;lib&#x2F;etcd&#x2F;default.etcd”<br>ETCD_LISTEN_CLIENT_URLS&#x3D;”<a href="http://0.0.0.0:2379/">http://0.0.0.0:2379</a>“</p>
<p>#[cluster]<br>ETCD_ADVERTISE_CLIENT_URLS&#x3D;”<a href="http://0.0.0.0:2379/">http://0.0.0.0:2379</a>“</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Edit /etc/kubernetes/apiserver to appear as such:</span><br></pre></td></tr></table></figure>
<h1 id="The-address-on-the-local-server-to-listen-to"><a href="#The-address-on-the-local-server-to-listen-to" class="headerlink" title="The address on the local server to listen to."></a>The address on the local server to listen to.</h1><p>KUBE_API_ADDRESS&#x3D;”–address&#x3D;0.0.0.0”</p>
<h1 id="The-port-on-the-local-server-to-listen-on"><a href="#The-port-on-the-local-server-to-listen-on" class="headerlink" title="The port on the local server to listen on."></a>The port on the local server to listen on.</h1><p>KUBE_API_PORT&#x3D;”–port&#x3D;8080”</p>
<h1 id="Port-kubelets-listen-on"><a href="#Port-kubelets-listen-on" class="headerlink" title="Port kubelets listen on"></a>Port kubelets listen on</h1><p>KUBELET_PORT&#x3D;”–kubelet-port&#x3D;10250”</p>
<h1 id="Comma-separated-list-of-nodes-in-the-etcd-cluster"><a href="#Comma-separated-list-of-nodes-in-the-etcd-cluster" class="headerlink" title="Comma separated list of nodes in the etcd cluster"></a>Comma separated list of nodes in the etcd cluster</h1><p>KUBE_ETCD_SERVERS&#x3D;”–etcd-servers&#x3D;<a href="http://centos-master:2379/">http://centos-master:2379</a>“</p>
<h1 id="Address-range-to-use-for-services"><a href="#Address-range-to-use-for-services" class="headerlink" title="Address range to use for services"></a>Address range to use for services</h1><p>KUBE_SERVICE_ADDRESSES&#x3D;”–service-cluster-ip-range&#x3D;10.254.0.0&#x2F;16”</p>
<h1 id="Add-your-own"><a href="#Add-your-own" class="headerlink" title="Add your own!"></a>Add your own!</h1><p>KUBE_API_ARGS&#x3D;””</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Start ETCD and configure it to hold the network overlay configuration on master: Warning This network must be unused in your network infrastructure! 172.30.0.0/16 is free in our network.</span><br></pre></td></tr></table></figure>
<p>systemctl start etcd<br>etcdctl mkdir &#x2F;kube-centos&#x2F;network<br>etcdctl mk &#x2F;kube-centos&#x2F;network&#x2F;config “{ &quot;Network&quot;: &quot;10.1.0.0&#x2F;16&quot;, &quot;SubnetLen&quot;: 24, &quot;Backend&quot;: { &quot;Type&quot;: &quot;vxlan&quot; } }”</p>
<ul>
<li>Configure flannel to overlay Docker network in &#x2F;etc&#x2F;sysconfig&#x2F;flanneld on the master (also in the nodes as we’ll see):<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"># Flanneld configuration options</span><br><span class="line"></span><br><span class="line"># etcd url location.  Point this to the server where etcd runs</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=&quot;http://centos-master:2379&quot;</span><br><span class="line"></span><br><span class="line"># etcd config key.  This is the configuration key that flannel queries</span><br><span class="line"># For address range assignment</span><br><span class="line">FLANNEL_ETCD_PREFIX=&quot;/kube-centos/network&quot;</span><br><span class="line"></span><br><span class="line"># Any additional options that you want to pass</span><br><span class="line">#FLANNEL_OPTIONS=&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>Start the appropriate services on master:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for SERVICES in etcd kube-apiserver kube-controller-manager kube-scheduler flanneld; do</span><br><span class="line">    systemctl restart $SERVICES</span><br><span class="line">    systemctl enable $SERVICES</span><br><span class="line">    systemctl status $SERVICES</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
Configure the Kubernetes services on the nodes.<br>We need to configure the kubelet and start the kubelet and proxy</li>
<li>Edit &#x2F;etc&#x2F;kubernetes&#x2F;kubelet to appear as such:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The address for the info server to serve on</span><br><span class="line">KUBELET_ADDRESS=&quot;--address=0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line"># The port for the info server to serve on</span><br><span class="line">KUBELET_PORT=&quot;--port=10250&quot;</span><br><span class="line"></span><br><span class="line"># You may leave this blank to use the actual hostname</span><br><span class="line"># Check the node number!</span><br><span class="line">KUBELET_HOSTNAME=&quot;--hostname-override=centos-minion-n&quot;</span><br><span class="line"></span><br><span class="line"># Location of the api-server</span><br><span class="line">KUBELET_API_SERVER=&quot;--api-servers=http://centos-master:8080&quot;</span><br><span class="line"></span><br><span class="line"># Add your own!</span><br><span class="line">KUBELET_ARGS=&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>Configure flannel to overlay Docker network in &#x2F;etc&#x2F;sysconfig&#x2F;flanneld (in all the nodes)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Flanneld configuration options</span><br><span class="line"></span><br><span class="line"># etcd url location.  Point this to the server where etcd runs</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=&quot;http://centos-master:2379&quot;</span><br><span class="line"></span><br><span class="line"># etcd config key.  This is the configuration key that flannel queries</span><br><span class="line"># For address range assignment</span><br><span class="line">FLANNEL_ETCD_PREFIX=&quot;/kube-centos/network&quot;</span><br><span class="line"></span><br><span class="line"># Any additional options that you want to pass</span><br><span class="line">#FLANNEL_OPTIONS=&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>Start the appropriate services on node (centos-minion-n).<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for SERVICES in kube-proxy kubelet flanneld docker; do</span><br><span class="line">    systemctl restart $SERVICES</span><br><span class="line">    systemctl enable $SERVICES</span><br><span class="line">    systemctl status $SERVICES</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li>Configure kubectl<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl config set-cluster default-cluster --server=http://centos-master:8080</span><br><span class="line">kubectl config set-context default-context --cluster=default-cluster --user=default-admin</span><br><span class="line">kubectl config use-context default-context</span><br></pre></td></tr></table></figure>
You should be finished!</li>
<li>Check to make sure the cluster can see the node (on centos-master)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME                   STATUS     AGE     VERSION</span><br><span class="line">centos-minion-1        Ready      3d      v1.6.0+fff5156</span><br><span class="line">centos-minion-2        Ready      3d      v1.6.0+fff5156</span><br><span class="line">centos-minion-3        Ready      3d      v1.6.0+fff5156</span><br></pre></td></tr></table></figure>
The cluster should be running! Launch a test pod.<br>Support Level</li>
</ul>
<p>IaaS Provider	Config. Mgmt	OS	Networking	Docs	Conforms	Support Level<br>Bare-metal	custom	CentOS	flannel	docs	 	Community (@coolsvap)<br>For support level information on all solutions, see the Table of solutions chart.<br>Create an Issue Edit this Page</p>
<h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><p>跨节点无法通信</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -F</span><br><span class="line">iptables -L -n</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云原生</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown 图床设置</title>
    <url>/markdown%20%E5%9B%BE%E5%BA%8A%E7%94%9F%E6%88%90.html</url>
    <content><![CDATA[<h2 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h2><p>安装requests库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>
<h4 id="获取图床信息"><a href="#获取图床信息" class="headerlink" title="获取图床信息"></a>获取图床信息</h4><p>选择新建存储空间，记住这个空间的名字。</p>
<img data-src="https://img.econow.cn/blog/1545128054650.png"/>


<h4 id="获取访问域名"><a href="#获取访问域名" class="headerlink" title="获取访问域名"></a>获取访问域名</h4><img data-src="https://img.econow.cn/blog/1545128359995.png" />

<p>注意该测试域名有效期30天，并且每天限流30G，也足够测试使用啦，以后最好还是绑定自己的域名。</p>
<h4 id="图床认证信息"><a href="#图床认证信息" class="headerlink" title="图床认证信息"></a>图床认证信息</h4><p>获取AK和SK</p>
<img data-src="https://img.econow.cn/blog/1545128556695.png" />

<h2 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载地址<br><a href="https://img.econow.cn/alfred%203.0.3.dmg">https://img.econow.cn/alfred%203.0.3.dmg</a><br>提取码<code>wkem</code> 必须得激活，不然用不了workflow.</p>
<p>OS X 10.14 激活参考<a href="https://img.econow.cn/alfred_3.0_CORE%20Keygen.app.zip">https://img.econow.cn/alfred_3.0_CORE%20Keygen.app.zip</a></p>
<p>今天试了一下MacBook Pro 2021 版本的也没啥问题。</p>
<h3 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h3><p>下载地址<br><a href="https://img.econow.cn/markdown_img.alfredworkflow">https://img.econow.cn/markdown_img.alfredworkflow</a> </p>
<h3 id="workflow-1"><a href="#workflow-1" class="headerlink" title="workflow"></a>workflow</h3><p>在 alfred 里面输入mdimgsetup,就会弹出一个文本文档，如下：<br><img data-src="https://img.econow.cn/medivh/1545129537529.png" /></p>
<ul>
<li>ak&#x2F;sk</li>
<li>URL改为自己的域名或者测试域名</li>
<li>bucket就是刚才创建的，注意保持一致</li>
</ul>
<h3 id="调整URL"><a href="#调整URL" class="headerlink" title="调整URL"></a>调整URL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line">from clipboard import get_paste_img_file</span><br><span class="line">from upload import upload_qiniu</span><br><span class="line">import util</span><br><span class="line">import os</span><br><span class="line">import subprocess</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if not os.path.exists(util.CONFIG_FILE):</span><br><span class="line">    util.generate_config_file()</span><br><span class="line"></span><br><span class="line">config = util.read_config()</span><br><span class="line">if not config:</span><br><span class="line">    util.notice(&#x27;请先设置你的七牛图床信息&#x27;)</span><br><span class="line">    util.open_with_editor(util.CONFIG_FILE)</span><br><span class="line">    sys.exit(0)</span><br><span class="line"></span><br><span class="line">url = &#x27;%s/%s&#x27; % (config[&#x27;url&#x27;], config[&#x27;prefix&#x27;])</span><br><span class="line"></span><br><span class="line">img_file, need_format, format = get_paste_img_file()</span><br><span class="line">if img_file:</span><br><span class="line">    # has image</span><br><span class="line"></span><br><span class="line">    # use time to generate a unique upload_file name, we can not use the tmp file name</span><br><span class="line">    upload_name = &quot;%s.%s&quot; % (int(time.time() * 1000), format)</span><br><span class="line">    if need_format:</span><br><span class="line">        size_str = subprocess.check_output(&#x27;sips -g pixelWidth %s | tail -n1 | cut -d&quot; &quot; -f4&#x27; % img_file.name, shell=True)</span><br><span class="line">        size = int(size_str.strip()) / 2</span><br><span class="line">        markdown_url = &#x27;&lt;img src=&quot;%s/%s&quot;  /&gt;&#x27; % (url, upload_name)</span><br><span class="line">    else:</span><br><span class="line">        markdown_url = &#x27;%s/%s&#x27; % (url, upload_name)</span><br><span class="line"></span><br><span class="line">    # make it to clipboard</span><br><span class="line">    os.system(&quot;echo &#x27;%s&#x27; | pbcopy&quot; % markdown_url)</span><br><span class="line">    os.system(&#x27;osascript -e \&#x27;tell application &quot;System Events&quot; to keystroke &quot;v&quot; using command down\&#x27;&#x27;)</span><br><span class="line">    upload_file = util.try_compress_png(img_file, format!=&#x27;gif&#x27;)</span><br><span class="line">    if not upload_qiniu(upload_file.name, upload_name): util.notice(&quot;上传图片到图床失败，请检查网络后重试&quot;)</span><br><span class="line">else:</span><br><span class="line">    util.notice(&quot;剪切版里没有图片！&quot;)</span><br></pre></td></tr></table></figure>
<p>根据个人需求，设置markdown_url拼接格式。如果出现什么问题，而且没有弹窗就再次导入alfed文件。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>###截图<br>使用任意截图工具截图之后，在任意编辑器里面你需要插入markdown格式图片的地方，按下cmd + ctrl + P即可！</p>
<h3 id="已有图片"><a href="#已有图片" class="headerlink" title="已有图片"></a>已有图片</h3><p>如果你已经有一张图片了，希望上传到图床得到一个链接；通常的方式需要图床客户端或者浏览器插件，通过这个alfred插件：<br>直接复制本地图片，然后按下cmd + ctrl + P 就能得到图床的链接！</p>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib 学习</title>
    <url>/matplotlib%20%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="matplotlib-有乱码"><a href="#matplotlib-有乱码" class="headerlink" title="matplotlib 有乱码"></a>matplotlib 有乱码</h3><p>1、下载中文字体（黑体，看准系统版本）<br>2、找到matplotlib字体文件夹，例如：matplotlib&#x2F;mpl-data&#x2F;fonts&#x2F;ttf，将SimHei.ttf拷贝到ttf文件夹下面<br>3、修改matplotlib配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/local/lib/python3.5/dist-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line"># 删除font.family和font.sans-serif两行前的#，并在font.sans-serif后添加中文字体Microsoft YaHei, ...(其余不变)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>4、下面代码检查可使用的字体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from matplotlib.font_manager import FontManager</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">fm = FontManager()</span><br><span class="line">mat_fonts = set(f.name for f in fm.ttflist)</span><br><span class="line">#print(mat_fonts)</span><br><span class="line">output = subprocess.check_output(&#x27;fc-list :lang=zh -f &quot;%&#123;family&#125;\n&quot;&#x27;, shell=True)</span><br><span class="line">#print( &#x27;*&#x27; * 10, &#x27;系统可用的中文字体&#x27;, &#x27;*&#x27; * 10)</span><br><span class="line">#print (output)</span><br><span class="line">zh_fonts = set(f.split(&#x27;,&#x27;, 1)[0] for f in output.decode(&#x27;utf-8&#x27;).split(&#x27;\n&#x27;))</span><br><span class="line">available = mat_fonts &amp; zh_fonts</span><br><span class="line">print (&#x27;*&#x27; * 10, &#x27;可用的字体&#x27;, &#x27;*&#x27; * 10)</span><br><span class="line">for f in available:</span><br><span class="line">     print (f)</span><br></pre></td></tr></table></figure>

<img data-src="https://img.econow.cn/medivh/1555251933809.png"  />


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import matplotlib</span><br><span class="line">from matplotlib.font_manager import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;]=[&#x27;Arial Unicode MS&#x27;]</span><br><span class="line">plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False #解决保存图像是负号&#x27;-&#x27;显示为方块的问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">price = [39.5, 39.9, 45.4, 38.9, 33.34]</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">绘制水平条形图方法barh</span><br><span class="line">参数一：y轴</span><br><span class="line">参数二：x轴</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">plt.barh(range(5), price, height=0.7, color=&#x27;steelblue&#x27;, alpha=0.8)      # 从下往上画</span><br><span class="line">plt.yticks(range(5), [&#x27;tom&#x27;, &#x27;当当网&#x27;, &#x27;中国图书网&#x27;, &#x27;京东&#x27;, &#x27;天猫&#x27;])</span><br><span class="line">plt.xlim(30,47)</span><br><span class="line">plt.xlabel(&quot;价格&quot;)</span><br><span class="line">plt.title(&quot;不同平台图书价格&quot;)</span><br><span class="line">for x, y in enumerate(price):</span><br><span class="line">    plt.text(y + 0.2, x - 0.1, &#x27;%s&#x27; % y)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者直接指定字体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import matplotlib</span><br><span class="line">from matplotlib.font_manager import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myfont = FontProperties(fname=&#x27;/System/Library/Fonts/PingFang.ttc&#x27;)</span><br><span class="line">matplotlib.rcParams[&#x27;axes.unicode_minus&#x27;]=False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">price = [39.5, 39.9, 45.4, 38.9, 33.34]</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">绘制水平条形图方法barh</span><br><span class="line">参数一：y轴</span><br><span class="line">参数二：x轴</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">plt.barh(range(5), price, height=0.7, color=&#x27;steelblue&#x27;, alpha=0.8)      # 从下往上画</span><br><span class="line">plt.yticks(range(5), [&#x27;tom&#x27;, &#x27;当当网&#x27;, &#x27;中国图书网&#x27;, &#x27;京东&#x27;, &#x27;天猫&#x27;],fontproperties=myfont)</span><br><span class="line">plt.xlim(30,47)</span><br><span class="line">plt.xlabel(&quot;价格&quot;,fontproperties=myfont)</span><br><span class="line">plt.title(&quot;不同平台图书价格&quot;,fontproperties=myfont)</span><br><span class="line">for x, y in enumerate(price):</span><br><span class="line">    plt.text(y + 0.2, x - 0.1, &#x27;%s&#x27; % y)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基本操作</title>
    <url>/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h2 id="Yum-安装"><a href="#Yum-安装" class="headerlink" title="Yum 安装"></a>Yum 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -Uvh  http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>
<h2 id="主从同步-读写分离"><a href="#主从同步-读写分离" class="headerlink" title="主从同步&#x2F;读写分离"></a>主从同步&#x2F;读写分离</h2><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server-id = 1  #(标识为master库)</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_format=mixed </span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">replicate-ignore-db=mysql</span><br><span class="line">binlog_cache_size = 1M</span><br><span class="line">binlog_format=mixed</span><br><span class="line">expire_logs_days=3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.创建账号并授权</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO backup@&#x27;%&#x27; IDENTIFIED BY &#x27;backup&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line">#2.锁表</span><br><span class="line">FLUSH TABLES WITH READ LOCK;</span><br><span class="line">#3.查看当前状态</span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1550219754792.png" />
备份导出，并将SQL文件传输给slave服务器执行导入。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot  --all-databases &gt; /tmp/mydb.sql</span><br></pre></td></tr></table></figure>


<h3 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h3><p>1、修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_id=2</span><br><span class="line">binlog-ignore-db=mysql #不记录binlog</span><br><span class="line">replicate-ignore-db=mysql #不复制test库的binlog</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_cache_size = 1M</span><br><span class="line">binlog_format=mixed</span><br><span class="line">expire_logs_days=3</span><br></pre></td></tr></table></figure>
<p>2、导入SQL文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source mydb.sql;</span><br></pre></td></tr></table></figure>
<p>3、开启同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.1.228&#x27;,MASTER_USER=&#x27;backup&#x27;,MASTER_PASSWORD=&#x27;backup&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000003&#x27;,MASTER_LOG_POS=399;</span><br></pre></td></tr></table></figure>
<p>4、设置只读<br>对于需要保证master-slave主从同步的salve库，如果要设置为只读状态，需要执行的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global variables like &quot;%read_only%&quot;;</span><br><span class="line">#查看只读状态</span><br><span class="line">mysql&gt; set global read_only=1;</span><br></pre></td></tr></table></figure>
<p>将salve库从只读状态变为读写状态，需要执行的命令是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global read_only=0;</span><br></pre></td></tr></table></figure>

<ul>
<li>1.read_only&#x3D;1只读模式，不会影响slave同步复制的功能，所以在MySQL slave库中设定了read_only&#x3D;1后，通过 show slave status\G 命令查看salve状态，可以看到salve仍然会读取master上的日志，并且在slave库中应用日志，保证主从数据库同步一致；</li>
<li>2.read_only&#x3D;1只读模式，可以限定普通用户进行数据修改的操作，但不会限定具有super权限的用户的数据修改操作；在MySQL中设置read_only&#x3D;1后，普通的应用用户进行insert、update、delete等会产生数据变化的DML操作时，都会报出数据库处于只读模式不能发生数据变化的错误，但具有super权限的用户，例如在本地或远程通过root用户登录到数据库，还是可以进行数据变化的DML操作；</li>
</ul>
<p>5、检查状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>
<p>检查是否和Master状态一致，并且两个线程是否为YES。<br><img data-src="https://img.econow.cn/medivh/1550219967672.png" /></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在Master上执行以下语句，解除锁表状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询最新10条数据  顺序、倒序</span><br><span class="line"></span><br><span class="line">select  * from t_web_001_member LIMIT 10</span><br><span class="line">select * from t_web_001_member ORDER BY memberId  desc limit 10</span><br></pre></td></tr></table></figure>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、update</span><br><span class="line">update table name set guarantee_id =&#x27;34&#x27; and guarantee_name = &#x27;xxxx’ where demand_id = 1567;</span><br><span class="line">2、insert into </span><br><span class="line">insert into table(field1,field2) values(value1,value2)</span><br><span class="line">3、delete</span><br><span class="line">delete from table where 范围</span><br><span class="line"></span><br><span class="line">-- select * from t_web_001_member where DATE(regtime) = &#x27;2017-09-13&#x27; and  memberId &gt; 165949;</span><br><span class="line">select * from t_web_001_member where DATE(regtime) = &#x27;2017-09-12&#x27;;</span><br><span class="line">-- select * from t_web_001_member where DATE(regtime) = &#x27;2017-09-13&#x27; and  memberId &gt; 165949;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- UPDATE  t_web_001_member  set regtime= DATE_FORMAT(ADDDATE(date_sub(&#x27;2017-09-12 07:00:00&#x27;,interval 0 day) , INTERVAL FLOOR(0 + RAND() * 120) MINUTE),&#x27;%Y-%m-%d %H:%i:%s&#x27;) where DATE(regtime) = &#x27;2017-09-13&#x27; and  memberId &gt; 165949 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into</span><br><span class="line">INSERT INTO t_web_001_member(userName, mobile, loginpwd,regtime,mobile_state, isAccountIn) SELECT username, mobile, PASSWORD, create_time,1, 1 FROM t_user;</span><br><span class="line"></span><br><span class="line">清空某列的数据</span><br><span class="line">update t_web_001_member set regtime =null;</span><br></pre></td></tr></table></figure>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.7设置root密码</span><br><span class="line">update mysql.user set authentication_string=password(&#x27;123qwe&#x27;) where user=&#x27;root&#x27; and Host = &#x27;localhost&#x27;;</span><br><span class="line"></span><br><span class="line">DATE_FORMAT(ADDDATE(date_sub(&#x27;2017-09-05 07:00:00&#x27;,interval -1 day) , INTERVAL FLOOR(0 + RAND() * 120) MINUTE),&#x27;%Y-%m-%d %H:%i:%s&#x27;)</span><br><span class="line">日期随机 </span><br><span class="line"></span><br><span class="line">mysqladmin -u root password &quot;newpass&quot;</span><br><span class="line">mysqladmin -u root password “ios&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create database zabbix charset utf8;</span><br><span class="line">create database car charset utf8;</span><br><span class="line">grant all privileges on car.* to &#x27;car&#x27;@&#x27;%&#x27; identified by &#x27;xxxxxx&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">#给普通用户建库的权限</span><br><span class="line">grant select,delete,update,create,drop,alter,insert on *.* to &#x27;xx&#x27;@&#x27;%&#x27; ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导入导出</span><br><span class="line">-d  表结构</span><br><span class="line">#导出数据和表结构</span><br><span class="line">mysqldump -uroot -p dbname &gt; dbname.sql</span><br><span class="line">#导出多张表</span><br><span class="line">mysqldump -uroot -password dbname table1 table2 &gt;db.sql</span><br><span class="line"></span><br><span class="line">#导出表结</span><br><span class="line">mysqldump -uroot -p -d     dbname &gt; dbname.sql</span><br><span class="line">#导出某张表的数据和表结构</span><br><span class="line">mysqldump -uroot -pdbpasswd  dbname &gt;db.sql;</span><br><span class="line">#导出某张表的表结构</span><br><span class="line">mysqldump -uroot -pdbpasswd dbname test&gt;db.sql;</span><br><span class="line"></span><br><span class="line">导出部分字段不为空的数据</span><br><span class="line">#select COUNT(*) from t_user where mobile !=&#x27;&#x27; and real_name !=&#x27;&#x27; and real_name !=&#x27;Null&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="binlog-查看"><a href="#binlog-查看" class="headerlink" title="binlog 查看"></a>binlog 查看</h3><blockquote>
<p>参数说明:<br>-v, –verbose 用于输出基于row模式的binlog日志，<br>-vv 为列数据类型添加注释 –base64-output&#x3D;decode-rows 解码binlog里经过base64编码的内容</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -vv --base64-output=decode-rows  mysql-binlog.xxxx &gt; new.sql</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>pptp vpn 部署脚本</title>
    <url>/pptp%20vpn%20%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC.html</url>
    <content><![CDATA[<p>时间久远，不建议直接使用，仅供参考。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># Interactive pptp vpn  install script for an OpenVZ VPS</span><br><span class="line"># surport  : Cenost ,Fedora  6.x </span><br><span class="line"># Augest 24, 2014 v1.00</span><br><span class="line">#url ：   http://www.dabu.info/?p=2178</span><br><span class="line"></span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Interactive PoPToP Install Script for an OpenVZ VPS&quot;</span><br><span class="line">echo</span><br><span class="line">echo &quot;Make sure to contact your provider and have them enable&quot;</span><br><span class="line">echo &quot;IPtables and ppp modules prior to setting up PoPToP.&quot;</span><br><span class="line">echo &quot;PPP can also be enabled from SolusVM.&quot;</span><br><span class="line">echo</span><br><span class="line">echo &quot;You need to set up the server before creating more users.&quot;</span><br><span class="line">echo &quot;A separate user is required per connection or machine.&quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo</span><br><span class="line">echo</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Select on option:&quot;</span><br><span class="line">echo &quot;1) Set up new PoPToP server AND create one user&quot;</span><br><span class="line">echo &quot;2) Create additional users&quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">read x</span><br><span class="line">if test $x -eq 1; then</span><br><span class="line">echo &quot;Enter username that you want to create (eg. client1 or john):&quot;</span><br><span class="line">read u</span><br><span class="line">echo &quot;Specify password that you want the server to use:&quot;</span><br><span class="line">read p</span><br><span class="line"></span><br><span class="line">## get the VPS IP</span><br><span class="line">#ip=`ifconfig venet0:0 | grep &#x27;inet addr&#x27; | awk &#123;&#x27;print $2&#x27;&#125; | sed s/.*://`</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Downloading and Installing ppp  and   pptpd  &quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">yum   install  ppp   -y</span><br><span class="line">rpm -q|grep epel || rpm -Uvh http://poptop.sourceforge.net/yum/stable/rhel6/pptp-release-current.noarch.rpm</span><br><span class="line">yum    install  pptpd  -y</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Creating Server Config&quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">cp /etc/ppp/options.pptpd /etc/ppp/options.pptpd.bak</span><br><span class="line">sed -i &#x27;70a ms-dns 10.202.72.116&#x27;    /etc/ppp/options.pptpd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># setting up pptpd.conf</span><br><span class="line">sed -i &#x27;101a localip 192.168.9.1&#x27;    /etc/pptpd.conf</span><br><span class="line">sed -i &#x27;102a  remoteip 192.168.9.11-30&#x27;    /etc/pptpd.conf</span><br><span class="line"></span><br><span class="line"># adding new user</span><br><span class="line">echo &quot;$u * $p *&quot; &gt;&gt; /etc/ppp/chap-secrets</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Forwarding IPv4 and Enabling it on boot&quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">cat &gt;&gt; /etc/sysctl.conf &lt;&lt;END</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">END</span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Updating IPtables Routing and Enabling it on boot&quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">iptables -t nat -A POSTROUTING -o eth1 -j  MASQUERADE</span><br><span class="line"># saves iptables routing rules and enables them on-boot</span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/network/if-pre-up.d/iptables &lt;&lt;END</span><br><span class="line">#!/bin/sh</span><br><span class="line">iptables-restore &lt; /etc/sysconfig/iptables</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">chmod +x /etc/network/if-pre-up.d/iptables</span><br><span class="line">cat &gt;&gt; /etc/ppp/ip-up &lt;&lt;END</span><br><span class="line">ifconfig ppp0 mtu 1400</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Restarting PoPToP&quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">sleep 5</span><br><span class="line">/etc/init.d/pptpd restart</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Server setup complete!&quot;</span><br><span class="line">echo &quot;Connect to your VPS at $ip with these credentials:&quot;</span><br><span class="line">echo &quot;Username:$u ##### Password: $p&quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line"></span><br><span class="line"># runs this if option 2 is selected</span><br><span class="line">elif test $x -eq 2; then</span><br><span class="line">echo &quot;Enter username that you want to create (eg. client1 or john):&quot;</span><br><span class="line">read u</span><br><span class="line">echo &quot;Specify password that you want the server to use:&quot;</span><br><span class="line">read p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># adding new user</span><br><span class="line">echo &quot;$u * $p *&quot; &gt;&gt; /etc/ppp/chap-secrets</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line">echo &quot;Addtional user added!&quot;</span><br><span class="line">echo &quot;Connect to your VPS at $ip with these credentials:&quot;</span><br><span class="line">echo &quot;Username:$u ##### Password: $p&quot;</span><br><span class="line">echo &quot;######################################################&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">echo &quot;Invalid selection, quitting.&quot;</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>request_time和upstream_response_time的区别</title>
    <url>/request_time%E5%92%8Cupstream_response_time%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个正常的请求过程如下：</p>
<ol>
<li>用户发出请求</li>
<li>建立NGINX连接</li>
<li>发送响应</li>
<li>接收程序的响应数据</li>
<li>关闭NGINX连接</li>
</ol>
<p><strong>request_time</strong><br>request processing time in seconds with a milliseconds resolution; time elapsed between the first bytes were read from the client and the log write after the last bytes were sent to the client.</p>
<p>指的就是从接受用户请求的第一个字节到发送完响应数据的时间，即包括接收请求数据时间、程序响应时间、输出响应数据时间。<br>对于此部分对应的是1+2+3+4+5。</p>
<p><strong>upstream_response_time</strong><br>keeps times of responses obtained from upstream servers; times are kept in seconds with a milliseconds resolution. Several response times are separated by commas and colons like addresses in the $upstream_addr variable.<br>是指从Nginx向后端（php-cgi)建立连接开始到接受完数据然后关闭连接为止的时间。<br>对于此部分对应的是2+3+4+5。</p>
<p>从上面的描述可以看出，<code>$request_time</code>肯定大于等于<code>$upstream_response_time</code>，特别是使用POST方式传递参数时，因为Nginx会把<code>request body</code>缓存住，接受完毕后才会把数据一起发给后端。所以如果用户网络较差，或者传递数据较大时，<code>$request_time</code>会比<code>$upstream_response_time</code>大很多。</p>
<p>如果要从access_log中查看较慢的接口的话，可以在<code>log_format</code>中加入<code>$upstream_response_time</code>。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>从网上看到下列一组图片，感觉画的很形象。</p>
<ul>
<li><code>request_time</code>是从接收到客户端的第一个字节开始，到把所有的响应数据都发送完为止。<br><img data-src="https://img.econow.cn/medivh/1637907742862.png" alt="1637907742862.png"></li>
<li><code>upstream_response_time</code>是从与后端建立TCP连接开始到接收完响应数据并关闭连接为止。<br><img data-src="https://img.econow.cn/medivh/1637907762851.png" alt="1637907762851.png"></li>
</ul>
<p>所以，<code>request_time</code>会大于等于<code>upstream_response_time</code>。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>对于较高的request—_time很可能是由于连接速度较慢的客户端造成的，对此无能为力，但是较高的request_time并不代表服务器或者程序的性能不够。总体来说，没必要在request_time上花费较多时间，而是应该重点关注upstream_response_time。</p>
<h3 id="nginx-log-format"><a href="#nginx-log-format" class="headerlink" title="nginx log_format"></a>nginx log_format</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$remote_addr</span>,<span class="variable">$http_x_forwarded_for</span>  <span class="comment">#记录客户端IP地址</span></span><br><span class="line"><span class="variable">$remote_user</span>   <span class="comment">#记录客户端用户名称</span></span><br><span class="line"><span class="variable">$request</span>       <span class="comment">#记录请求的URL和HTTP协议</span></span><br><span class="line"><span class="variable">$status</span>        <span class="comment">#记录请求状态</span></span><br><span class="line"><span class="variable">$body_bytes_sent</span>  <span class="comment">#发送给客户端的字节数，不包括响应头的大小；该变量与Apache模块mod_log_config李的“%B”参数兼容</span></span><br><span class="line"><span class="variable">$bytes_sent</span>    <span class="comment">#发送给客户端的总字节数</span></span><br><span class="line"><span class="variable">$connection</span>    <span class="comment">#连接到序列号</span></span><br><span class="line"><span class="variable">$connection_requests</span> <span class="comment">#当前通过一个链接获得的请求数量</span></span><br><span class="line"><span class="variable">$msec</span>       <span class="comment">#日志写入时间，单位为秒精度是毫秒。</span></span><br><span class="line"><span class="variable">$pipe</span>       <span class="comment">#如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”,否则为&quot;.&quot;.</span></span><br><span class="line"><span class="variable">$http_referer</span>  <span class="comment">#记录从那个页面链接访问过来的</span></span><br><span class="line"><span class="variable">$http_user_agent</span>  <span class="comment">#记录客户端浏览器相关信息</span></span><br><span class="line"><span class="variable">$request_length</span>   <span class="comment">#请求的长度（包括请求行，请求头和请求正文）。</span></span><br><span class="line"><span class="variable">$request_time</span> <span class="comment">#请求处理时间，单位为秒，精度毫秒；从读入客户端的第一个字节开始，知道把最后一个字符发送给客户端后进行日志写入位置。</span></span><br><span class="line"><span class="variable">$time_iso8601</span> ISO8601标准格式下的本地时间</span><br><span class="line"><span class="variable">$time_local</span>  <span class="comment">#通用日志格式下的本地时间</span></span><br></pre></td></tr></table></figure>

<h2 id="NGINX的文件传输"><a href="#NGINX的文件传输" class="headerlink" title="NGINX的文件传输"></a>NGINX的文件传输</h2><h3 id="sendile"><a href="#sendile" class="headerlink" title="sendile"></a>sendile</h3><p>参数sendfile on 用于开启文件高效传输模式，同时配合tcp_nopush on 和tcp_nodelay on 两个指令，可防止网络及磁盘I&#x2F;O阻塞，提升Nginx工作效率。但需要注意的是，linux内核版本2.5.9以后的版本中两者是可以兼容的。</p>
<p>三个指令都开启的好处是，sendfile可以开启高效的文件传输模式，tcp_nopush开启可以确保在发送到客户端之前数据包已经充分“填满”， 这大大减少了网络开销，并加快了文件发送的速度。 然后，当它到达最后一个可能因为没有“填满”而暂停的数据包时，Nginx会忽略tcp_nopush参数， 然后，tcp_nodelay强制套接字发送数据。</p>
<p><img data-src="https://img.econow.cn/medivh/1637918539854.png" alt="1637918539854.png"></p>
<h3 id="tcp-nopush"><a href="#tcp-nopush" class="headerlink" title="tcp_nopush"></a>tcp_nopush</h3><p>当有数据时，先别着急发送, 确保数据包已经装满数据, 避免了网络拥塞。需要我们等到数据量达到最大时才通过网络一次发送全部数据，这种数据传输方式有益于大量数据的通信性能，典型的应用就是文件服务器。<br>对于nginx配置文件中的tcp_nopush，默认就是tcp_nopush,不需要特别指定，这个选项对于www，ftp等大文件很有帮助。</p>
<h3 id="tcp-nodelay"><a href="#tcp-nodelay" class="headerlink" title="tcp_nodelay"></a>tcp_nodelay</h3><p>有时要抓紧发货, 确保数据尽快发送, 提高可数据传输效率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>平时对request_time和upstream_response_time这两个参数没什么研究，关注的不多，主要关注request_time。但是最近阿里云的日志服务统计数据出现了异常，request_time和upstream_response_time的值完全违反了字段定义的原则。理论上request_time无论如何也会大于upstream_response_time的，但是客服死活不承认。无奈之下，好好研究一番，通过阿里云官网文档截图和历史正常数据已经现在的异常数据，客服最终承认存在问题，表示整改。<br>事实证明，阿里云的客服技术水平也是良莠不齐。</p>
<p>经过此次事件，也遇到了一些Markdown语法的问题，不过幸运的是vs code提供了很多帮助，能直接定位到问题，而对应的问题都有参考方案。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">ngx_http_log_module</a></li>
<li><a href="https://github.com/DavidAnson/markdownlint/blob/v0.24.0/doc/Rules.md">https://github.com/DavidAnson/markdownlint/blob/v0.24.0/doc/Rules.md</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>一个Flask项目经验总结</title>
    <url>/%E4%B8%80%E4%B8%AAFlask%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h2 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h2><h3 id="Error-While-importing-‘run-app-dev’-an-ImportError-was-raised"><a href="#Error-While-importing-‘run-app-dev’-an-ImportError-was-raised" class="headerlink" title="Error: While importing ‘run_app_dev’, an ImportError was raised"></a>Error: While importing ‘run_app_dev’, an ImportError was raised</h3><p>网上说是循环调用的问题，但这个项目在我笔记本上是可以运行的，怀疑是不是flask的版本问题，因为我直接安装了最新的flask&#x3D;&#x3D;2.0.2，把最新的flask卸载后，安装1.1.2的flask 此问题解决。</p>
<h3 id="当flask-migrate没有MigrateCommand时"><a href="#当flask-migrate没有MigrateCommand时" class="headerlink" title="当flask_migrate没有MigrateCommand时"></a>当flask_migrate没有MigrateCommand时</h3><p>出现这个情况的原因是最新的flask_migrate，已经去除了MigrateCommand，可以直接在命令行中使用,如果需要使用MigrateCommand的话:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可用 pip install flask_migrate==xx 命令</span><br><span class="line">把flask_migrate降低一个版本</span><br><span class="line">这里用的2.7.0版本的把问题解决了</span><br></pre></td></tr></table></figure>

<h3 id="ModuleNotFoundError-No-module-named-‘Crypto’解决方案"><a href="#ModuleNotFoundError-No-module-named-‘Crypto’解决方案" class="headerlink" title="ModuleNotFoundError: No module named ‘Crypto’解决方案"></a>ModuleNotFoundError: No module named ‘Crypto’解决方案</h3><p>方案一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 uninstall pycryptodome</span><br><span class="line">pip3 uninstall crypto</span><br><span class="line">Pip3 install pycrypto</span><br></pre></td></tr></table></figure>

<p>方案二：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Pip3 install pycrypto</span><br><span class="line"><span class="comment">#然后手动修改 site-packages/crypto 目录改为Crypto即可</span></span><br></pre></td></tr></table></figure>

<h3 id="如何转义JSON"><a href="#如何转义JSON" class="headerlink" title="如何转义JSON"></a>如何转义JSON</h3><p>飞书更新的接口文档，要求卡片信息格式必须为转移后的JSON，和普通JSON的区别就是必须加转义符“\”。这个就很麻烦了。<br>实现方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">s1 = &#123;<span class="string">&quot;elements&quot;</span>:[&#123;<span class="string">&quot;content&quot;</span>:<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;tag&quot;</span>:<span class="string">&quot;markdown&quot;</span>&#125;,&#123;<span class="string">&quot;tag&quot;</span>:<span class="string">&quot;hr&quot;</span>&#125;,&#123;<span class="string">&quot;elements&quot;</span>:[&#123;<span class="string">&quot;content&quot;</span>:<span class="string">&quot;hi text&quot;</span>,<span class="string">&quot;tag&quot;</span>:<span class="string">&quot;plain_text&quot;</span>&#125;],<span class="string">&quot;tag&quot;</span>:<span class="string">&quot;note&quot;</span>&#125;]&#125;</span><br><span class="line">s2 = json.dumps(s1)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(s2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="string">&quot;&#123;\&quot;elements\&quot;: [&#123;\&quot;content\&quot;: \&quot;hi\&quot;, \&quot;tag\&quot;: \&quot;markdown\&quot;&#125;, &#123;\&quot;tag\&quot;: \&quot;hr\&quot;&#125;, &#123;\&quot;elements\&quot;: [&#123;\&quot;content\&quot;: \&quot;hi text\&quot;, \&quot;tag\&quot;: \&quot;plain_text\&quot;&#125;], \&quot;tag\&quot;: \&quot;note\&quot;&#125;]&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>简单来说就是通过两次<code>json.dumps()</code>来实现自动增加转义符的。</p>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>在模糊查询的时候经常会遇到字段不确定的情况，因此使用原生SQL更为简单，并且能结合模糊查询来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> request.args.get(<span class="string">&#x27;key&#x27;</span>) <span class="keyword">and</span> request.args.get(<span class="string">&#x27;value&#x27;</span>):</span><br><span class="line">    sql = <span class="string">&quot;&quot;&quot;select * from user where %s like &#x27;%s&#x27;&quot;&quot;&quot;</span> % (key, <span class="string">&quot;%&quot;</span> + value + <span class="string">&quot;%&quot;</span>)</span><br><span class="line">    c = db.session.execute(sql).fetchall()</span><br><span class="line">    <span class="keyword">if</span> c:</span><br><span class="line">        res_obj = c[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res_obj = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>单独动态查询的话也容易实现，但是模糊查询不太容易结合，只能使用下面的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = &#123;key: value&#125;</span><br><span class="line">res_obj = db.session.query(User).filter_by(**params).<span class="built_in">all</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二次优化"><a href="#二次优化" class="headerlink" title="二次优化"></a>二次优化</h4><p>将查询记录转变为非list类型的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;&quot;&quot;select * from user where %s like &#x27;%s&#x27;&quot;&quot;&quot;</span> % (key, <span class="string">&quot;%&quot;</span> + value + <span class="string">&quot;%&quot;</span>)</span><br><span class="line">c = db.session.execute(sql).fetchall()</span><br><span class="line"><span class="keyword">if</span> c:</span><br><span class="line">    res_obj = <span class="built_in">tuple</span>(c)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    res_obj = <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增加判断条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> <span class="built_in">isinstance</span>(res, <span class="built_in">tuple</span>):  <span class="comment"># 针对于模糊查询的情况</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> res:</span><br><span class="line">        lst.append(<span class="built_in">dict</span>(<span class="built_in">zip</span>(col.keys(), col)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当为tuple类型的时候，单独处理，独立于之前的list处理模式。</p>
<h3 id="flask-apscheduler-上下文的问题"><a href="#flask-apscheduler-上下文的问题" class="headerlink" title="flask_apscheduler 上下文的问题"></a>flask_apscheduler 上下文的问题</h3><p>最近调试apscheduler的时候出现以下的错误：</p>
<blockquote>
<p>RuntimeError: Working outside of application context.<br>This typically means that you attempted to use functionality that needed to interface with the current application object in some way. To solve this, set up an application context with app.app_context().  See the documentation for more information.</p>
</blockquote>
<p>其主要原因是由于调用到了公共变量，而flask引入了应用上下文管理，但是并没有获取到上下文导致。<br>解决方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> scheduler</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncAssets</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    同步资产信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> scheduler.app.app_context():</span><br><span class="line">            access_key_id = current_app.config.get(<span class="string">&#x27;ALI_KEY_ID&#x27;</span>)</span><br><span class="line">            access_key = current_app.config.get(<span class="string">&#x27;ALI_KEY&#x27;</span>)</span><br><span class="line">            access_r = current_app.config.get(<span class="string">&#x27;ALI_R&#x27;</span>)</span><br><span class="line">            self.client = AcsClient(access_key_id, access_key, access_r)</span><br></pre></td></tr></table></figure>

<h3 id="vue-时间格式化的问题"><a href="#vue-时间格式化的问题" class="headerlink" title="vue 时间格式化的问题"></a>vue 时间格式化的问题</h3><p>时间格式化处理使用moment.js。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install moment</span><br></pre></td></tr></table></figure>

<p>需要注意在格式化时间戳的时候检查是多少位，考虑是否除以1000和UTC的问题。</p>
<ul>
<li><a href="http://momentjs.cn/">http://momentjs.cn</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>一个伤心的事</title>
    <url>/%E4%B8%80%E4%B8%AA%E4%BC%A4%E5%BF%83%E7%9A%84%E4%BA%8B.html</url>
    <content><![CDATA[<p>昨天发生了一件不太美好的事，我把自己的md文件都给删除啦。本来思考着要不要恢复它，但是一想，就给自己留个教训吧。<br>不是所有的事情都可以后悔！！！</p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Cloudera部署和管理hadoop集群</title>
    <url>/%E4%BD%BF%E7%94%A8Cloudera%E9%83%A8%E7%BD%B2%E5%92%8C%E7%AE%A1%E7%90%86hadoop%E9%9B%86%E7%BE%A4.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Cloude Manager 概述：</p>
<p>CDH 是 Cloudera 公司对整体 hadoop 集群环境进行监控与管理的企业级大数据管理平台。</p>
<p>Cloudera Manager 分为：</p>
<p>Cloudera Manager Server：对整个集群提供监控与管理操作。Cloudera Manager Server 通过部署在不同设备上的 Cloudera Manager Agent 进行管理整体集群。Cloudera Manager Server 需要部署在一台设备上。</p>
<p>Cloudera Manager Agent：部署在每个需要监控与管理的设备上。负责采集运行数据与执行下发的管理命令。</p>
<p>DataBase：关系型数据库是 Cloudera Manager 执行管理操作时，存储整体集群情况数据</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先安装 Cloudrea Manager，再通过 Cloudrea Manager 在节点上安装 Cloudrea Manager 客户端，CDH，管理工具。<br><a href="https://www.cloudera.com/documentation/manager/5-1-x.html">官方文档</a></p>
<h3 id="一、环境需求"><a href="#一、环境需求" class="headerlink" title="一、环境需求:"></a>一、环境需求:</h3><ul>
<li>关闭 selinux</li>
<li>各节点可以 SSH 登陆</li>
<li>在&#x2F;etc&#x2F;hosts 中添加各节点的主机名</li>
</ul>
<h3 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h3><p>1、修改以下参数，否则检查主机正确性时会出现 “已启用“透明大页面”，它可能会导致重大的性能问题。” 的警告</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"></span><br><span class="line"># vi /etc/rc.local</span><br><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure>

<p>2、取代默认 JDK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/java</span><br><span class="line">ln -s /usr/local/jdk1.8.0_91/ /usr/java/default</span><br></pre></td></tr></table></figure>

<p>因为默认情况下安装 Cloudrea Manager 的时候会自动安装一个 JDK7，所以在这里提前替换一下。如果之后检查的时候不生效，注意删除 JDK7，然后重启服务。正常的目录如下：<br><img data-src="https://img.econow.cn/medivh/1550050311058.png" /></p>
<h3 id="三、安装-Cloudrea-Manager"><a href="#三、安装-Cloudrea-Manager" class="headerlink" title="三、安装 Cloudrea Manager"></a>三、安装 Cloudrea Manager</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget http://archive.cloudera.com/cm5/installer/latest/cloudera-manager-installer.bin</span><br><span class="line">chmod +x cloudera-manager-installer.bin</span><br><span class="line">./cloudera-manager-installer.bin</span><br></pre></td></tr></table></figure>

<p>然后会出现以下画面，点击 Next 或者<Yes>,开始安装<br><img data-src="https://img.econow.cn/medivh/1550039104564.png" /></p>
<img data-src="https://img.econow.cn/medivh/1550039166335.png" />
最后安装完成，提示访问7180端口,账号密码都是admin
<img data-src="https://img.econow.cn/medivh/1550039183944.png" />

<h3 id="四、数据库准备工作"><a href="#四、数据库准备工作" class="headerlink" title="四、数据库准备工作"></a>四、数据库准备工作</h3><h4 id="1-Mysql-Install"><a href="#1-Mysql-Install" class="headerlink" title="1. Mysql Install"></a>1. Mysql Install</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -Uvh  http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>

<h4 id="2-Installing-the-MySQL-JDBC-Driver"><a href="#2-Installing-the-MySQL-JDBC-Driver" class="headerlink" title="2. Installing the MySQL JDBC Driver"></a>2. Installing the MySQL JDBC Driver</h4><p>If you already have the JDBC driver installed on the hosts that need it, you can skip this section. However, MySQL 5.6 requires a 5.1 driver version 5.1.26 or higher.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/src</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.46.tar.gz</span><br><span class="line">tar zxvf mysql-connector-java-5.1.46.tar.gz</span><br><span class="line">mkdir -pv /usr/share/java</span><br><span class="line">cd mysql-connector-java-5.1.46</span><br><span class="line">sudo cp mysql-connector-java-5.1.46-bin.jar /usr/share/java/mysql-connector-java.jar</span><br></pre></td></tr></table></figure>

<h4 id="3-Creating-Databases-for-Cloudera-Software"><a href="#3-Creating-Databases-for-Cloudera-Software" class="headerlink" title="3. Creating Databases for Cloudera Software"></a>3. Creating Databases for Cloudera Software</h4><p>以下数据库名称仅供参考，只要匹配得上就行<br><img data-src="https://img.econow.cn/medivh/1550139934136.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">&gt; create database scm;</span><br><span class="line">&gt; grant all on *.* to &#x27;scm&#x27;@&#x27;%&#x27; identified by &#x27;scm&#x27; with grant option;</span><br><span class="line">&gt; create database hive_metastore;</span><br><span class="line">&gt; grant all on hive_metastore.* to &#x27;hive&#x27;@&#x27;%&#x27; identified by &#x27;hive&#x27; with grant option;</span><br><span class="line">&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<h4 id="4-Set-up-the-Cloudera-Manager-Database"><a href="#4-Set-up-the-Cloudera-Manager-Database" class="headerlink" title="4. Set up the Cloudera Manager Database"></a>4. Set up the Cloudera Manager Database</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/cloudera/cm/schema/scm_prepare_database.sh  mysql cm -hlocalhost -uscm -pscm --scm-host localhost scm scm scm</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cloudera.com/documentation/enterprise/latest/topics/prepare_cm_database.html">详细参数参考</a></p>
<h3 id="五、安装-Cloudrea-Agent"><a href="#五、安装-Cloudrea-Agent" class="headerlink" title="五、安装 Cloudrea Agent"></a>五、安装 Cloudrea Agent</h3><h4 id="1-搜索主机"><a href="#1-搜索主机" class="headerlink" title="1.搜索主机"></a>1.搜索主机</h4><img data-src="https://img.econow.cn/medivh/1550039268472.png" />
注意搜索的时候主机名以逗号隔开，选择后点击继续。
#### 2.选择版本
选择使用Parcel安装，选择CDH版本,默认即可
<img data-src="https://img.econow.cn/medivh/1550039358949.png" />
然后选择是否安装JDK，如果已经安装了，这里就不需要勾选
<img data-src="https://img.econow.cn/medivh/1550039397866.png" />
#### 3.授权
默认使用root用户，提供公钥或者密码来授权连接
<img data-src="https://img.econow.cn/medivh/1550039466326.png" />
选择继续安装
<img data-src="https://img.econow.cn/medivh/1550039533173.png" />
如果安装过程中，下载安装jdk 或 cloudera-manager-agent失败，可以在节点上手动安装，然后再在Cloudrea  Manager上继续安装。此处的JDK只是为了启动CM，和以后要用的JDK不是一回事！

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install jdk</span><br><span class="line">yum -y install oracle-j2sdk1.7</span><br><span class="line">yum -y install cloudera-manager-agent</span><br></pre></td></tr></table></figure>

<h4 id="4-分配-Parcelf"><a href="#4-分配-Parcelf" class="headerlink" title="4.分配 Parcelƒ"></a>4.分配 Parcelƒ</h4><p>下载 Parcel 并分配 Parcel 到各节点</p>
<img data-src="https://img.econow.cn/medivh/1550039893581.png" />

<p>注意如果下载完后长时间不动，检查日志</p>
<p>分配完成后点击继续，进行主机检查<br><img data-src="https://img.econow.cn/medivh/1550050454788.png" /><br>标注的为有可能出现问题的地方。解决后，选择重新检查即可。如果验证部分通过，下面的版本部分出现不适用也可以忽略。</p>
<h3 id="六、添加-Services"><a href="#六、添加-Services" class="headerlink" title="六、添加 Services"></a>六、添加 Services</h3><h4 id="1-选择服务"><a href="#1-选择服务" class="headerlink" title="1.选择服务"></a>1.选择服务</h4><img data-src="https://img.econow.cn/medivh/1550140558695.png" />
此处会有add 的选项，点击

<p>根据个人需求选择安装服务类型，也可以 选择自定义<br><img data-src="https://img.econow.cn/medivh/1550197444765.png" /></p>
<blockquote>
<p>The Select Services page allows you to select the services you want to install and configure. Make sure that you have the appropriate license key for the services you want to use. You can choose from Cloudera Essentials, Data Engineering, Analytic Database, Operational Database, All Services, and Custom Services. To include Cloudera Navigator data management, check the box labeled Include Cloudera Navigator.</p>
</blockquote>
<p>服务选择页面允许你选择你想要的服务，然后选择继续。</p>
<blockquote>
<p>After selecting the services you want to add, click Continue. The Assign Roles page displays.</p>
</blockquote>
<h4 id="2-Assign-Roles-角色分配"><a href="#2-Assign-Roles-角色分配" class="headerlink" title="2.Assign Roles 角色分配"></a>2.Assign Roles 角色分配</h4><blockquote>
<p>The Assign Roles page suggests role assignments for the hosts in your cluster. You can click on the hostname for a role to select a different host. You can also click the View By Host button to see all the roles assigned to a host.<br>To review the recommended role assignments, see Recommended Cluster Hosts and Role Distribution.<br>After assigning all of the roles for your services, click Continue. The Setup Database page displays.</p>
</blockquote>
<p>简单说就是根据实际情况来分配对应角色。<br><img data-src="https://img.econow.cn/medivh/1550197498148.png" /></p>
<p><a href="https://www.cloudera.com/documentation/enterprise/latest/topics/cm_ig_host_allocations.html#host_role_assignments">官网推荐分配策略参考</a><br>下面分别列出 3-10 和 3-20 台服务器的建议<br><img data-src="https://img.econow.cn/medivh/1550196758734.png" /></p>
<img data-src="https://img.econow.cn/medivh/1550196815297.png" />
下图为实际情况5个节点的分配
<img data-src="https://img.econow.cn/medivh/1550196894404.png" />
#### 3.Setup Database
>On the Setup Database page, you can enter the database names, usernames, and passwords you created in Step 4: Install and Configure Databases.
现在开始填写数据库信息，地址、账号和密码，就是之前准备环境的时候创建的库。
>Select the database type and enter the database name, username, and password for each service. Click Test Connection to validate the settings. If the connection is successful, a green checkmark and the word Successful appears next to each service. If there are any problems, the error is reported next to the service that failed to connect.

<blockquote>
<p>After verifying that each connection is successful, click Continue. The Review Changes page displays.</p>
</blockquote>
<img data-src="https://img.econow.cn/medivh/1550197550054.png" />
注意选择Mysql！填写完成后记得验证一下。下面的库就是之前创建好的
<img data-src="https://img.econow.cn/medivh/1550197181087.png" />
现在表是空的，之后就会创建以下的表
<img data-src="https://img.econow.cn/medivh/1550197226238.png" />
#### 4.启动服务
<img data-src="https://img.econow.cn/medivh/1550197594729.png" />
一般情况下除了hive以外，其他的服务都会正常启动。这个时候就要去修改以下hive配置。另外开一个页面，按照截图修改！
<img data-src="https://img.econow.cn/medivh/1550197756375.png" />
这样之前的hive元数据库就会自动创建表了。

<h2 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h2><h3 id="1-服务状态验证"><a href="#1-服务状态验证" class="headerlink" title="1.服务状态验证"></a>1.服务状态验证</h3><img data-src="https://img.econow.cn/medivh/1550197833064.png" />
这样所有的服务都绿了。
### 2.主机状态
<img data-src="https://img.econow.cn/medivh/1550198340635.png" />
状态正常，且心跳时间小于15秒
### 3.1任务测试一
登任意主机，执行下面任务（用Hadoop计算PI值，圆周率）
10指的是要运行10次map任务，10000指的是每个map任务，要投掷多少次，2个参数的乘积就是总的投掷次数。 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop jar /opt/cloudera/parcels/CDH/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar pi 10 10000</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1550198625749.png" />
然后在群集-》Cluster1-》Yarn-》应用程序查看执行结果
<img data-src="https://img.econow.cn/medivh/1550199361878.png" />

<p>执行结果：<br><img data-src="https://img.econow.cn/medivh/1550198647297.png" /></p>
<h4 id="3-2-任务测试二"><a href="#3-2-任务测试二" class="headerlink" title="3.2 任务测试二"></a>3.2 任务测试二</h4><p>1.编辑一段文本，示例如下；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aslkl hello</span><br><span class="line">hah</span><br><span class="line">hah</span><br><span class="line">hi</span><br><span class="line">en</span><br><span class="line">word</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>2.上传文件到 hdfs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop fs -mkdir /test</span><br><span class="line">#如果提示没有权限，记得修改一下</span><br><span class="line">hadoop fs -chmod 777 -R /</span><br><span class="line">hadoop fs -put s.txt  /test</span><br><span class="line">#上传</span><br><span class="line">hadoop jar /opt/cloudera/parcels/CDH/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar wordcount /test/s.txt /out/</span><br><span class="line">#执行</span><br><span class="line">hadoop fs -text  /out/*</span><br><span class="line">#查看结果</span><br></pre></td></tr></table></figure>

<h4 id="4-1-MapReduce-测试"><a href="#4-1-MapReduce-测试" class="headerlink" title="4.1 MapReduce 测试"></a>4.1 MapReduce 测试</h4><p>创建表<br><img data-src="https://img.econow.cn/medivh/1550202246962.png" /><br>执行操作<br><img data-src="https://img.econow.cn/medivh/1550202281115.png" /><br>OK！</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-优化访问速度"><a href="#1-优化访问速度" class="headerlink" title="1.优化访问速度"></a>1.优化访问速度</h3><img data-src="https://img.econow.cn/medivh/1550199570686.png" />
### 2.部分命令
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service cloudera-scm-server stop </span><br><span class="line">service cloudera-scm-server-db stop</span><br><span class="line">#内置PostgreSQL</span><br><span class="line">service cloudera-scm-agent stop</span><br></pre></td></tr></table></figure>
### 3.邮件报警
#### 1.配置邮箱
点击 cloudera manager service 
<img data-src="https://img.econow.cn/medivh/1550394449078.png" />
点击配置，搜索alert，根据实际情况填写邮箱信息。注意区分25和465端口，并且保证邮箱地址正确。
<img data-src="https://img.econow.cn/medivh/1550394622296.png" />
页眉和页脚随意修改
<img data-src="https://img.econow.cn/medivh/1550394734754.png" />
修改完成后点击保存，然后重启！

<h4 id="2-测试邮件"><a href="#2-测试邮件" class="headerlink" title="2.测试邮件"></a>2.测试邮件</h4><img data-src="https://img.econow.cn/medivh/1550394787512.png" />
点击发送测试即可
<img data-src="https://img.econow.cn/medivh/1550394808019.png" />
这样就收到了测试邮件。
<img data-src="https://img.econow.cn/medivh/1550394890160.png" />
#### 3.可能出现的问题
* 日志报localhost和25端口 
<img data-src="https://img.econow.cn/medivh/1550395083684.png" />
原因是修改配置后没有重启cloudera manager service 
* QQ邮箱报535错误
<img data-src="https://img.econow.cn/medivh/1550394953596.png" />
检查用户名和授权码是否正确。注意QQ邮箱的是授权码不是纯粹的密码
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python smtplib 发送邮件</title>
    <url>/%E4%BD%BF%E7%94%A8Python%20smtplib%20%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。<br>Python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件。</p>
<h3 id="sample-1-发送文本邮件"><a href="#sample-1-发送文本邮件" class="headerlink" title="sample 1.发送文本邮件"></a>sample 1.发送文本邮件</h3><h4 id="构造MIMEText"><a href="#构造MIMEText" class="headerlink" title="构造MIMEText"></a>构造MIMEText</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">msg = MIMEText(&#x27;hello, send by Python...&#x27;, &#x27;plain&#x27;, &#x27;utf-8&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意到构造MIMEText对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入’plain’表示纯文本，最终的MIME就是’text&#x2F;plain’，最后一定要用utf-8编码保证多语言兼容性。</p>
<h4 id="使用smtp发送"><a href="#使用smtp发送" class="headerlink" title="使用smtp发送"></a>使用smtp发送</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 输入Email地址和口令:</span><br><span class="line">from_addr = xxx@x.com</span><br><span class="line">password = xxxxxxx</span><br><span class="line"># 输入收件人地址:</span><br><span class="line">to_addr = xxx@xx.com</span><br><span class="line"># 输入SMTP服务器地址，以QQ企业邮箱为例</span><br><span class="line">smtp_server = smtp.exmail.qq.com</span><br><span class="line">def _format_addr(s):</span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))</span><br><span class="line"></span><br><span class="line">msg = MIMEText(&#x27;hello, send by Python...&#x27;, &#x27;plain&#x27;, &#x27;utf-8&#x27;)</span><br><span class="line">msg[&#x27;From&#x27;] = _format_addr(&#x27;Python爱好者 &lt;%s&gt;&#x27; % from_addr)</span><br><span class="line">msg[&#x27;To&#x27;] = _format_addr(&#x27;管理员 &lt;%s&gt;&#x27; % to_addr)</span><br><span class="line">msg[&#x27;Cc&#x27;] = _format_addr(&#x27;其他成员 &lt;%s&gt;&#x27; % to_addr)</span><br><span class="line">msg[&#x27;Subject&#x27;] = Header(&#x27;来自SMTP的问候……&#x27;, &#x27;utf-8&#x27;).encode()</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP_SSL(smtp_server, 465)  # SMTP SSL协议默认端口是465，注意使用SMTP_SSL</span><br><span class="line">#server = smtplib.SMTP(smtp_server, 25)  # 25端口的话注意使用SMTP</span><br><span class="line">server.set_debuglevel(1)</span><br><span class="line">try:</span><br><span class="line">    server.login(from_addr, password)</span><br><span class="line">    print(&#x27;ok&#x27;)</span><br><span class="line">    server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">    server.quit()</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>编写了一个函数<code>_format_addr()</code>来格式化一个邮件地址。注意不能简单地传入<code>name &lt;addr@example.com&gt;</code>，因为如果包含中文，需要通过<code>Header</code>对象进行编码。<code>msg[&#39;To&#39;]</code>接收的是字符串而不是<code>list</code>，如果有多个邮件地址，用,分隔即可。</p>
</li>
<li><p>用<code>set_debuglevel(1)</code>就可以打印出和SMTP服务器交互的所有信息。SMTP协议就是简单的文本命令和响应。<code>login()</code>方法用来登录SMTP服务器，<code>sendmail()</code>方法就是发邮件，由于可以一次发给多个人，所以传入一个<code>list</code>，邮件正文是一个<code>str</code>，<code>as_string()</code>把<code>MIMEText</code>对象变成<code>str</code>。</p>
</li>
<li><p><code>From</code>:发件人</p>
</li>
<li><p><code>To</code>:收件人</p>
</li>
<li><p><code>Cc</code>:抄送人</p>
</li>
<li><p><code>Subject</code>：主题</p>
</li>
<li><p>此处必须注意<code>smtplib.SMTP_SSL</code>和<code>smtplib.SMTP</code>的区分，否则会报错提示连接失败。</p>
</li>
</ul>
<p>这样我们就收到了一封测试邮件。</p>
<img data-src="https://img.econow.cn/medivh/1550985997669.png" />

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 _*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author:medivh</span><br><span class="line">@file: ex_send_mail.py</span><br><span class="line">@time: 2019/02/24</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email import encoders</span><br><span class="line">from email.header import Header</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.utils import parseaddr, formataddr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _format_addr(s):</span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输入Email地址和口令:</span><br><span class="line">from_addr = xxx@x.com</span><br><span class="line">password = xxxxxxx</span><br><span class="line"># 输入收件人地址:</span><br><span class="line">to_addr = xxx@xx.com</span><br><span class="line"># 输入SMTP服务器地址，以QQ企业邮箱为例</span><br><span class="line">smtp_server = smtp.exmail.qq.com</span><br><span class="line"></span><br><span class="line">msg = MIMEText(&#x27;hello, send by Python...&#x27;, &#x27;plain&#x27;, &#x27;utf-8&#x27;)</span><br><span class="line">msg[&#x27;From&#x27;] = _format_addr(&#x27;Python爱好者 &lt;%s&gt;&#x27; % from_addr)</span><br><span class="line">msg[&#x27;To&#x27;] = _format_addr(&#x27;管理员 &lt;%s&gt;&#x27; % to_addr)</span><br><span class="line">msg[&#x27;Cc&#x27;] = _format_addr(&#x27;其他成员 &lt;%s&gt;&#x27; % to_addr)</span><br><span class="line">msg[&#x27;Subject&#x27;] = Header(&#x27;来自SMTP的问候……&#x27;, &#x27;utf-8&#x27;).encode()</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP_SSL(smtp_server, 465)  # SMTP SSL协议默认端口是465，注意使用SMTP_SSL</span><br><span class="line">#server = smtplib.SMTP(smtp_server, 25)  # 25端口的话注意使用SMTP</span><br><span class="line">server.set_debuglevel(1)</span><br><span class="line">try:</span><br><span class="line">    server.login(from_addr, password)</span><br><span class="line">    print(&#x27;ok&#x27;)</span><br><span class="line">    server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">    server.quit()</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="samele-2-附件邮件"><a href="#samele-2-附件邮件" class="headerlink" title="samele 2.附件邮件"></a>samele 2.附件邮件</h3><p>如果Email中要加上附件怎么办？带附件的邮件可以看做包含若干部分的邮件：文本和各个附件本身，所以，可以构造一个MIMEMultipart对象代表邮件本身，然后往里面加上一个MIMEText作为邮件正文，再继续往里面加上表示附件的MIMEBase对象即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 邮件对象:</span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[&#x27;From&#x27;] = _format_addr(&#x27;Python爱好者 &lt;%s&gt;&#x27; % from_addr)</span><br><span class="line">msg[&#x27;To&#x27;] = _format_addr(&#x27;管理员 &lt;%s&gt;&#x27; % to_addr)</span><br><span class="line">msg[&#x27;Subject&#x27;] = Header(&#x27;来自SMTP的问候……&#x27;, &#x27;utf-8&#x27;).encode()</span><br><span class="line">msg_text = &#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&#x27; + &#x27;&lt;p&gt;send by &lt;a href=&quot;http://www.econow.cn&quot;&gt;Python&lt;/a&gt;...&lt;/p&gt;&#x27; + &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;</span><br><span class="line">msg.attach(MIMEText(msg, &#x27;html&#x27;, &#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line"># 添加附件就是加上一个MIMEBase，从本地读取一个图片:</span><br><span class="line">with open(&#x27;./hi.png&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    # 设置附件的MIME和文件名，这里是png类型:</span><br><span class="line">    FileApart = MIMEApplication(f.read())</span><br><span class="line">    FileApart.add_header(&#x27;Content-Disposition&#x27;, &#x27;attachment&#x27;, filename=&#x27;hi.png&#x27;)</span><br><span class="line">    msg.attach(FileApart)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img data-src="https://img.econow.cn/medivh/1550987252487.png" />

<h3 id="sample-3-html-邮件"><a href="#sample-3-html-邮件" class="headerlink" title="sample 3.html 邮件"></a>sample 3.html 邮件</h3><p>在构造MIMEText对象时，把HTML字符串传进去，再把第二个参数由plain变为html就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">msg = MIMEText(&#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&#x27; +</span><br><span class="line">    &#x27;&lt;p&gt;send by &lt;a href=&quot;http://www.econow.cn&quot;&gt;Python&lt;/a&gt;...&lt;/p&gt;&#x27; +</span><br><span class="line">    &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;, &#x27;html&#x27;, &#x27;utf-8&#x27;)</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1550986154659.png" />
### samele 3.图片邮件
要把图片嵌入到邮件正文中，我们只需按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用src="cid:0"就可以把附件作为图片嵌入了。如果有多个图片，给它们依次编号，然后引用不同的cid:x即可。
事实上，无论图片还是音频文件,使用方式都是一样的。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msgText = &#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&#x27; + &#x27;&lt;p&gt;&lt;img src=&quot;cid:0&quot;&gt;&lt;/p&gt;&#x27; + &#x27;&lt;p&gt;send by &lt;a href=&quot;http://www.econow.cn&quot;&gt;Python&lt;/a&gt;...&lt;/p&gt;&#x27; + &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;</span><br><span class="line"></span><br><span class="line"># 添加附件就是加上一个MIMEImage，从本地读取一个图片:</span><br><span class="line">with open(&#x27;./hi.png&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    # 设置附件的MIME和文件名，这里是png类型:</span><br><span class="line">    FileApart = MIMEImage(f.read())</span><br><span class="line">    FileApart.add_header(&#x27;Content-ID&#x27;, &#x27;&lt;0&gt;&#x27;)</span><br><span class="line">    msg.attach(FileApart)</span><br></pre></td></tr></table></figure>
<img data-src="https://img.econow.cn/medivh/1550988329662.png" />

<p>全部代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 _*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author:medivh</span><br><span class="line">@file: ex_send_mail.py</span><br><span class="line">@time: 2019/02/24</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.mime.multipart import MIMEMultipart</span><br><span class="line">from email.mime.application import MIMEApplication</span><br><span class="line">from email.mime.image import MIMEImage</span><br><span class="line">from email.header import Header</span><br><span class="line">from email.utils import parseaddr, formataddr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _format_addr(s):</span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    return formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输入Email地址和口令:</span><br><span class="line">from_addr = xxx@x.com</span><br><span class="line">password = xxxx</span><br><span class="line"># 输入收件人地址:</span><br><span class="line">to_addr = xx@xx.com</span><br><span class="line"># 输入SMTP服务器地址，以QQ企业邮箱为例</span><br><span class="line">smtp_server = &#x27;smtp.exmail.qq.com&#x27;</span><br><span class="line"></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[&#x27;From&#x27;] = _format_addr(&#x27;Python爱好者 &lt;%s&gt;&#x27; % from_addr)</span><br><span class="line">msg[&#x27;To&#x27;] = _format_addr(&#x27;管理员 &lt;%s&gt;&#x27; % to_addr)</span><br><span class="line">msg[&#x27;Subject&#x27;] = Header(&#x27;来自SMTP的问候……&#x27;, &#x27;utf-8&#x27;).encode()</span><br><span class="line">msgText = &#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&#x27; + &#x27;&lt;p&gt;&lt;img src=&quot;cid:0&quot;&gt;&lt;/p&gt;&#x27; + &#x27;&lt;p&gt;send by &lt;a href=&quot;http://www.econow.cn&quot;&gt;Python&lt;/a&gt;...&lt;/p&gt;&#x27; + &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;</span><br><span class="line">msg.attach(MIMEText(msgText, &#x27;html&#x27;, &#x27;utf-8&#x27;))</span><br><span class="line"># 添加附件就是加上一个MIMEImage，从本地读取一个图片:</span><br><span class="line">with open(&#x27;./hi.png&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    # 设置附件的MIME和文件名，这里是png类型:</span><br><span class="line">    FileApart = MIMEImage(f.read())</span><br><span class="line">    FileApart.add_header(&#x27;Content-ID&#x27;, &#x27;&lt;0&gt;&#x27;)</span><br><span class="line">    msg.attach(FileApart)</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP_SSL(smtp_server, 465)  # SMTP SSL协议默认端口是465，注意使用SMTP_SSL</span><br><span class="line">server.set_debuglevel(3)</span><br><span class="line">try:</span><br><span class="line">    server.login(from_addr, password)</span><br><span class="line">    server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">    server.quit()</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h3><h4 id="通用类型"><a href="#通用类型" class="headerlink" title="通用类型"></a>通用类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class email.mime.application.MIMEApplication(_data, _subtype=&#x27;octet-stream&#x27;, _encoder=email.encoders.encode_base64, *, policy=compat32, **_params)</span><br><span class="line">Module: email.mime.application</span><br><span class="line"></span><br><span class="line">    A subclass of MIMENonMultipart, the MIMEApplication class is used to represent MIME message objects of major type application. _data is a string containing the raw byte data. Optional _subtype specifies the MIME subtype and defaults to octet-stream.</span><br><span class="line"></span><br><span class="line">    Optional _encoder is a callable (i.e. function) which will perform the actual encoding of the data for transport. This callable takes one argument, which is the MIMEApplication instance. It should use get_payload() and set_payload() to change the payload to encoded form. It should also add any Content-Transfer-Encoding or other headers to the message object as necessary. The default encoding is base64. See the email.encoders module for a list of the built-in encoders.</span><br><span class="line"></span><br><span class="line">    Optional policy argument defaults to compat32.</span><br><span class="line"></span><br><span class="line">    _params are passed straight through to the base class constructor.</span><br><span class="line"></span><br><span class="line">    Changed in version 3.6: Added policy keyword-only parameter.</span><br></pre></td></tr></table></figure>
<h4 id="音频类型"><a href="#音频类型" class="headerlink" title="音频类型"></a>音频类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class email.mime.audio.MIMEAudio(_audiodata, _subtype=None, _encoder=email.encoders.encode_base64, *, policy=compat32, **_params)¶</span><br><span class="line">    Module: email.mime.audio</span><br><span class="line"></span><br><span class="line">    A subclass of MIMENonMultipart, the MIMEAudio class is used to create MIME message objects of major type audio. _audiodata is a string containing the raw audio data. If this data can be decoded by the standard Python module sndhdr, then the subtype will be automatically included in the Content-Type header. Otherwise you can explicitly specify the audio subtype via the _subtype argument. If the minor type could not be guessed and _subtype was not given, then TypeError is raised.</span><br><span class="line"></span><br><span class="line">    Optional _encoder is a callable (i.e. function) which will perform the actual encoding of the audio data for transport. This callable takes one argument, which is the MIMEAudio instance. It should use get_payload() and set_payload() to change the payload to encoded form. It should also add any Content-Transfer-Encoding or other headers to the message object as necessary. The default encoding is base64. See the email.encoders module for a list of the built-in encoders.</span><br><span class="line"></span><br><span class="line">    Optional policy argument defaults to compat32.</span><br><span class="line"></span><br><span class="line">    _params are passed straight through to the base class constructor.</span><br><span class="line"></span><br><span class="line">    Changed in version 3.6: Added policy keyword-only parameter.</span><br></pre></td></tr></table></figure>
<h4 id="图片类型"><a href="#图片类型" class="headerlink" title="图片类型"></a>图片类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class email.mime.image.MIMEImage(_imagedata, _subtype=None, _encoder=email.encoders.encode_base64, *, policy=compat32, **_params)</span><br><span class="line">    Module: email.mime.image</span><br><span class="line"></span><br><span class="line">    A subclass of MIMENonMultipart, the MIMEImage class is used to create MIME message objects of major type image. _imagedata is a string containing the raw image data. If this data can be decoded by the standard Python module imghdr, then the subtype will be automatically included in the Content-Type header. Otherwise you can explicitly specify the image subtype via the _subtype argument. If the minor type could not be guessed and _subtype was not given, then TypeError is raised.</span><br><span class="line"></span><br><span class="line">    Optional _encoder is a callable (i.e. function) which will perform the actual encoding of the image data for transport. This callable takes one argument, which is the MIMEImage instance. It should use get_payload() and set_payload() to change the payload to encoded form. It should also add any Content-Transfer-Encoding or other headers to the message object as necessary. The default encoding is base64. See the email.encoders module for a list of the built-in encoders.</span><br><span class="line"></span><br><span class="line">    Optional policy argument defaults to compat32.</span><br><span class="line"></span><br><span class="line">    _params are passed straight through to the MIMEBase constructor.</span><br><span class="line"></span><br><span class="line">    Changed in version 3.6: Added policy keyword-only parameter.</span><br></pre></td></tr></table></figure>
<p>综上所述，如果想不起来啥类型就使用<code>MIMEApplication</code>。</p>
<p>参考资料：<a href="https://docs.python.org/3/library/email.mime.html">https://docs.python.org/3/library/email.mime.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python+Alfred-Workflow开发一个翻译插件</title>
    <url>//%E4%BD%BF%E7%94%A8Python+Alfred-Workflow%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install Alfred-Workflow</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">pip install --target=. Alfred-Workflow</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只支持Python2版本，Python3的话需要考虑兼容问题。</p>
</blockquote>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>有个1.40.0 版本的较为新一点 <a href="https://files.pythonhosted.org/packages/a7/65/636e999af8a5f8a9642b19a0875799629cfbdf28cba441bb2f9107816b3f/Alfred-Workflow-1.40.0.tar.gz">Alfred-Workflow-1.40.0.tar.gz</a></p>
<h3 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h3><p>这个库是使用 Python2 写的，直接在 Python3 上使用会有问题，如果你习惯使用 Python3，可以有一些办法做一些兼容。</p>
<p>基础准备如下：</p>
<ol>
<li>首先在使用 pip 安装时，要记得选择使用 Python2 安装</li>
<li>跟 Workflow 相关的操作放在一个文件里（称为 a.py），使用 Python2 作为解释器</li>
<li>把真正的逻辑放到另一个文件里（称为 b.py），使用 Python3 作为解释器</li>
</ol>
<p>工作过程：</p>
<ol>
<li>a.py 接收参数后，使用 subprocess 模块提供的功能，传递到 b.py 文件传输</li>
<li>b.py 可以通过文件读写、数据库或者标准输出的方式，把结果再传回</li>
<li>a.py 再读取 b.py 执行的结果，完成 Alfred 内条目的添加</li>
</ol>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your Workflow/</span><br><span class="line">    info.plist</span><br><span class="line">    icon.png</span><br><span class="line">    workflow/</span><br><span class="line">        __init__.py</span><br><span class="line">        background.py</span><br><span class="line">        notify.py</span><br><span class="line">        Notify.tgz</span><br><span class="line">        update.py</span><br><span class="line">        version</span><br><span class="line">        web.py</span><br><span class="line">        workflow.py</span><br><span class="line">    yourscript.py</span><br><span class="line">    etc.</span><br></pre></td></tr></table></figure>

<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="前提调研"><a href="#前提调研" class="headerlink" title="前提调研"></a>前提调研</h3><p>起初用的是某位老哥开发的一个workflow，但是近两天发现有道的API下线了，事实上是HTTP版本的接口下线了，现在就只保留了一个新版本的API。</p>
<p>那就注册一个自己的开发者账号，填上认证信息，改改还能用。但是第二天一看，前天查俩单词就扣费了7分钱，虽说费用很低，但是架不住时间长了啊，何况认证用户只送50元的体验金，说不定哪天就用完了。</p>
<p>后来想了想还是自己开发一个新的，和有道翻译说再见了。在网上随便一搜看到了百度的通用翻译API，每个月权益如下，虽然不多但也够用了。</p>
<ul>
<li>QPS&#x3D;1</li>
<li>支持28个语种互译</li>
<li>单次最长请求1000字符</li>
<li>免费调用量5万字符&#x2F;月</li>
</ul>
<p>其实后来又看到很多其他家的产品，QPS都较高，免费额度也不错，比如腾讯云、阿里云等等。总之有一个能用就行了，就算将来再换也看文档改一下就行了。</p>
<h3 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h3><p>首先点击加号新建，使用hotkey的方式</p>
<p><img data-src="https://img.econow.cn/blog/1689923285674.png" alt="创建"></p>
<p>然后配置hotkey</p>
<p><img data-src="https://img.econow.cn/blog/1689923447818.png" alt="配置"></p>
<blockquote>
<p>注意箭头标识的部分不要写错，prefix的值也是唯一的，不然就冲突了。</p>
</blockquote>
<p>之后配置脚本部分</p>
<p><img data-src="https://img.econow.cn/blog/1689923544329.png" alt="配置脚本"></p>
<p>这里的语言选择了bash，但是脚本是单独存放的，点击下面的目录可以看到当前的workflow的存放位置，将开发脚本放在那个目录下，别忘了还有最开始下载的Alfred-Workflow。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>首先调试翻译的代码，从官网上下载稍微修改了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">appid = <span class="string">&#x27;xxxxxxxxx&#x27;</span></span><br><span class="line">appkey = <span class="string">&#x27;xxxxxxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">endpoint = <span class="string">&#x27;http://api.fanyi.baidu.com/api/trans/vip/translate&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_text</span>(<span class="params">query</span>):</span><br><span class="line">    salt = random.randint(<span class="number">32768</span>, <span class="number">65536</span>)</span><br><span class="line">    sign = md5((appid + query + <span class="built_in">str</span>(salt) + appkey).encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line">    payload = &#123;<span class="string">&#x27;appid&#x27;</span>: appid, <span class="string">&#x27;q&#x27;</span>: query, <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;auto&#x27;</span>, <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;auto&#x27;</span>, <span class="string">&#x27;salt&#x27;</span>: salt, <span class="string">&#x27;sign&#x27;</span>: sign&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.post(endpoint, params=payload)</span><br><span class="line">        r.raise_for_status()  <span class="comment"># Raise an error if the request was unsuccessful</span></span><br><span class="line">        res = r.json().get(<span class="string">&#x27;trans_result&#x27;</span>, [&#123;<span class="string">&#x27;dst&#x27;</span>: r.json()&#125;])[<span class="number">0</span>][<span class="string">&#x27;dst&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;Network error: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(e)&#125;</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;JSON parsing error: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(e)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    query = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">1</span>:])</span><br><span class="line">    result = translate_text(query)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主程序中获取子进程的输出结果，可以考虑以下两种方式：</p>
<ol>
<li>使用 <code>print(result)</code> 输出，并通过 <code>subprocess.check_output()</code> 来获取子进程的输出结果。这种方式在示例代码中已经使用，并且是相对简单和直接的方式。</li>
<li>将子进程的输出写入到文件中，然后在主进程中读取文件来获取输出结果。这样可以绕过无法直接获取子进程输出的问题。</li>
</ol>
</blockquote>
<p>调试完成后会根据输入的语言翻译成对应的语言。之后再配置刚才截图中使用的vn.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> workflow <span class="keyword">import</span> Workflow3</span><br><span class="line"></span><br><span class="line">API_KEY = <span class="string">&#x27;your-pinboard-api-key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">wf</span>):</span><br><span class="line">    args = wf.args</span><br><span class="line">    <span class="comment"># 使用 subprocess.check_output() 捕获被调用脚本的输出结果</span></span><br><span class="line">    result = subprocess.check_output([<span class="string">&#x27;python3&#x27;</span>, <span class="string">&#x27;Baidu_Text_transAPI.py&#x27;</span>] + args, universal_newlines=<span class="literal">True</span>).decode(</span><br><span class="line">        <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    wf.logger.info(<span class="string">u&quot;翻译结果：%s&quot;</span>, result)</span><br><span class="line">    wf.add_item(</span><br><span class="line">        title=args[<span class="number">0</span>],</span><br><span class="line">        subtitle=<span class="string">u&quot;翻译结果: &quot;</span> + result,</span><br><span class="line">        valid=<span class="literal">True</span>,</span><br><span class="line">        uid=<span class="string">&quot;url here&quot;</span>,</span><br><span class="line">        arg=result</span><br><span class="line">    )</span><br><span class="line">    wf.send_feedback()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">u&quot;__main__&quot;</span>:</span><br><span class="line">    wf = Workflow3()</span><br><span class="line">    sys.exit(wf.run(main))</span><br></pre></td></tr></table></figure>

<p>调试过程中很痛苦，主要是必须顾虑到Python2的写法，在中文编码和ASCII上折腾了很久，还是Python3用着爽，可惜deanise大神没这打算。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img data-src="https://img.econow.cn/blog/1689924104970.png" alt="翻译结果"></p>
<blockquote>
<p>调试的时候可以点开右上角的蜘蛛，会展示debug信息。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.deanishe.net/alfred-workflow/">https://www.deanishe.net/alfred-workflow/</a></li>
<li><a href="https://github.com/deanishe/alfred-workflow">https://github.com/deanishe/alfred-workflow</a></li>
<li><a href="https://pypi.org/project/Alfred-Workflow/#description">https://pypi.org/project/Alfred-Workflow/#description</a></li>
<li><a href="https://api.fanyi.baidu.com/doc/21">百度通用翻译API文档</a></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Alfred</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python刷某博客平台的阅读量</title>
    <url>/%E4%BD%BF%E7%94%A8Python%E5%88%B7%E6%9F%90%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%E7%9A%84%E9%98%85%E8%AF%BB%E9%87%8F.html</url>
    <content><![CDATA[<blockquote>
<p>近期重新拾起来了久违的爬虫，有时候就想练练手，正好想起来了某个博客平台，虽然这个平台的评价不高，但是也是有一定存在意义的。那就用Python的方式的方式刷一下阅读量吧。</p>
</blockquote>
<h2 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h2><h3 id="获取目标数据"><a href="#获取目标数据" class="headerlink" title="获取目标数据"></a>获取目标数据</h3><p>首先要获取所有文章的列表，一般只有两个方式：</p>
<ol>
<li>从个人主页获取</li>
<li>从创作中心也就是个人后台获取。</li>
</ol>
<p>很明显从个人主页的位置获取更简单，因为不需要登录，完全没有任何必要给自己找麻烦。</p>
<p><img data-src="https://img.econow.cn/blog/1699326143890.png"></p>
<p>我们要的是文章的版块所以选择文章，在开发者工具中看到有个接口<code>get-business-list</code>提供了我们需要的数据：</p>
<ul>
<li>文章ID</li>
<li>文章URL</li>
<li>文章标题</li>
</ul>
<p>其实到这里，我们能拿到文章ID或者URL就可以了。</p>
<h3 id="分析接口"><a href="#分析接口" class="headerlink" title="分析接口"></a>分析接口</h3><p>接下来我们具体分析这个接口情况</p>
<p><img data-src="https://img.econow.cn/blog/1699326376088.png"></p>
<p>载荷部分很简单，定义了页数索引和size以及username等数据。</p>
<p>然后再看一眼请求头，如果没有特殊字段就好办了。</p>
<p><img data-src="https://img.econow.cn/blog/1699326505465.png"></p>
<p>很明显，只有一个cookie，但是这个cookie是必须的吗，也不一定，待会试试就可以了。直接复制完整URL<code>https://blog.csdn.net/community/home-api/v1/get-business-list?page=1&amp;size=20&amp;businessType=blog&amp;orderby=&amp;noMore=false&amp;year=&amp;month=&amp;username=u013046615</code> 发起get请求。</p>
<p><img data-src="https://img.econow.cn/blog/1699326615025.png"></p>
<p>的确可以直接请求，可以没有cookie。</p>
<p>那么到这里，我们就清晰了获取文章ID的整个过程，接下来就可以考虑代码的思路了。</p>
<h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>代码的整体思路如下：</p>
<ol>
<li>首先获取文章ID或URL（URL其实也可以自己去拼接）</li>
<li>根据文章信息进行requests请求</li>
</ol>
<h3 id="获取文章信息的代码"><a href="#获取文章信息的代码" class="headerlink" title="获取文章信息的代码"></a>获取文章信息的代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_id_from_api</span>():</span><br><span class="line">    api_url = <span class="string">&#x27;https://blog.csdn.net/community/home-api/v1/get-business-list?page=1&amp;size=20&amp;businessType=blog&#x27;</span> \</span><br><span class="line">              <span class="string">&#x27;&amp;orderby=&amp;noMore=false&amp;year=&amp;month=&amp;username=u013046615&#x27;</span></span><br><span class="line">    resp = requests.get(api_url, headers=headers)</span><br><span class="line">    all_ids = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> resp.json()[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;list&#x27;</span>]:</span><br><span class="line">        all_ids.append(i[<span class="string">&#x27;articleId&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> all_ids</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.econow.cn/blog/1699327023246.png"></p>
<p>将数据进行提取，主要是最后的文章ID，也可以直接使用URL，这都无所谓。</p>
<h3 id="进行文章访问的代码"><a href="#进行文章访问的代码" class="headerlink" title="进行文章访问的代码"></a>进行文章访问的代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">pv</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(timeout=timeout) <span class="keyword">as</span> session:</span><br><span class="line">              <span class="comment"># 我这里加了代理，因人而异</span></span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">f&#x27;<span class="subst">&#123;url&#125;</span><span class="subst">&#123;<span class="built_in">id</span>&#125;</span>&#x27;</span>, headers=headers,proxy=proxy) <span class="keyword">as</span> resp:</span><br><span class="line">                    <span class="keyword">await</span> asyncio.sleep(random.uniform(<span class="number">1.0</span>, <span class="number">3.0</span>))</span><br><span class="line">                    <span class="keyword">if</span> resp.status == <span class="number">200</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这里使用的是aiohttp，使用requests也可以。将文章ID传入，然后进行访问，至于返回结果无所属，只要阅读数上升了，就算有一些异常也无关紧要。这里建议使用一些代理，否则可能接口返回异常的可能性大一些。</p>
<p>最后还是要sleep以下，否则容易被ban掉，也算是对自己负责吧。</p>
<h3 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time:2023/10/13</span></span><br><span class="line"><span class="string">@file:csdn.py</span></span><br><span class="line"><span class="string">@author:medivh</span></span><br><span class="line"><span class="string">@mail:admin@econow.cn</span></span><br><span class="line"><span class="string">@IDE:PyCharm </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> freeze_support</span><br><span class="line"></span><br><span class="line">freeze_support()</span><br><span class="line">user_agent_list = [</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; …) Gecko/20100101 Firefox/61.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: random.choice(user_agent_list)&#125;</span><br><span class="line"></span><br><span class="line">host = <span class="string">&quot;https://blog.csdn.net&quot;</span></span><br><span class="line">url = <span class="string">&quot;https://blog.csdn.net/u013046615/article/details/&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_id_from_api</span>():</span><br><span class="line">    api_url = <span class="string">&#x27;https://blog.csdn.net/community/home-api/v1/get-business-list?page=1&amp;size=20&amp;businessType=blog&#x27;</span> \</span><br><span class="line">              <span class="string">&#x27;&amp;orderby=&amp;noMore=false&amp;year=&amp;month=&amp;username=u013046615&#x27;</span></span><br><span class="line">    resp = requests.get(api_url, headers=headers)</span><br><span class="line">    all_ids = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> resp.json()[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;list&#x27;</span>]:</span><br><span class="line">        all_ids.append(i[<span class="string">&#x27;articleId&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> all_ids</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">pv</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(timeout=timeout) <span class="keyword">as</span> session:</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">f&#x27;<span class="subst">&#123;url&#125;</span><span class="subst">&#123;<span class="built_in">id</span>&#125;</span>&#x27;</span>, headers=headers,proxy=proxy) <span class="keyword">as</span> resp:</span><br><span class="line">                    <span class="keyword">await</span> asyncio.sleep(random.uniform(<span class="number">1.0</span>, <span class="number">3.0</span>))</span><br><span class="line">                    <span class="keyword">if</span> resp.status == <span class="number">200</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    total_lines = <span class="number">9999999</span>  <span class="comment"># 你需要提供总共的循环次数</span></span><br><span class="line">    pbar = tqdm(total=total_lines, desc=<span class="string">&quot;进度&quot;</span>)</span><br><span class="line">    id_list = get_id_from_api()</span><br><span class="line">    <span class="comment"># 为每个元素分配权重，可以根据索引设置权重，这里使用倒序索引</span></span><br><span class="line">    weights = [<span class="number">1</span> / (i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(id_list))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; total_lines:</span><br><span class="line">        num_list = [num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">14</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机选择一个元素，带有权重</span></span><br><span class="line">        selected_id = random.choices(id_list, weights=weights, k=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        tasks = [asyncio.create_task(pv(selected_id)) <span class="keyword">for</span> _ <span class="keyword">in</span> num_list]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line">        <span class="comment"># 使用 tqdm 更新进度</span></span><br><span class="line">        pbar.update(<span class="number">1</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_ts = time.time()</span><br><span class="line">    sslgen = SSLFactory()</span><br><span class="line">    semaphore = asyncio.Semaphore(<span class="number">10</span>)  <span class="comment"># 限制同时进行的请求数量为10</span></span><br><span class="line">    timeout = aiohttp.ClientTimeout(total=<span class="number">10</span>)  <span class="comment"># 设置总超时时间为10秒</span></span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;耗时：<span class="subst">&#123;time.time() - start_ts&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img data-src="https://img.econow.cn/blog/1699327281563.png"></p>
<p>可以对比前面的截图中的viewCount 174多了好几百，在个人中心也可以看到同样的数据，真实有效！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现刷阅读量的功能很简单，思路也很简单，没有什么逆向的过程。当然代码也有一些优化的潜力，比如：</p>
<ul>
<li>目前是获取了第一页的文章列表，可以根据第一次请求的总数算出需要请求多少页</li>
<li>也可以加上定时任务，比如只有工作日的时候刷，毕竟很少有人大半夜闲的没事干读技术文章</li>
</ul>
<p><img data-src="https://img.econow.cn/blog/1699327534419.png"></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nmap来进行一些探索</title>
    <url>/%E4%BD%BF%E7%94%A8nmap%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2.html</url>
    <content><![CDATA[<blockquote>
<p>很多时候需要探测局域网中存在哪些主机，或者开放了哪些端口，有一个特别好用的命令——nmap.</p>
</blockquote>
<h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。 当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图 突破防火墙的封锁。</p>
<p>由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(-sL)或者 通过关闭ping (-P0)跳过ping的步骤，也可以使用多个端口把TCP SYN&#x2F;ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0&#x2F;8尤其普遍。 那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。 主机发现能够找到零星分布于IP地址海洋上的那些机器。</p>
<p>如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用connect()系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用-PA -PE选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。</p>
<ul>
<li>-sL 列表扫描。只能列出来这个网段会有多少主机，并不能判断主机的任何状态。默认情况下还能获取主机名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ nmap -sL 192.168.1.0/24</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 16:37 CST</span><br><span class="line">Nmap scan report for 192.168.1.0</span><br><span class="line">Nmap scan report for nsys.cn (192.168.1.1)</span><br><span class="line">...</span><br><span class="line">Nmap scan report for *.demo.haha.com (192.168.1.102)</span><br><span class="line">...</span><br><span class="line">Nmap done: 256 IP addresses (0 hosts up) scanned in 11.16 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>-sP ping扫描。仅使用ping来扫描主机，然后输出对ping进行响应的主机，速度较快，但是意义并不是太大，主要是因为不能获取所有存活的主机。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ nmap -sP 192.168.1.0/24</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 16:42 CST</span><br><span class="line">Nmap scan report for nsys.cn (192.168.1.1)</span><br><span class="line">Host is up (0.00078s latency).</span><br><span class="line">Nmap scan report for 192.168.1.9</span><br><span class="line">Host is up (0.086s latency).</span><br><span class="line">Nmap scan report for 192.168.1.10</span><br><span class="line">Host is up (0.00054s latency).</span><br><span class="line">...</span><br><span class="line">Nmap done: 256 IP addresses (29 hosts up) scanned in 2.64 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>-PU UDP Ping,可以绕过只过滤TCP的防火墙和过滤器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ nmap -P0 192.168.1.0/24</span><br><span class="line">Host discovery disabled (-Pn). All addresses will be marked &#x27;up&#x27; and scan times will be slower.</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 16:45 CST</span><br><span class="line">Nmap scan report for 192.168.1.0</span><br><span class="line">Host is up (0.000029s latency).</span><br><span class="line">All 1000 scanned ports on 192.168.1.0 are filtered</span><br><span class="line"></span><br><span class="line">Nmap scan report for nsys.cn (192.168.1.1)</span><br><span class="line">Host is up (0.0020s latency).</span><br><span class="line">Not shown: 998 filtered ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">80/tcp   open  http</span><br><span class="line">1723/tcp open  pptp</span><br><span class="line">...</span><br><span class="line">Nmap scan report for 192.168.1.97</span><br><span class="line">Host is up (0.000019s latency).</span><br><span class="line">Not shown: 863 closed ports, 135 filtered ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">5900/tcp open  vnc</span><br><span class="line">8086/tcp open  d-s-n</span><br></pre></td></tr></table></figure>

<h3 id="端口扫描基础"><a href="#端口扫描基础" class="headerlink" title="端口扫描基础"></a>端口扫描基础</h3><ul>
<li><p>open<br>  应用程序正在该端口接收TCP 连接或者UDP报文。</p>
</li>
<li><p>closed<br>  关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。</p>
</li>
<li><p>filtered<br>  由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。</p>
</li>
<li><p>unfiltered<br>  未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。</p>
</li>
<li><p>open|filtered(开放或者被过滤的)<br>  当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。</p>
</li>
<li><p>closed|filtered(关闭或者被过滤的)<br>  该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。</p>
</li>
<li><p>-sS TCP SYN扫描，执行速度快，每秒可以扫描上千个端口。因为它不完成一个完全的TCP连接。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo nmap -sS  192.168.1.0/24</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 16:52 CST</span><br><span class="line">Nmap scan report for nsys.cn (192.168.1.1)</span><br><span class="line">Host is up (0.00032s latency).</span><br><span class="line">Not shown: 993 filtered ports</span><br><span class="line">PORT     STATE  SERVICE</span><br><span class="line">80/tcp   open   http</span><br><span class="line">443/tcp  closed https</span><br><span class="line">xxx</span><br><span class="line">MAC Address: xxxx</span><br><span class="line">...</span><br><span class="line">Nmap scan report for 192.168.1.97</span><br><span class="line">Host is up (0.000017s latency).</span><br><span class="line">Not shown: 499 closed ports, 499 filtered ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">5900/tcp open  vnc</span><br><span class="line">8086/tcp open  d-s-n</span><br><span class="line"></span><br><span class="line">Nmap done: 256 IP addresses (100 hosts up) scanned in 127.95 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>-sT TCP connect()扫描</li>
<li>-sU UDP 扫描</li>
<li>-sA TCP ACK扫描</li>
<li>-sw TCP窗口扫描</li>
</ul>
<h3 id="端口说明和扫描顺序"><a href="#端口说明和扫描顺序" class="headerlink" title="端口说明和扫描顺序"></a>端口说明和扫描顺序</h3><ul>
<li>-p 只扫描指定端口</li>
<li>-F 快速有限的端口</li>
<li>-r 不要按随机顺序扫描</li>
</ul>
<h3 id="服务和版本探测"><a href="#服务和版本探测" class="headerlink" title="服务和版本探测"></a>服务和版本探测</h3><ul>
<li>-v</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.1.236</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 17:18 CST</span><br><span class="line">Nmap scan report for 192.168.1.236</span><br><span class="line">Host is up (1.0s latency).</span><br><span class="line">Not shown: 996 closed ports</span><br><span class="line">PORT      STATE SERVICE    VERSION</span><br><span class="line">22/tcp    open  ssh        OpenSSH 7.4 (protocol 2.0)</span><br><span class="line">111/tcp   open  rpcbind    2-4 (RPC #100000)</span><br><span class="line">9100/tcp  open  jetdirect?</span><br><span class="line">38292/tcp open  java-rmi   Java RMI</span><br><span class="line"></span><br><span class="line">Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 36.78 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>-O</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo nmap -O 192.168.1.236</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-01 17:20 CST</span><br><span class="line">Nmap scan report for 192.168.1.236</span><br><span class="line">Host is up (0.00057s latency).</span><br><span class="line">Not shown: 996 closed ports</span><br><span class="line">PORT      STATE SERVICE</span><br><span class="line">22/tcp    open  ssh</span><br><span class="line">111/tcp   open  rpcbind</span><br><span class="line">9100/tcp  open  jetdirect</span><br><span class="line">38292/tcp open  landesk-cba</span><br><span class="line">MAC Address: 52:xxxxxxx:49 (QEMU virtual NIC)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Linux 3.X|4.X</span><br><span class="line">OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4</span><br><span class="line">OS details: Linux 3.2 - 4.9</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line"></span><br><span class="line">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 1.91 seconds</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>指定端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>探测分为两部分，获取主机地址和端口。</p>
<ul>
<li>挖掘更多的网络服务信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script=discovery</span><br></pre></td></tr></table></figure>

<ul>
<li>负责检查目标主机是否有常见的漏洞<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script=vuln 192.168.1.xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其他脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth：负责处理鉴权证书、绕开鉴权的脚本。</span><br><span class="line"></span><br><span class="line">broadcast：处理在局域网内探查更多服务开启的状况，如 dhcp / dns / sqlserver 等服务。</span><br><span class="line"></span><br><span class="line">brute：提供暴力破解方式，针对常见的应用如 http / snmp 等。</span><br><span class="line"></span><br><span class="line">default：使用 sC 或 A 选项时默认的脚本，提供基本脚本扫描能力。</span><br><span class="line"></span><br><span class="line">discovery：挖掘更多的网络服务信息，如 smb 枚举、snmp 查询等。</span><br><span class="line"></span><br><span class="line">dos：用于进行拒绝服务攻击。</span><br><span class="line"></span><br><span class="line">exploit：利用已知的漏洞入侵系统。</span><br><span class="line"></span><br><span class="line">external：利用第三方的数据库或资源，如进行 whois 解析。</span><br><span class="line"></span><br><span class="line">fuzzer：模糊测试脚本，发送异常的包到目标主机，探测出潜在的漏洞。</span><br><span class="line"></span><br><span class="line">malware：探测目标是否感染了病毒，是否开启了后门。</span><br><span class="line"></span><br><span class="line">safe：与 fuzzer 功能相反，属于安全性脚本。</span><br><span class="line"></span><br><span class="line">version：负责增强信性服务与版本扫描功能的脚本。</span><br><span class="line"></span><br><span class="line">vuln：负责检查目标主机是否有常见的漏洞，如 ms08_067。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>全自动部署Hexo 到github</title>
    <url>/%E5%85%A8%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo-%E5%88%B0github.html</url>
    <content><![CDATA[<p>有一天把hexo配置好了，但是每次更新后还有手动部署太麻烦。正好有个pm2的工具，完全可以代替我们做这些事。</p>
<h4 id="安装-pm2"><a href="#安装-pm2" class="headerlink" title="安装 pm2"></a>安装 pm2</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>

<p>在博客source目录新建start.json</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var process = require(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">process.exec(<span class="string">&#x27; hexo g -d&#x27;</span>, <span class="keyword">function</span> (error, stdout, stderr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error !== null) &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;exec error: &#x27;</span> + error);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="新建watch-json"><a href="#新建watch-json" class="headerlink" title="新建watch.json"></a>新建watch.json</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;apps&quot;</span> : [&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span>       : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line"> <span class="string">&quot;script&quot;</span>     : <span class="string">&quot;./start.js&quot;</span>,</span><br><span class="line"> <span class="string">&quot;exec_interpreter&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line"> <span class="string">&quot;exec_mode&quot;</span>  : <span class="string">&quot;fork_mode&quot;</span>,</span><br><span class="line"> <span class="string">&quot;watch&quot;</span>      : <span class="string">&quot;_posts&quot;</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用pm2命令实现监控文件变动自动提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start watch.json</span><br></pre></td></tr></table></figure>

<h4 id="pm2常用命令"><a href="#pm2常用命令" class="headerlink" title="pm2常用命令"></a>pm2常用命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 list</span><br><span class="line">pm2 logs</span><br><span class="line">pm2 start watch.json</span><br><span class="line">pm2 show &lt;<span class="built_in">id</span>|name&gt;</span><br></pre></td></tr></table></figure>

<img data-src="https://img.econow.cn/2018/1544954010476.png" width="826"/>

<p>这样就会发现Hexo已经被自动部署到github啦，而且时刻保持最新版</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于DDOS的防护措施的一些探索方案</title>
    <url>/%E5%85%B3%E4%BA%8EDDOS%E7%9A%84%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<h2 id="10-23"><a href="#10-23" class="headerlink" title="10:23"></a>10:23</h2><ul>
<li>收到阿里云的邮件通知，DDOS攻击开始，自动清洗启动</li>
<li>流量超出阈值，进入黑洞</li>
</ul>
<h2 id="10-25"><a href="#10-25" class="headerlink" title="10:25"></a>10:25</h2><p>所有部署在WAF上的域名沦陷，且无法观测到底有多大的流量攻击。</p>
<h2 id="10-35-切换域名解析"><a href="#10-35-切换域名解析" class="headerlink" title="10:35 切换域名解析"></a>10:35 切换域名解析</h2><h3 id="应急方案启动"><a href="#应急方案启动" class="headerlink" title="应急方案启动"></a>应急方案启动</h3><p>根据之前的方案安排，依据的主要理论是用DNS的多条A记录来扛。但事实不太美好，域名服务商并不支持重复的解析记录，无论是A记录还是CNAME。</p>
<h3 id="方案调整"><a href="#方案调整" class="headerlink" title="方案调整"></a>方案调整</h3><p>由于WAF已被黑洞，尝试切换流量直接到SLB。目前来说有两个域名优先级最高，官网和接口。而官网域名配置最为简单，可以检验效果。</p>
<ul>
<li>解析官网域名到SLB</li>
<li>5分钟左右，官网正常访问</li>
</ul>
<h2 id="11-03"><a href="#11-03" class="headerlink" title="11:03"></a>11:03</h2><p>解除黑洞</p>
<h2 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h2><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><ul>
<li>使用临时域名app1，CNAME解析到中间域名 a1.xxx.com</li>
<li>a1.xxx.com配置多条A记录</li>
<li>每条A记录对应一台SLB</li>
</ul>
<h3 id="攻击发生"><a href="#攻击发生" class="headerlink" title="攻击发生"></a>攻击发生</h3><ol>
<li>修改DNS解析 生产域名 CNAME 指向 a1.xxx.com</li>
<li>观察接口域名是否可以正常使用</li>
<li>观察所有SLB流量和攻击情况</li>
</ol>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Mac上MySQL认证失败的问题</title>
    <url>/%E5%85%B3%E4%BA%8EMac%E4%B8%8AMySQL%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<blockquote>
<p>今天遇到了点小问题，想重构一个项目，顺便创建一个干净的数据库，但是连接失败！</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img data-src="https://img.econow.cn/medivh/1638526336673.png" alt="1638526336673.png"></p>
<p>事实上我在终端上测试后确定账号和密码是没有问题的，因此重点查看软件和MySQL。终于仔细检查后发现是认证失败的问题。这个问题就很纳闷，咋会遇到这种问题，只好看看大家有没有遇到过。难道是Sequel Pro的问题？不应该吧，这就是一个普通的开源软件。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>终于找到一篇靠谱的文章，描述了异常的原因，而不是直接说怎么解决。<br>主要原因是8.x版本的MySQL的验证机制变成了caching_sha2_password，并不是原来的mysql_native_password。问题说简单也简单，说复杂也复杂，升级个版本还有这样的问题，怪不得没有太多人愿意随便升版本。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>低版本的MySQL，比如5.6，使用的时候是这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create database xxx charset=utf8mb4;</span><br><span class="line">CREATE USER <span class="string">&#x27;xxx&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON xxx.* TO <span class="string">&#x27;xxx&#x27;</span>@<span class="string">&#x27;%&#x27;</span>  WITH GRANT OPTION; </span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>而对于高版本的比如8.x就得用以下的方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>完事,再用Sequel Pro 连接就成功了,其他工具navicat也是这么操作,一样可以连接了。</p>
<p><img data-src="https://img.econow.cn/medivh/1638526875427.png" alt="1638526875427.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实其他版本的MySQL也会有其他的问题，和低版本相比而言，之后再整理一下。<br>很快就要休假了，反而又热爱上了工作，可笑。。。<br>但愿假期一切安好吧！</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Nginx在日常工作中的一些经验</title>
    <url>/%E5%85%B3%E4%BA%8ENginx%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C.html</url>
    <content><![CDATA[<h3 id="负载均衡参数"><a href="#负载均衡参数" class="headerlink" title="负载均衡参数"></a>负载均衡参数</h3><p>在Nginx的负载均衡检查模块中，对于负载均衡的节点可以配置如下可选参数参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">max_fails=1fail_timeout=10s</span><br></pre></td></tr></table></figure>

<p>这个是Nginx在负载均衡功能中，用于判断后端节点状态，所用到两个参数。</p>
<p>Nginx基于连接探测，如果发现后端异常，在单位周期为fail_timeout设置的时间，中达到max_fails次数，这个周期次数内，如果后端同一个节点不可用，那么接将把节点标记为不可用，并等待下一个周期（同样时常为fail_timeout）再一次去请求，判断是否连接是否成功。如果成功，将恢复之前的轮询方式，如果不可用将在下一个周期(fail_timeout)再试一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认：fail_timeout为10s,max_fails为1次。</span></span><br></pre></td></tr></table></figure>

<h3 id="proxy-next-upstream"><a href="#proxy-next-upstream" class="headerlink" title="proxy_next_upstream"></a>proxy_next_upstream</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_next_upstream http_500 | http_502 | http_503 | http_504 |http_404;</span><br></pre></td></tr></table></figure>

<p>当其中一台返回错误码404,500…等错误时，可以分配到下一台服务器程序继续处理，提高平台访问成功率，多可运用于前台程序负载。</p>
<p>场景:当访问A时，A返回error timeout时，访问会继续分配到下一台服务器处理，就等于一个请求分发到多台服务器，就可能出现多次处理的情况，<br>如果涉及到充值，就有可能充值多次的情况，这种情况下就要把proxy_next_upstream关掉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_next_upstream off</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Ngin正向代理和反向代理的应用</title>
    <url>/%E5%85%B3%E4%BA%8ENginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8.html</url>
    <content><![CDATA[<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。代理也可以称为正向代理。<br>所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。<br>提供代理服务的电脑系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。一个完整的代理请求过程为：客户端首先与代理服务器创建连接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建连接、或者获得目标服务器的指定资源（如：文件）。在后一种情况中，代理服务器可能对目标服务器的资源下载至本地缓存，如果客户端所要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接传回已缓存的资源。一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应，以满足代理协议的需要。代理服务器的选项和设置在计算机程序中，通常包括一个“防火墙”，允许用户输入代理地址，它会遮盖他们的网络活动，可以允许绕过互联网过滤实现网络访问。</p>
<img data-src="https://img.econow.cn/medivh/1630550846470.png"  />

<p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，并不会直接发送给前方持有资源的目标服务器。<br>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。</p>
<img data-src="https://img.econow.cn/medivh/1630550861682.png"  />

<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ul>
<li>HTTP</li>
<li>HTTPS</li>
</ul>
<h4 id="Socks"><a href="#Socks" class="headerlink" title="Socks"></a>Socks</h4><ul>
<li>Socks4&#x2F;5</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li>提高访问速度：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>
<li>控制对内部资源的访问：如某大学FTP（前提是该代理地址在该资源的允许访问范围之内），使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li>
<li>过滤内容：例如限制对特定计算机的访问，将一种语言的数据翻译成另一种语言，或是防御代理服务器两边的攻击性访问。</li>
<li>隐藏真实IP：上网者也可以通过代理服务器隐藏自己的IP，免受攻击。但是只一个代理很难保证安全，更安全的方法是利用特定的工具创建代理链（如：Tor）。</li>
<li>突破自身IP访问限制：访问国外站点。</li>
<li>突破内容过滤机制限制，访问被过滤网站。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在生产活动中比较常见的使用方式：</p>
<ul>
<li>使用代理IP抓取社保网站的信息；</li>
<li>打通内网和云环境的部分接口；</li>
<li>代理MongoDB给QMS。<br>主要用的的软件是Nginx，可以代理若干协议：</li>
</ul>
<img data-src="https://img.econow.cn/medivh/1630550965945.png"  />

<p>需要注意的是Nginx默认支持http代理，但是如果使用https代理需要增加模块：ngx_http_proxy_connect_module<br>需要注意的是安装patch命令，服务器默认是没有这个命令的。<br>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://nginx.org/download/nginx-1.9.2.tar.gz</span><br><span class="line">$ tar -xzvf nginx-1.9.2.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> nginx-1.9.2/</span><br><span class="line">$ patch -p1 &lt; /path/to/ngx_http_proxy_connect_module/patch/proxy_connect.patch</span><br><span class="line">$ ./configure \</span><br><span class="line">--user=nginx \</span><br><span class="line">--group=nginx \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_realip_module \</span><br><span class="line">--with-threads \</span><br><span class="line">--add-module=/root/ngx_http_proxy_connect_module</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>对于已经安装了nginx的可以使用以下方式（未实际验证过）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止NGINX服务</span></span><br><span class="line"><span class="comment"># systemctl stop nginx</span></span><br><span class="line"><span class="comment"># 备份原执行文件</span></span><br><span class="line"><span class="comment"># cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span></span><br><span class="line"><span class="comment"># 在源代码路径重新编译</span></span><br><span class="line"><span class="comment"># cd /usr/local/src/nginx-1.16.0</span></span><br><span class="line">./configure \</span><br><span class="line">--user=www \</span><br><span class="line">--group=www \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_realip_module \</span><br><span class="line">--with-threads \</span><br><span class="line">--add-module=/root/src/ngx_http_proxy_connect_module</span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># 不要make install</span></span><br><span class="line"><span class="comment"># 将新生成的可执行文件拷贝覆盖原来的nginx执行文件</span></span><br><span class="line"><span class="comment"># cp objs/nginx /usr/local/nginx/sbin/nginx</span></span><br><span class="line"><span class="comment"># /usr/bin/nginx -V</span></span><br><span class="line">nginx version: nginx/1.16.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC)</span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --user=www --group=www --prefix=/usr/local/nginx --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-threads --add-module=/root/src/ngx_http_proxy_connect_module</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen                         3128;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dns resolver used by forward proxying</span></span><br><span class="line">    resolver                       8.8.8.8;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># forward proxy for CONNECT request</span></span><br><span class="line">    proxy_connect;</span><br><span class="line">    proxy_connect_allow            443 563;</span><br><span class="line">    proxy_connect_connect_timeout  10s;</span><br><span class="line">    proxy_connect_read_timeout     10s;</span><br><span class="line">    proxy_connect_send_timeout     10s;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># forward proxy for non-CONNECT request</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://<span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>resolver 必须配置，建议和服务器一致</li>
</ul>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>反向代理在电脑网络中是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器集群的存在[1]。<br>与正向代理不同，正向代理作为客户端的代理，将从互联网上获取的资源返回给一个或多个的客户端，服务端（如Web服务器）只知道代理的IP地址而不知道客户端的IP地址；而反向代理是作为服务器端（如Web服务器）的代理使用，而不是客户端。客户端借由前向代理可以间接访问很多不同互联网服务器（集群）的资源，而反向代理是供很多客户端都通过它间接访问不同后端服务器上的资源，而不需要知道这些后端服务器的存在，而以为所有资源都来自于这个反向代理服务器。</p>
<img data-src="https://img.econow.cn/medivh/1630551013440.png"  />

<p>反向代理在现时的互联网中并不少见，而另一些例子，像是CDN、SNI代理等，是反向代理结合DNS的一类延伸应用。<br><img data-src="https://img.econow.cn/medivh/1630551027126.png"  /></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>对客户端隐藏服务器（集群）的IP地址</li>
<li>安全：作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS&#x2F;DDoS）的防护，更容易排查恶意软件等</li>
<li>为后端服务器（集群）统一提供加密和SSL加速（如SSL终端代理）</li>
<li>负载均衡，若服务器集群中有负荷较高者，反向代理通过URL重写，根据连线请求从负荷较低者获取与所需相同的资源或备援</li>
<li>对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务</li>
<li>对一些内容进行压缩，以节约带宽或为网络带宽不佳的网络提供服务</li>
<li>减速上传</li>
<li>为在私有网络下（如局域网）的服务器集群提供NAT穿透及外网发布服务</li>
<li>提供HTTP访问认证[2]</li>
<li>突破互联网封锁<br>该部分较为常见，不再叙述。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>代理服务器</li>
<li><a href="https://www.kancloud.cn/lizhenjie1992/nginxx/2043708">https://www.kancloud.cn/lizhenjie1992/nginxx/2043708</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title>关于协程的认知</title>
    <url>/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在执行IO密集型任务的时候，程序经常会因为等待IO而阻塞。比如平时使用的requests库来进行请求接口，如果响应过慢，程序会一直等待响应，最后导致抓取数据的效率低下。为了解决这一问题，来研究一下异步协程加速的方法。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>阻塞。阻塞状态是指程序未得到所需计算资源被挂起的状态。程序在等待某操作期间，自身无法继续干别的事。常见的阻塞形式：网络I&#x2F;O阻塞、磁盘IO&#x2F;阻塞、用户输入阻塞等。</li>
<li>非阻塞。程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事，则成该程序在该操作上非阻塞的。 非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时和效率低下，因此我们才要把它变味非阻塞的。</li>
<li>同步。不同的程序为了完成某个任务，在执行过程中需要依靠某种同喜方式协调一致，称这些程序单元是同步执行的，比如商品库存。</li>
<li>异步。为了完成某个任务，不同程序之间过程无需通信协调，也能完成任务的方式，不相关的程序单元之间是可以异步的。比如爬虫网页。</li>
<li>多进程。就是利用CPU多核的优势，在同一时间并行的执行多个任务，可以极大的提高效率。</li>
<li>协程，Coroutine，又称微线程，是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复之前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，即局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态。协程本质上是个单线程，相对于多进程来说，无需线程的上下文切换的开销，无需原子操作锁定及同步的开销。可以使用的场景，比如在网络爬虫的场景，发出一个请求之后，需要等待一定的实际才能得到响应。但是在等待过程中，程序可以做一些其他的事情，等到响应后再切回来继续处理，这样可以充分利用CPU和其他资源，也就是协程的优势所在。</li>
</ul>
<h3 id="执行顺序的对比"><a href="#执行顺序的对比" class="headerlink" title="执行顺序的对比"></a>执行顺序的对比</h3><p><img data-src="https://img.econow.cn/medivh/1658742421514.png" alt="1658742421514.png"><br><img data-src="https://img.econow.cn/medivh/1658742437775.png" alt="1658742437775.png"></p>
<h2 id="协程的用法"><a href="#协程的用法" class="headerlink" title="协程的用法"></a>协程的用法</h2><p>协程相关的概念:  </p>
<ul>
<li>event_loop 事件循环，相当于一个无限循环，可以把一些函数注册到这个事件循环上，当满足条件时，就会调用对应的处理方法。</li>
<li>coroutine 协程，在 Python 中常指代为协程对象类型，可以将协程对象注册到事件循环中，会被事件循环调用。使用 async 关键字来定义一个方法，在调用时不会立即被执行，而是先放回一个协程对象。</li>
<li>task 任务，是对协程对象的进一步封装，包含了任务的所有状态。</li>
<li>future 代表将来执行或没有执行任务的任务的结果，和task没有本质的区别。</li>
</ul>
<h3 id="定义协程"><a href="#定义协程" class="headerlink" title="定义协程"></a>定义协程</h3><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_number</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine = get_number(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">Coroutine</span>: &lt;coroutine <span class="built_in">object</span> get_number at <span class="number">0x10e049f40</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Number: <span class="number">1</span></span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure>

<p>执行过程的分析：</p>
<ol>
<li>引入 asyncio ，这样才可以使用 async 和 await；</li>
<li>然后使用async定义一个方法，方法接收一个数字的参数，该方法执行后会打印数字；</li>
<li>随后调用这个方法，但是并没有执行，而是返回一个coroutine 协程对象；</li>
<li>之后我们使用get_event_loop方法创建一个事件循环loop，并调用了loop对象的run_until_complate方法将协程注册到事件循环loop中，然后启动；</li>
<li>最后看到了输出结果。</li>
</ol>
<p>可见，async 定义的方法机会变成一个无法直接运行的coroutine对象，必须注册到事件循环中才可以执行。上文中提到的task，是对coroutine对象的进一步封装，比coroutine对象多了允许状态，比如running、fiished等，可以通过这些状态来获取协程对象的执行情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_number</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine = get_number(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="type">Coroutine</span>: &lt;coroutine <span class="built_in">object</span> get_number at <span class="number">0x10e38df40</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_number() running at /Users/medivh/tools/test_async.py:<span class="number">45</span>&gt;&gt;</span><br><span class="line">Number: <span class="number">1</span></span><br><span class="line">Task: &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_number() done, defined at /Users/medivh/tools/test_async.py:<span class="number">45</span>&gt; result=<span class="number">1</span>&gt;</span><br><span class="line">After calling loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里定义loop对象后，接着调用了create_task方法将coroutine对象转化为了task对象，随后的输出发现是pending状态。接着将task对象添加到事件循环中得到执行，随后再输出，就变成了finished。并且同时result变成了1，也就是get_number方法的返回结果。</p>
<p>另外，还有一种定义task对象的方式，直接通过asyncio的ensure_future()方法，返回的也是task对象，就不需要借助loop来定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_number</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine = get_number(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    task = asyncio.ensure_future(coroutine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="type">Coroutine</span>: &lt;coroutine <span class="built_in">object</span> get_number at <span class="number">0x10c19ff40</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_number() running at /Users/medivh/tools/test_async.py:<span class="number">48</span>&gt;&gt;</span><br><span class="line">Number: <span class="number">1</span></span><br><span class="line">Task: &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_number() done, defined at /Users/medivh/tools/test_async.py:<span class="number">48</span>&gt; result=<span class="number">1</span>&gt;</span><br><span class="line">After calling loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h3><p>可以给某个task搬到回调方法，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>():</span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Status:&#x27;</span>, task.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine_obj = get_status()</span><br><span class="line">    task = asyncio.ensure_future(coroutine_obj)  <span class="comment"># 定义task</span></span><br><span class="line">    task.add_done_callback(callback)    <span class="comment"># 将callback() 传递给封装好的task对象</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Task: &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;request() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt; cb=[callback() at /Users/medivh/tools/test_async.py:<span class="number">75</span>]&gt;</span><br><span class="line">Status: <span class="number">200</span></span><br><span class="line">Task: &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;request() done, defined at /Users/medivh/tools/test_async.py:<span class="number">69</span>&gt; result=<span class="number">200</span>&gt;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ol>
<li>调用add_done_callback方法，将callback方法传递给封装好的task对象；</li>
<li>task执行完毕后调用callback方法；</li>
<li>task对象同时作为参数传递给callback方法，调用task对象的result方法就可以获取返回结果。</li>
</ol>
<p>其实，不用回方法，直接在task运行完毕后也可以直接调用result方法获取结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>():</span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    coroutine_obj = get_status()</span><br><span class="line">    task = asyncio.ensure_future(coroutine_obj)  <span class="comment"># 定义task</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task Result:&#x27;</span>, task.result())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Task: &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_status() running at /Users/medivh/tools/test_async.py:<span class="number">69</span>&gt;&gt;</span><br><span class="line">Task: &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_status() done, defined at /Users/medivh/tools/test_async.py:<span class="number">69</span>&gt; result=<span class="number">200</span>&gt;</span><br><span class="line">Task Result: <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h3 id="多任务协程"><a href="#多任务协程" class="headerlink" title="多任务协程"></a>多任务协程</h3><p>对于想执行多次请求的方案，可以定义一个task列表，然后使用asyncio的wait方法即可执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>():</span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tasks = [asyncio.ensure_future(get_status()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Tasks: &quot;</span>, tasks)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Task Result:&quot;</span>, task.result())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Tasks:  [&lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending name=<span class="string">&#x27;Task-2&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending name=<span class="string">&#x27;Task-3&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending name=<span class="string">&#x27;Task-4&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;, &lt;Task pending name=<span class="string">&#x27;Task-5&#x27;</span> coro=&lt;get_status() running at /Users/medivh/github/mercury/tools/test_async.py:<span class="number">69</span>&gt;&gt;]</span><br><span class="line">Task Result: <span class="number">200</span></span><br><span class="line">Task Result: <span class="number">200</span></span><br><span class="line">Task Result: <span class="number">200</span></span><br><span class="line">Task Result: <span class="number">200</span></span><br><span class="line">Task Result: <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ol>
<li>for循环创建5个task，组成list；</li>
<li>把list首先传给asyncio的wait方法，然后注册到事件循环中；</li>
<li>发起5个任务；</li>
<li>输出任务结果。</li>
</ol>
<h3 id="协程实现"><a href="#协程实现" class="headerlink" title="协程实现"></a>协程实现</h3><p>前面的代码都是以网络请求为例，都是耗时的等待的操作，因为在请求网页后需要等待页面响应并返回结果。耗时的等待操作一般都是IO操作，比如文件读写、网络请求等，而协程对于处理这种操作具有很大优势。往往可以在需要等待的时候，程序可以暂时挂起，转而执行其他的操作，从而避免等待一个程序而耗费过多的时间，达到充分利用资源的目的。</p>
<p>代码示例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/welcome&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url,time.time()))</span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(get_status()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818769.805218</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818770.0085208</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818770.101907</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818770.1906009</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658818770.262319</span></span><br><span class="line">Cost time: <span class="number">0.5311617851257324</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>事实上和正常的请求耗时相差不大，几乎是依次执行的。其实出现这种情况是因为要实现异步处理，必须得有挂起的操作，当一个任务需要等待IO结果的时候，可以挂起当前任务，转而去执行其他任务。</p>
<p>接下来了解一下await的用法，使用await可以将耗时等待的操作挂起，让出控制权。当协程执行的时候遇到await，事件循环就会将本协程挂起，转而执行其他的协程，知道其他的协程挂起或执行完毕。然后，将代码改造一下。</p>
<blockquote>
<p>如果直接改造上文代码，会出现以下提示<code>Class &#39;int&#39; does not define &#39;__await__&#39;, so the &#39;await&#39; operator cannot be used on its instances </code>。这是因为await后必须符合以下对象：</p>
<ul>
<li>一个原生coroutine对象</li>
<li>一个有types.coroutine（）修饰的生成器，这个生成器可以返回coroutine对象</li>
<li>一个包含await方法的对象返回的一个迭代器</li>
</ul>
</blockquote>
<p>接下来进行一次尝试，用async把请求的方法改造成coroutine对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">return</span> requests.get(url).status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_result</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/welcome&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url, time.time()))</span><br><span class="line">    status = <span class="keyword">await</span> get_status(url)</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(get_result()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>)]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658819455.563387</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658819455.612329</span></span><br><span class="line">waiting <span class="keyword">for</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/welcome <span class="number">1658819455.662548</span></span><br><span class="line">Cost time: <span class="number">3.005825996398926</span></span><br></pre></td></tr></table></figure>

<p>输出的结果证明这种方式不可行，并没有达到真正的异步。这里使用一个支持异步请求的库——aiohttp，利用它和asyncio配合可以方便的实现异步请求操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install apiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_status</span>(<span class="params">url</span>):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = <span class="keyword">await</span> session.get(url)</span><br><span class="line">    result = <span class="keyword">await</span> response.text()</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_result</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/api/afk/pod?current=1&amp;pageSize=100&#x27;</span></span><br><span class="line">    status = <span class="keyword">await</span> get_status(url)</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    tasks = [asyncio.ensure_future(get_result()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Cost time: <span class="number">1.1510028839111328</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请求耗时直接缩短到1秒左右。</p>
<ol>
<li>使用await，后面跟get方法，在执行10个协程的时候，遇到了await，就会将当前协程挂起，转而执行其他协程，直到其他协程也挂起或执行完毕，再进行下一个协程的执行；</li>
<li>开始运行的时候，事件循环会运行第一个task，第一个task执行遇到await跟着的get方法后，被挂起。但这个get方法第一步的执行是非阻塞的，挂起后立刻被环行，创建了ClientSession对象，接着遇到第二个await，调用了session.get()请求方法，然后就被挂起。由于请求耗时较久，所以一直没有被唤醒；</li>
<li>事件循环会寻找当前为被挂起的协程继续执行，于是转而执行第二个task。之后，依次执行了第10个task的session.get()方法后，全部的task被挂起。</li>
<li>所有task处于挂起状态，等待响应。1秒后，所有请求几乎同时有了响应，然后这10个task都被唤醒继续执行，输出请求结果。</li>
</ol>
<p>接下来尝试不同量级的task，输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">Cost time: 1.0380501747131348</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line">Cost time: 1.143162727355957</span><br><span class="line"></span><br><span class="line"><span class="comment"># 50</span></span><br><span class="line">Cost time: 3.379934787750244</span><br><span class="line"></span><br><span class="line"><span class="comment"># 100</span></span><br><span class="line">Cost time: 5.655962705612183</span><br><span class="line"></span><br><span class="line"><span class="comment"># 200 </span></span><br><span class="line">Cost time: 9.78205680847168</span><br><span class="line"></span><br><span class="line"><span class="comment"># 300</span></span><br><span class="line">Cost time: 9.797142028808594</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后的运行时间基本都在10秒内，200个task开始就会出现502情况，当然这个完全在于后端服务的问题。但是100个task以内的时候，时间都是很接近的。</p>
<h3 id="和单进程、多进程对比"><a href="#和单进程、多进程对比" class="headerlink" title="和单进程、多进程对比"></a>和单进程、多进程对比</h3><p>单进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/api/afk/pod?current=1&amp;pageSize=100&#x27;</span></span><br><span class="line">    result = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        get_page()</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Cost time: <span class="number">106.35312700271606</span></span><br></pre></td></tr></table></figure>

<p>多进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">_</span>):</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/api/afk/pod?current=1&amp;pageSize=100&#x27;</span></span><br><span class="line">    result = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">8</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(get_page, <span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Cost time: <span class="number">16.823662996292114</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>8核CPU执行时间为16.8秒，远大于协程的5.6秒。</p>
<p>多线程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://127.0.0.1/api/afk/pod?current=1&amp;pageSize=100&#x27;</span></span><br><span class="line">    result = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">        t = threading.Thread(target=get_page)</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end - start)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">Cost time: <span class="number">10.563114881515503</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多线程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cost time: 1.160654067993164</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>前面讲了那么多，是不是有些内容值得思考一下呢？现在回过头来再总结一下。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象，进程是资源分配的最小单位。<br>那么为什么会有进程这个事物呢？主要目的是为了合理压榨CPU性能和分配运行的时间片。在计算机系统中，其计算核心是CPU，负责所有计算相关的工作和资源。单个CPU一次只能运行一个任务。如果一个进程运行着就完全占用一个CPU，是非常不合理的。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>有了多进程，为什么还要线程？原因如下：</p>
<ol>
<li>进程直接的信息难以共享，父子进程并未共享内存，需要进程间通信，性能开销大</li>
<li>创建进程的性能开销较大。</li>
</ol>
<p>进程由多个线程组成，一个进程可以由多个线程的执行单元组成。每个线程都在运行进程的上下文中，共享着同样的代码和全局数据。多个线程比多进程之间更容易共享数据，在上下文切换中一般比进程更高效，原因如下： </p>
<ol>
<li>线程间能够快速、方便共享数据</li>
<li>创建线程的速度比创建进程快10倍以上</li>
</ol>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是用户态的线程。协程的优势：</p>
<ol>
<li>节省CPU。避免系统内核级的线程频繁切换，造成CPU的浪费。协程是用户态的线程，用户可以自行控制协程的创建和销毁，极大程度上避免了系统级线程上下文切换造成的资源浪费。</li>
<li>节约内存。64位的Linux系统中，一个线程需要分配8MB栈内存和64MB堆内存。系统内存的制约导致无法开启更多线程的并发。而协程只需要KB级别，可以轻松达到几十万。</li>
<li>稳定性。线程之间通过内存来共享数据，这就会导致一个问题，比如一个线程出错时，进程中的所有线程都会跟着崩溃。</li>
<li>开发效率。开发过程中，可以方便的把一些耗时的IO操作异步化，比如些写文件、耗时IO请求等。</li>
</ol>
<p>总之，协程的本质是用户态下的线程.</p>
<p>用一个形象的例子：</p>
<ul>
<li>进程就像一家餐馆，餐馆有多个服务员，每个餐桌是要完成的任务。单进程，对应一家餐馆；</li>
<li>多进程，增加了N家餐馆，接待的客人多了，成本也上去了；</li>
<li>多线程。一家餐馆，来一桌客人安排一个服务员；</li>
<li>协程。一家餐馆只安排一个服务员，A点菜，就去B服务，A点完了就再回到A这。B还没点完就去C那，依次类推，直到所有人都吃上饭。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于混合部署方案的设想</title>
    <url>/%E5%85%B3%E4%BA%8E%E6%B7%B7%E5%90%88%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%E7%9A%84%E8%AE%BE%E6%83%B3.html</url>
    <content><![CDATA[<h2 id="理论依据"><a href="#理论依据" class="headerlink" title="理论依据"></a>理论依据</h2><p>在时效性上来区分任务，常规的任务一般分为在线任务和离线任务。其中在线任务消耗的资源相对较少，但是要求相应时间较短，比如web服务；而离线任务则对时效性要求不高，但是任务量大，需要的资源更多。因此把两种项目混合部署在一起就叫做混合部署。</p>
<p>大多数进程可以分为I&#x2F;O密集型和CPU密集型。I&#x2F;O密集型程序将大多数时间都花在了I&#x2F;O操作而不是运算上，而CPU密集型程序正好相反，将大多数时间花在了运算上，而很少产生I&#x2F;O操作。选出一个I&#x2F;O密集型和CPU密集型程序的良好组合，对于长期调度器是非常重要的。否则，假如所有的程序都是CPU密集型的，那么I&#x2F;O队列将会几乎永远都是空的，这样就会导致一些设备从来没被使用过，系统资源分配就是不均衡的。显然，性能极佳的系统必然是CPU密集型和I&#x2F;O密集型程序的组合。在现代操作系统中，这被用来保证实时进程能获得足够的CPU时间来完成任务。但我们的当前绝大部分项目并不能做到资源的和谐组合——cpu使用率远低于内存使用率。这样的特点也方便混合部署的时候只需要考虑内存的瓶颈即可。</p>
<h2 id="资源使用率现状"><a href="#资源使用率现状" class="headerlink" title="资源使用率现状"></a>资源使用率现状</h2><p>通俗来讲，我们希望使用提高资源使用率的同时降低成本。任务类型的分类是提高资源利用率的理论依据，只不过迫于现实，实践过程中会有些偏差。<br>当前的现状，大部分CPU平均使用率长期在30%以内徘徊，极大的浪费资源。<br><img data-src="https://img.econow.cn/medivh/1630553329133.png"  /></p>
<p>而对于内存调整的空间较为有限，个别实例有操作空间。<br><img data-src="https://img.econow.cn/medivh/1630553335430.png"  /></p>
<p>当前的实例用途类型基本分为三类：</p>
<ul>
<li>大数据集群<ul>
<li>夜间使用率高，白天使用率低</li>
<li>CPU和内存需求较高</li>
</ul>
</li>
<li>微服务<ul>
<li>白天使用率微高，夜间极低</li>
<li>CPU使用率较低，内存使用率微高</li>
</ul>
</li>
<li>中间件<ul>
<li>波动较小<br>自2021年起始，累计增加了约8~10个微服务项目，关停1台主机但并没有增加新的实例主机。单纯的微服务集群内存使用率峰值只增加了不到5个百分点。这些数字说明了一些可能的现象：</li>
</ul>
</li>
<li>业务量有降低</li>
<li>代码性能更好<br>当前保有实例45台，每年的开支大约在32万，是不是有可能降低10%~15%？</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>现有ECS基本可以分为2种类型的实例，离线型和在线型。其中离线型的实例配置较高，常规配置为16核32G，近期保有量为3~5台。因此之后一段时间可以将部分微服务部署在相应的节点。</p>
<h3 id="规划节点"><a href="#规划节点" class="headerlink" title="规划节点"></a>规划节点</h3><p>节点角色</p>
<ul>
<li>003~005 轻量级节点</li>
<li>006~007 常规级节点</li>
<li></li>
</ul>
<h4 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h4><p>轻量级的实例部署了多种大数据相关的服务，因此只可部署少量的微服务，避免极端情况下微服务和大数据服务资源的抢夺。常规级的节点可以部署更多pod。。同时，两类服务共存会带来一些潜在的问题：</p>
<ol>
<li>极端调度；</li>
<li>抢夺资源；</li>
<li>网络关系.</li>
</ol>
<p>以上三个问题中最重要的是第一个问题，第一个问题处理好后，第二个问题就会很好处理。而第三个则是永远无法避免的，能做的只能是选择网络依赖最小的微服务。因此，重点解决调度的问题。</p>
<ol>
<li>节点选择。在默认情况下，pod的调度是由scheduler-crontroller根据节点资源和有限制来自动完成的。但是在目前的情况下我们希望微服务部署在某些节点和少量部署在另一部分节点上。对于指定节点部署可以使用NodeSelector设定的标签来选择节点，原理是给node设置标签，scheduler就会把pod调度到具有该标签的node上。</li>
<li>资源限制。每个pod都会有cpu和memory的limits限制，因此再加上pod的数量限制，就可以避免服务间的资源抢夺了。设置–max-pods较为简单，修改各node kubelet启动参数即可，较容易实现。</li>
<li>均匀调度。每个微服务默认期望部署在至少两个节点，常规实例和大数据实例。对于这个问题需要用节点亲和性和pod亲和性来处理。节点亲和性指定了将pod调度到节点的权重或其他规则。pod亲和性基于已经在节点上运行的pod的标签来约束pod可以调度到的节点，而不是基于节点的标签。但是这这两种方式不适合当前版本的kubernetes，只能在高版本的集群上使用。<br>综上所述，潜在问题可以大部分通过参数调整达到期望的状态，基本满足正常使用。如果期望达到更好的状态，则必须升级kubernetes集群。</li>
</ol>
<h3 id="部署节点"><a href="#部署节点" class="headerlink" title="部署节点"></a>部署节点</h3><h4 id="部署kubelete-client"><a href="#部署kubelete-client" class="headerlink" title="部署kubelete client"></a>部署kubelete client</h4><p>常规部署，无特殊处理，修改<code>--max-pods</code>。</p>
<h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><ul>
<li>需注意大数据集群和业务服务的网络互通，重点在安全组的配置</li>
</ul>
<h4 id="预期目标"><a href="#预期目标" class="headerlink" title="预期目标"></a>预期目标</h4><p>目前保有143个pod，加上部分服务的编排处理，预计全部的pod会到达160个。通过混合部署，预计能释放20~30个pod的资源潜力，约至少32G内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当年内预期目标ECS部分的开支控制在30万内，去年约31万。当前阶段通过资源混部来实现资源的错位运用可以提高一些资源利用率。接下来通过pod的资源利用率监控可以更合理的进行资源限制，释放过剩资源。之后kubernetes的版本升级之后带来的亲和性功能和hpa、vpa、ca则会带来更多的想象空间。</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 学习</title>
    <url>/%E5%85%B3%E4%BA%8E%E5%AF%B9Flask%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>常用的架构有以下两种方式：</p>
<ul>
<li>功能式</li>
<li>分布式</li>
</ul>
<h3 id="功能式"><a href="#功能式" class="headerlink" title="功能式"></a>功能式</h3><p>简单来讲就是以功能来归类文件，比如静态文件放一个目录，模块文件放一个目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yourapp/</span><br><span class="line">    __init__.py</span><br><span class="line">    static/</span><br><span class="line">    templates/</span><br><span class="line">        home/</span><br><span class="line">        control_panel/</span><br><span class="line">        admin/</span><br><span class="line">    views/</span><br><span class="line">        __init__.py</span><br><span class="line">        home.py</span><br><span class="line">        control_panel.py</span><br><span class="line">        admin.py</span><br><span class="line">    models.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了 <code>yourapp/views/__init__.py</code>，在<code>yourapp/views/</code>文件夹中的每一个.py文件都是一个蓝图。在<code>yourapp/__init__.py</code> 中，我们将加载这些蓝图并在我们的Flask()对象中注册它们。</p>
<p>特点：</p>
<ul>
<li>分类明确，很明显就知道去哪找哪种文件；</li>
<li>适合小型项目；</li>
<li>各功能之间联系紧密；</li>
</ul>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>按照每一部分所属的蓝图来组织你的应用。比如A功能的静态文件、模块、视图都放在A的这一个大的目录下。就像一个国家有N个诸侯，每个诸侯管理自己的地盘，互不打扰。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yourapp/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    home/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    control_panel/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    models.py</span><br></pre></td></tr></table></figure>

<p>在像上面列举的分区式结构，每一个yourapp&#x2F;之下的文件夹都是一个独立的蓝图。所有的蓝图通过顶级的__init__.py注册到Flask()中。</p>
<p>特点：</p>
<ul>
<li>应用较为独立，仅共享配置和模型等等；</li>
<li>更为灵活</li>
</ul>
<p>综上所述一般绝大部分的项目就用功能式的架构就会满足需要了。</p>
<h2 id="如何使用蓝图重构一个项目"><a href="#如何使用蓝图重构一个项目" class="headerlink" title="如何使用蓝图重构一个项目"></a>如何使用蓝图重构一个项目</h2><p>Step 1：分区式还是功能式？<br>这个应用由关联较小的各部分构成。模板和静态文件不太可能在蓝图间共享，所以我们将使用分区式结构。<br>Step 2：分而治之<br>注意 在你对你的应用大刀阔斧之前，把一切提交到版本控制。你不会接受对任何有用的东西的意外删除。</p>
<p>接下来我们将继续前进，为我们的新应用创建目录树。从为每一个蓝图创建一个目录开始吧。然后整体复制views.py，static&#x2F;和templates&#x2F;到每一个蓝图文件夹。接着你可以从顶级目录删除掉它们了。</p>
<p>Step 3：大扫除<br>现在我们可以到每一个蓝图中，移除无关的视图，静态文件和模板。你在这一阶段的处境很大程度上取决于一开始你是怎么组织你的应用的。</p>
<p>最终结果应该是：每个蓝图有一个views.py包括了蓝图里的所有视图，没有两个蓝图对同一个路由定义了视图；每一个templates&#x2F;文件夹应该只包括该蓝图所需的模板；每一个static&#x2F;文件夹应该只包括该蓝图所需的静态文件。</p>
<p>注意 趁此机会消除所有不必要的import。很容易忽略掉他们的存在，但他们会拥塞你的代码，甚至拖慢你的应用。</p>
<p>Step 4：蓝图<br>在这一部分我们把文件夹转换成蓝图。关键在于__init__.py文件。作为开始，让我们看一下API蓝图的定义。</p>
<p>Step 5：大功告成<br>现在我们的应用已经比只有单个臃肿的views.py的时候更加模块化了。</p>
<p>总结:</p>
<ul>
<li>一个蓝图包括了可以作为独立应用的视图，模板，静态文件和其他插件。</li>
<li>蓝图是组织你的应用的好办法。</li>
<li>在分区式架构下，每个蓝图对应你的应用的一个部分。</li>
<li>在功能式架构下，每个蓝图就只是视图的集合。所有的模板和静态文件都放在一块。</li>
<li>要使用蓝图，你需要定义它，并在应用中用Flask.register_blueprint()注册它。</li>
<li>你可以给一个蓝图中的所有路由定义一个动态URL前缀。</li>
<li>你也可以给蓝图中的所有路由定义一个动态子域名。</li>
<li>仅需五步走，你可以用蓝图重构一个应用。</li>
</ul>
<h2 id="一些有意思的事情"><a href="#一些有意思的事情" class="headerlink" title="一些有意思的事情"></a>一些有意思的事情</h2><h3 id="json和jsonify的差异"><a href="#json和jsonify的差异" class="headerlink" title="json和jsonify的差异"></a>json和jsonify的差异</h3><p>字符串转json对象，使用json.loads()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 字符串转json，注意（key与value必须是双引号）</span></span><br><span class="line">str1 = <span class="string">&#x27;&#123;&quot;a&quot;:1, &quot;b&quot;:&quot;2&quot;&#125;&#x27;</span></span><br><span class="line">j1 = json.loads(str1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(j1), j1)  <span class="comment"># &lt;class &#x27;dict&#x27;&gt; &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;2&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="string">&#x27;[&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:&quot;2&quot;&#125;]&#x27;</span></span><br><span class="line">j2 = json.loads(str2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(j2), j2)  <span class="comment"># &lt;class &#x27;list&#x27;&gt; [&#123;&#x27;a&#x27;: 1&#125;, &#123;&#x27;a&#x27;: &#x27;2&#x27;&#125;]</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> j2:</span><br><span class="line">    <span class="built_in">print</span>(obj[<span class="string">&quot;a&quot;</span>])  <span class="comment"># 1  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可见通过json的loads方法可将标准json字符串转成字典对象或字典集合</span></span><br><span class="line"><span class="comment"># 下面是嵌套组合的字符串也可以通过loads方法转换</span></span><br><span class="line">f = <span class="string">&#x27;&#123;&quot;a&quot;:1, &quot;b&quot;: [&#123;&quot;b_1&quot;: &quot;b1&quot;&#125;, &#123;&quot;b_1&quot;: &quot;b1&quot;&#125;]&#125;&#x27;</span></span><br><span class="line">l = json.loads(f)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(l), l)  <span class="comment"># &lt;class &#x27;dict&#x27;&gt; &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: [&#123;&#x27;b_1&#x27;: &#x27;b1&#x27;&#125;, &#123;&#x27;b_1&#x27;: &#x27;b1&#x27;&#125;]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(l[<span class="string">&quot;b&quot;</span>], <span class="built_in">type</span>(l[<span class="string">&quot;b&quot;</span>]))  <span class="comment"># [&#123;&#x27;b_1&#x27;: &#x27;b1&#x27;&#125;, &#123;&#x27;b_1&#x27;: &#x27;b1&#x27;&#125;] &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt; &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;2&#x27;</span>&#125;]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt; &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: [&#123;<span class="string">&#x27;b_1&#x27;</span>: <span class="string">&#x27;b1&#x27;</span>&#125;, &#123;<span class="string">&#x27;b_1&#x27;</span>: <span class="string">&#x27;b1&#x27;</span>&#125;]&#125;</span><br><span class="line">[&#123;<span class="string">&#x27;b_1&#x27;</span>: <span class="string">&#x27;b1&#x27;</span>&#125;, &#123;<span class="string">&#x27;b_1&#x27;</span>: <span class="string">&#x27;b1&#x27;</span>&#125;] &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>json对象转字符串，使用json.dumps()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">obj = &#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">objStr = json.dumps(obj)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(objStr), objStr)  <span class="comment"># &lt;class &#x27;str&#x27;&gt; &#123;&quot;a&quot;: 1, &quot;b&quot;: &quot;2&quot;&#125;</span></span><br><span class="line">arr = [</span><br><span class="line">    &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line">arrStr = json.dumps(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(arrStr), arrStr)  <span class="comment"># &lt;class &#x27;str&#x27;&gt; [&#123;&quot;a&quot;: 1&#125;, &#123;&quot;a&quot;: &quot;2&quot;&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt; &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt; [&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;, &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>通过jsonify()将dict转为json字符串</p>
<p>简单，快速是Flask自带的模块jsonify。 功能类似于<code>json.dumps()</code>，但是会把返回的<code>Content-Type从text/html</code>转换成带json特征的 <code>application/json</code>。</p>
<p><img data-src="https://img.econow.cn/medivh/1659598907405.png" alt="1659598907405.png"></p>
<p>总结：</p>
<ul>
<li>json.loads() 把 json 字符串 转成 python 数据类型</li>
<li>json.load(python数据类型,文件句柄) 把 json 文件 转成 python 数据类型</li>
<li>json.dumps() 把 python 数据类型 转成 json 字符串</li>
<li>json.dump(文件句柄) 把 python 数据类型 写入到 json 文件中</li>
</ul>
<p>个人倾向在flask项目中使用jsonify()，简捷。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透工具——frp的实践</title>
    <url>//%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94frp%E7%9A%84%E5%AE%9E%E8%B7%B5</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p>
<h3 id="frp的优点"><a href="#frp的优点" class="headerlink" title="frp的优点"></a>frp的优点</h3><ul>
<li>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</li>
<li>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</li>
<li>代理组间的负载均衡。</li>
<li>端口复用，多个服务通过同一个服务端端口暴露。</li>
<li>多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。</li>
<li>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</li>
<li>服务端和客户端 UI 页面。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>目前可以在 Github 的 <a href="https://github.com/fatedier/frp/releases">Release</a> 页面中下载到最新版本的客户端和服务端二进制文件，所有文件被打包在一个压缩包中。</p>
<p><img data-src="https://img.econow.cn/medivh/1669967801775.png" alt="1669967801775.png"></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>解压缩下载的压缩包，将其中的 frpc 拷贝到内网服务所在的机器上，将 frps 拷贝到具有公网 IP 的机器上，放置在任意目录。<br>编写配置文件，先通过 <code>./frps -c ./frps.ini</code> 启动服务端，再通过<code>./frpc -c ./frpc.ini</code>启动客户端。如果需要在后台长期运行，建议结合其他工具使用，例如 <code>systemd</code> 和 <code>supervisor</code>。</p>
<p>如果是 Windows 用户，需要在 cmd 终端中执行命令。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="服务端配置文件"><a href="#服务端配置文件" class="headerlink" title="服务端配置文件"></a>服务端配置文件</h3><p>以Linux服务器为例，编辑配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"><span class="comment"># 默认7000，可以自定义</span></span><br><span class="line">bind_port =7001</span><br><span class="line"><span class="comment"># 自定义token</span></span><br><span class="line">token = xxxxxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># frp管理后台端口，请按自己需求更改</span></span><br><span class="line">dashboard_port = 7002</span><br><span class="line"><span class="comment"># frp管理后台用户名和密码，请改成自己的</span></span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br><span class="line">enable_prometheus = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># frp日志配置</span></span><br><span class="line">log_file = /var/log/frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure>

<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>创建或编辑<code>/etc/systemd/system/frps.service</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="comment"># 服务名称，可自定义</span></span><br><span class="line">Description = frp server</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line"><span class="comment"># 启动frps的命令，需修改为您的frps的安装路径</span></span><br><span class="line">ExecStart = /opt/frp/frps -c /opt/frp/frps.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>

<p>系统命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动frp</span></span><br><span class="line">systemctl start frps</span><br><span class="line"><span class="comment"># 停止frp</span></span><br><span class="line">systemctl stop frps</span><br><span class="line"><span class="comment"># 重启frp</span></span><br><span class="line">systemctl restart frps</span><br><span class="line"><span class="comment"># 查看frp状态</span></span><br><span class="line">systemctl status frps</span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> frps</span><br></pre></td></tr></table></figure>

<h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>下载对应平台的客户端和二进制文件，修改配置文件<code>frpc.ini</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7001</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br></pre></td></tr></table></figure>

<p>local_ip 和 local_port 配置为本地需要暴露到公网的服务地址和端口。remote_port 表示在 frp 服务端监听的端口，访问此端口的流量将会被转发到本地服务对应的端口。</p>
<p>分别启动 frps 和 frpc。</p>
<p>通过 SSH 访问内网机器，假设用户名为 test：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh <span class="built_in">test</span>@x.x.x.x -p 6000</span><br></pre></td></tr></table></figure>

<p>frp 会将请求 x.x.x.x:6000 的流量转发到内网机器的 22 端口。</p>
<p>而此时访问服务器IP:dashboard_port 还能看到监控信息。</p>
<p><img data-src="https://img.econow.cn/medivh/1669969264963.png" alt="1669969264963.png"></p>
<p>frp的tcp模式相当于你的设备直接向公网暴露了一个tcp端口。任何设备都可以尝试连接这个端口。这里就会有很大的安全风险。因此，可以考虑使用stcp的模式。</p>
<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="stcp"><a href="#stcp" class="headerlink" title="stcp"></a>stcp</h3><p>对于某些服务来说如果直接暴露于公网上将会存在安全隐患。<br>首先client1向服务端注册时携带了一个sk，所有期望连接的设备访问端口时都必须先验证sk。<br><img data-src="https://img.econow.cn/medivh/1670392327929.png" alt="1670392327929.png"><br>然后，client2注册时也携带了通用的sk，就可以通过本机的端口间接连接client1了。<br><img data-src="https://img.econow.cn/medivh/1670392380127.png" alt="1670392380127.png"></p>
<p>使用 stcp(secret tcp) 类型的代理可以避免让任何人都能访问到要穿透的服务，但是访问者也需要运行另外一个 frpc 客户端。</p>
<p><strong>1.</strong> 服务端不变<br><strong>2.</strong> 在需要暴露到内网的机器上部署 frpc，且配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[secret_ssh]</span><br><span class="line"><span class="built_in">type</span> = stcp</span><br><span class="line"><span class="comment"># 只有 sk 一致的用户才能访问到此服务</span></span><br><span class="line">sk = abcdefg</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> 在想要访问内网服务的机器上也部署 frpc，且配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[secret_ssh_visitor]</span><br><span class="line"><span class="built_in">type</span> = stcp</span><br><span class="line"><span class="comment"># stcp 的访问者</span></span><br><span class="line">role = visitor</span><br><span class="line"><span class="comment"># 要访问的 stcp 代理的名字</span></span><br><span class="line">server_name = secret_ssh</span><br><span class="line">sk = abcdefg</span><br><span class="line"><span class="comment"># 绑定本地端口用于访问 SSH 服务</span></span><br><span class="line">bind_addr = 127.0.0.1</span><br><span class="line">bind_port = 6000</span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> 通过 SSH 访问内网机器，假设用户名为 test：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh <span class="built_in">test</span>@127.0.0.1 -p 6000</span><br></pre></td></tr></table></figure>

<p>已经验证成功了，连上了家里的服务器。需要注意的是如果frpc配置在openwrt上需要对应配置填写。</p>
<p>frp 提供了一种新的代理类型 xtcp 用于应对在希望传输大量数据且流量不经过服务器的场景。使用方式同 stcp 类似，需要在两边都部署上 frpc 用于建立直接的连接。<br>后来测试了一下xtcp的模式，虽然日志提示没啥错误，但是依然无法连接，可能还是网络环境的问题吧。配置方式和stcp差不多，唯一的区别就是需要在服务端多加一个端口，客户端type为xtcp。</p>
<h3 id="http-proxy-socks5"><a href="#http-proxy-socks5" class="headerlink" title="http_proxy&#x2F;socks5"></a>http_proxy&#x2F;socks5</h3><p>客户端插件可以被应用在任意类型的代理中，但是需要插件本身的协议能够支持。可以使用http_proxy和socks5进行代理，客户端的机器上配置代理即可访问内网。</p>
<p>Mac 终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> goproxy=<span class="string">&#x27;export http_proxy=http://远程IP:远程端口&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> disproxy=<span class="string">&#x27;unset http_proxy https_proxy&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> goproxys5=<span class="string">&#x27;http_proxy=socks5://xxx:xxx@xxxx:6005&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[http_proxy]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 6004</span><br><span class="line">plugin = http_proxy</span><br><span class="line">plugin_http_user = abc</span><br><span class="line">plugin_http_passwd = abc</span><br><span class="line"></span><br><span class="line">[socket5proxy]</span><br><span class="line"><span class="built_in">type</span> = socks5</span><br><span class="line">remote_port = 6005</span><br><span class="line">plugin = socks5</span><br><span class="line">plugin_user = abc</span><br><span class="line">plugin_passwd = abc</span><br></pre></td></tr></table></figure>

<p>无论是浏览器访问，还是终端访问HTTP地址都可以，但是ssh无法直接访问，暂未解决。还有个不足的地方，会被端口扫描。</p>
<h3 id="static-file"><a href="#static-file" class="headerlink" title="static_file"></a>static_file</h3><p>通过 static_file 插件可以对外提供一个简单的基于 HTTP 的文件访问服务。对于这个功能，可以做成一个软件仓库来使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[test_static_file]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">remote_port = 6000</span><br><span class="line">plugin = static_file</span><br><span class="line"><span class="comment"># 要对外暴露的文件目录</span></span><br><span class="line">plugin_local_path = /tmp/file</span><br><span class="line"><span class="comment"># 访问 url 中会被去除的前缀，保留的内容即为要访问的文件路径</span></span><br><span class="line">plugin_strip_prefix = static</span><br><span class="line">plugin_http_user = abc</span><br><span class="line">plugin_http_passwd = abc</span><br></pre></td></tr></table></figure>

<p>通过浏览器访问 来查看位于  &#x2F;tmp&#x2F;file  目录下的 <a href="http://x.x.x.x:6000/static/">http://x.x.x.x:6000/static/</a>  文件，会要求输入已设置好的用户名和密码。</p>
<h3 id="域名访问"><a href="#域名访问" class="headerlink" title="域名访问"></a>域名访问</h3><p>首先设置frps：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">vhost_http_port = 8080</span><br><span class="line"><span class="comment"># 用于身份验证，请自行修改，要保证服务端与客户端一致</span></span><br><span class="line">token = abcdefgh</span><br></pre></td></tr></table></figure>

<p>然后设置frpc:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[web]</span><br><span class="line"><span class="built_in">type</span> = http</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = xx.xx.com</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://gofrp.org/">https://gofrp.org/</a></li>
<li><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></li>
</ul>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Kubernetes manifest 指南</title>
    <url>/%E5%88%9B%E5%BB%BAKubernetes%20manifest%20%E6%8C%87%E5%8D%97.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>创建编排文件，是一件复杂的事情，很多时候可能没有头绪该如何开始。所以此篇文章提供一些创建的思路。</p>
<p>在定义资源时，将包含以下字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  ...</span><br><span class="line">spec:</span><br><span class="line">  ... </span><br></pre></td></tr></table></figure>

<blockquote>
<p>以下操作均在1.20.0版本，其他版本命令或结果有所不同。</p>
</blockquote>
<h2 id="字段详解"><a href="#字段详解" class="headerlink" title="字段详解"></a>字段详解</h2><h3 id="apiVersion"><a href="#apiVersion" class="headerlink" title="apiVersion"></a>apiVersion</h3><p>该字段指用于创建资源的API组和药使用的API版本。Kubernetes API被聚合到API组中，v1是要使用的apps API版本。如果想列出可用的API组及其版本，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl api-versions </span><br><span class="line">admissionregistration.k8s.io/v1</span><br><span class="line">admissionregistration.k8s.io/v1beta1</span><br><span class="line">apiextensions.k8s.io/v1</span><br><span class="line">apiextensions.k8s.io/v1beta1</span><br><span class="line">apiregistration.k8s.io/v1</span><br><span class="line">apiregistration.k8s.io/v1beta1</span><br><span class="line">apps/v1</span><br><span class="line">authentication.k8s.io/v1</span><br><span class="line">authentication.k8s.io/v1beta1</span><br><span class="line">authorization.k8s.io/v1</span><br><span class="line">authorization.k8s.io/v1beta1</span><br><span class="line">autoscaling/v1</span><br><span class="line">autoscaling/v2beta1</span><br><span class="line">autoscaling/v2beta2</span><br><span class="line">batch/v1</span><br><span class="line">batch/v1beta1</span><br><span class="line">certificates.k8s.io/v1</span><br><span class="line">certificates.k8s.io/v1beta1</span><br><span class="line">coordination.k8s.io/v1</span><br><span class="line">coordination.k8s.io/v1beta1</span><br><span class="line">crd.projectcalico.org/v1</span><br><span class="line">discovery.k8s.io/v1beta1</span><br><span class="line">events.k8s.io/v1</span><br><span class="line">events.k8s.io/v1beta1</span><br><span class="line">extensions/v1beta1</span><br><span class="line">flowcontrol.apiserver.k8s.io/v1beta1</span><br><span class="line">networking.k8s.io/v1</span><br><span class="line">networking.k8s.io/v1beta1</span><br><span class="line">node.k8s.io/v1</span><br><span class="line">node.k8s.io/v1beta1</span><br><span class="line">policy/v1beta1</span><br><span class="line">rbac.authorization.k8s.io/v1</span><br><span class="line">rbac.authorization.k8s.io/v1beta1</span><br><span class="line">scheduling.k8s.io/v1</span><br><span class="line">scheduling.k8s.io/v1beta1</span><br><span class="line">storage.k8s.io/v1</span><br><span class="line">storage.k8s.io/v1beta1</span><br><span class="line">v1</span><br></pre></td></tr></table></figure>

<h3 id="kind"><a href="#kind" class="headerlink" title="kind"></a>kind</h3><p>指定要创建的资源类型，比如Deployment、Pod和ReplicaSet等，可以使用以下命令查看可用的资源类型以及关联的API组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl api-resources | more</span><br><span class="line">NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND</span><br><span class="line">bindings                                       v1                                     <span class="literal">true</span>         Binding</span><br><span class="line">componentstatuses                 cs           v1                                     <span class="literal">false</span>        ComponentStatus</span><br><span class="line">configmaps                        cm           v1                                     <span class="literal">true</span>         ConfigMap</span><br><span class="line">endpoints                         ep           v1                                     <span class="literal">true</span>         Endpoints</span><br><span class="line">events                            ev           v1                                     <span class="literal">true</span>         Event</span><br><span class="line">limitranges                       limits       v1                                     <span class="literal">true</span>         LimitRange</span><br><span class="line">namespaces                        ns           v1                                     <span class="literal">false</span>        Namespace</span><br><span class="line">nodes                             no           v1                                     <span class="literal">false</span>        Node</span><br><span class="line">persistentvolumeclaims            pvc          v1                                     <span class="literal">true</span>         PersistentVolum</span><br><span class="line">eClaim</span><br><span class="line">persistentvolumes                 pv           v1                                     <span class="literal">false</span>        PersistentVolum</span><br><span class="line">e</span><br><span class="line">pods                              po           v1                                     <span class="literal">true</span>         Pod</span><br><span class="line">podtemplates                                   v1                                     <span class="literal">true</span>         PodTemplate</span><br><span class="line">replicationcontrollers            rc           v1                                     <span class="literal">true</span>         ReplicationCont</span><br><span class="line">roller</span><br><span class="line">resourcequotas                    quota        v1                                     <span class="literal">true</span>         ResourceQuota</span><br><span class="line">secrets                                        v1                                     <span class="literal">true</span>         Secret</span><br><span class="line">serviceaccounts                   sa           v1                                     <span class="literal">true</span>         ServiceAccount</span><br><span class="line">services                          svc          v1                                     <span class="literal">true</span>         Service</span><br><span class="line">mutatingwebhookconfigurations                  admissionregistration.k8s.io/v1        <span class="literal">false</span>        MutatingWebhook</span><br><span class="line">Configuration</span><br><span class="line">validatingwebhookconfigurations                admissionregistration.k8s.io/v1        <span class="literal">false</span>        ValidatingWebho</span><br><span class="line">okConfiguration</span><br><span class="line">customresourcedefinitions         crd,crds     apiextensions.k8s.io/v1                <span class="literal">false</span>        CustomResourceD</span><br><span class="line">efinition</span><br><span class="line">apiservices                                    apiregistration.k8s.io/v1              <span class="literal">false</span>        APIService</span><br><span class="line">controllerrevisions                            apps/v1                                <span class="literal">true</span>         ControllerRevis</span><br><span class="line">ion</span><br><span class="line">daemonsets                        ds           apps/v1                                <span class="literal">true</span>         DaemonSet</span><br><span class="line">deployments                       deploy       apps/v1                                <span class="literal">true</span>         Deployment</span><br><span class="line">replicasets                       rs           apps/v1                                <span class="literal">true</span>         ReplicaSet</span><br><span class="line">statefulsets                      sts          apps/v1                                <span class="literal">true</span>         StatefulSet</span><br><span class="line">tokenreviews                                   authentication.k8s.io/v1               <span class="literal">false</span>        TokenReview</span><br><span class="line">localsubjectaccessreviews                      authorization.k8s.io/v1                <span class="literal">true</span>         LocalSubjectAcc</span><br><span class="line">essReview</span><br><span class="line">selfsubjectaccessreviews                       authorization.k8s.io/v1                <span class="literal">false</span>        SelfSubjectAcce</span><br><span class="line">ssReview</span><br><span class="line">selfsubjectrulesreviews                        authorization.k8s.io/v1                <span class="literal">false</span>        SelfSubjectRule</span><br><span class="line">sReview</span><br><span class="line">subjectaccessreviews                           authorization.k8s.io/v1                <span class="literal">false</span>        SubjectAccessRe</span><br><span class="line">view</span><br><span class="line">horizontalpodautoscalers          hpa          autoscaling/v1                         <span class="literal">true</span>         HorizontalPodAu</span><br><span class="line">toscaler</span><br><span class="line">cronjobs                          cj           batch/v1beta1                          <span class="literal">true</span>         CronJob</span><br><span class="line"><span class="built_in">jobs</span>                                           batch/v1                               <span class="literal">true</span>         Job</span><br><span class="line">certificatesigningrequests        csr          certificates.k8s.io/v1                 <span class="literal">false</span>        CertificateSign</span><br><span class="line">ingRequest</span><br><span class="line">leases                                         coordination.k8s.io/v1                 <span class="literal">true</span>         Lease</span><br><span class="line">bgpconfigurations                              crd.projectcalico.org/v1               <span class="literal">false</span>        BGPConfiguratio</span><br><span class="line">n</span><br><span class="line">bgppeers                                       crd.projectcalico.org/v1               <span class="literal">false</span>        BGPPeer</span><br><span class="line">blockaffinities                                crd.projectcalico.org/v1               <span class="literal">false</span>        BlockAffinity</span><br><span class="line">caliconodestatuses                             crd.projectcalico.org/v1               <span class="literal">false</span>        CalicoNodeStatu</span><br><span class="line">s</span><br><span class="line">clusterinformations                            crd.projectcalico.org/v1               <span class="literal">false</span>        ClusterInformat</span><br><span class="line">ion</span><br><span class="line">felixconfigurations                            crd.projectcalico.org/v1               <span class="literal">false</span>        FelixConfigurat</span><br><span class="line">ion</span><br><span class="line">globalnetworkpolicies                          crd.projectcalico.org/v1               <span class="literal">false</span>        GlobalNetworkPo</span><br><span class="line">licy</span><br><span class="line">globalnetworksets                              crd.projectcalico.org/v1               <span class="literal">false</span>        GlobalNetworkSe</span><br><span class="line">t</span><br><span class="line">hostendpoints                                  crd.projectcalico.org/v1               <span class="literal">false</span>        HostEndpoint</span><br><span class="line">ipamblocks                                     crd.projectcalico.org/v1               <span class="literal">false</span>        IPAMBlock</span><br><span class="line">ipamconfigs                                    crd.projectcalico.org/v1               <span class="literal">false</span>        IPAMConfig</span><br><span class="line">ipamhandles                                    crd.projectcalico.org/v1               <span class="literal">false</span>        IPAMHandle</span><br><span class="line">ippools                                        crd.projectcalico.org/v1               <span class="literal">false</span>        IPPool</span><br><span class="line">ipreservations                                 crd.projectcalico.org/v1               <span class="literal">false</span>        IPReservation</span><br><span class="line">kubecontrollersconfigurations                  crd.projectcalico.org/v1               <span class="literal">false</span>        KubeControllers</span><br><span class="line">Configuration</span><br><span class="line">networkpolicies                                crd.projectcalico.org/v1               <span class="literal">true</span>         NetworkPolicy</span><br><span class="line">networksets                                    crd.projectcalico.org/v1               <span class="literal">true</span>         NetworkSet</span><br><span class="line">endpointslices                                 discovery.k8s.io/v1beta1               <span class="literal">true</span>         EndpointSlice</span><br><span class="line">events                            ev           events.k8s.io/v1                       <span class="literal">true</span>         Event</span><br><span class="line">ingresses                         ing          extensions/v1beta1                     <span class="literal">true</span>         Ingress</span><br><span class="line">flowschemas                                    flowcontrol.apiserver.k8s.io/v1beta1   <span class="literal">false</span>        FlowSchema</span><br><span class="line">prioritylevelconfigurations                    flowcontrol.apiserver.k8s.io/v1beta1   <span class="literal">false</span>        PriorityLevelCo</span><br><span class="line">nfiguration</span><br><span class="line">ingressclasses                                 networking.k8s.io/v1                   <span class="literal">false</span>        IngressClass</span><br><span class="line">ingresses                         ing          networking.k8s.io/v1                   <span class="literal">true</span>         Ingress</span><br><span class="line">networkpolicies                   netpol       networking.k8s.io/v1                   <span class="literal">true</span>         NetworkPolicy</span><br><span class="line">runtimeclasses                                 node.k8s.io/v1                         <span class="literal">false</span>        RuntimeClass</span><br><span class="line">poddisruptionbudgets              pdb          policy/v1beta1                         <span class="literal">true</span>         PodDisruptionBu</span><br><span class="line">dget</span><br><span class="line">podsecuritypolicies               psp          policy/v1beta1                         <span class="literal">false</span>        PodSecurityPoli</span><br><span class="line">cy</span><br><span class="line">clusterrolebindings                            rbac.authorization.k8s.io/v1           <span class="literal">false</span>        ClusterRoleBind</span><br><span class="line">ing</span><br><span class="line">clusterroles                                   rbac.authorization.k8s.io/v1           <span class="literal">false</span>        ClusterRole</span><br><span class="line">rolebindings                                   rbac.authorization.k8s.io/v1           <span class="literal">true</span>         RoleBinding</span><br><span class="line">roles                                          rbac.authorization.k8s.io/v1           <span class="literal">true</span>         Role</span><br><span class="line">priorityclasses                   pc           scheduling.k8s.io/v1                   <span class="literal">false</span>        PriorityClass</span><br><span class="line">csidrivers                                     storage.k8s.io/v1                      <span class="literal">false</span>        CSIDriver</span><br><span class="line">csinodes                                       storage.k8s.io/v1                      <span class="literal">false</span>        CSINode</span><br><span class="line">storageclasses                    sc           storage.k8s.io/v1                      <span class="literal">false</span>        StorageClass</span><br><span class="line">volumeattachments                              storage.k8s.io/v1                      <span class="literal">false</span>        VolumeAttachmen</span><br><span class="line">t</span><br></pre></td></tr></table></figure>

<p>使用<code>api-version</code>和<code>api-resources</code>命令可以找到可用资源与资源类型关联的API组以及API组版本。根据此信息填写<code>apiVersion:</code>和<code>kind:</code>字段。</p>
<p>如果想了解某种资源类型的用途，可以使用<code>kubectl explain</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl explain --api-version=apps/v1 deployment</span><br><span class="line">KIND:     Deployment</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     Deployment enables declarative updates <span class="keyword">for</span> Pods and ReplicaSets.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   apiVersion	&lt;string&gt;</span><br><span class="line">     APIVersion defines the versioned schema of this representation of an</span><br><span class="line">     object. Servers should convert recognized schemas to the latest internal</span><br><span class="line">     value, and may reject unrecognized values. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="comment">#resources</span></span><br><span class="line"></span><br><span class="line">   kind	&lt;string&gt;</span><br><span class="line">     Kind is a string value representing the REST resource this object</span><br><span class="line">     represents. Servers may infer this from the endpoint the client submits</span><br><span class="line">     requests to. Cannot be updated. In CamelCase. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="comment">#types-kinds</span></span><br><span class="line"></span><br><span class="line">   metadata	&lt;Object&gt;</span><br><span class="line">     Standard object metadata.</span><br><span class="line"></span><br><span class="line">   spec	&lt;Object&gt;</span><br><span class="line">     Specification of the desired behavior of the Deployment.</span><br><span class="line"></span><br><span class="line">   status	&lt;Object&gt;</span><br><span class="line">     Most recently observed status of the Deployment.</span><br></pre></td></tr></table></figure>

<h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>用于唯一标识Kubernetes集群中的资源，可以为资源命名、分配标签、注解和指定命名空间等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl explain deployment.metadata | more</span><br><span class="line">KIND:     Deployment</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: metadata &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     Standard object metadata.</span><br><span class="line">                                                                                                                                             </span><br><span class="line">     ObjectMeta is metadata that all persisted resources must have, <span class="built_in">which</span></span><br><span class="line">     includes all objects <span class="built_in">users</span> must create.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   annotations  &lt;map[string]string&gt;</span><br><span class="line">     Annotations is an unstructured key value map stored with a resource that</span><br><span class="line">     may be <span class="built_in">set</span> by external tools to store and retrieve arbitrary metadata. They</span><br><span class="line">     are not queryable and should be preserved when modifying objects. More</span><br><span class="line">     info: http://kubernetes.io/docs/user-guide/annotations</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="spec"><a href="#spec" class="headerlink" title="spec"></a>spec</h3><p>可以定义要使用的容器镜像、副本数量、selector条件、存活或就绪探针的定义等。查看具体信息可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl explain deployment.spec | more</span><br><span class="line">KIND:     Deployment</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: spec &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     Specification of the desired behavior of the Deployment.</span><br><span class="line"></span><br><span class="line">     DeploymentSpec is the specification of the desired behavior of the</span><br><span class="line">     Deployment.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   minReadySeconds	&lt;<span class="built_in">integer</span>&gt;</span><br><span class="line">     Minimum number of seconds <span class="keyword">for</span> <span class="built_in">which</span> a newly created pod should be ready</span><br><span class="line">     without any of its container crashing, <span class="keyword">for</span> it to be considered available.</span><br><span class="line">     Defaults to 0 (pod will be considered available as soon as it is ready)</span><br><span class="line"></span><br><span class="line">   paused	&lt;boolean&gt;</span><br><span class="line">     Indicates that the deployment is paused.</span><br><span class="line"></span><br><span class="line">   progressDeadlineSeconds	&lt;<span class="built_in">integer</span>&gt;</span><br><span class="line">     The maximum time <span class="keyword">in</span> seconds <span class="keyword">for</span> a deployment to make progress before it is</span><br><span class="line">     considered to be failed. The deployment controller will <span class="built_in">continue</span> to process</span><br><span class="line">     failed deployments and a condition with a ProgressDeadlineExceeded reason</span><br><span class="line">     will be surfaced <span class="keyword">in</span> the deployment status. Note that progress will not be</span><br><span class="line">     estimated during the time a deployment is paused. Defaults to 600s.</span><br><span class="line"></span><br><span class="line">   replicas	&lt;<span class="built_in">integer</span>&gt;</span><br><span class="line">     Number of desired pods. This is a pointer to distinguish between explicit</span><br><span class="line">     zero and not specified. Defaults to 1.</span><br><span class="line"></span><br><span class="line">   revisionHistoryLimit	&lt;<span class="built_in">integer</span>&gt;</span><br><span class="line">     The number of old ReplicaSets to retain to allow rollback. This is a</span><br><span class="line">     pointer to distinguish between explicit zero and not specified. Defaults to</span><br><span class="line">     10.</span><br><span class="line"></span><br><span class="line">   selector	&lt;Object&gt; -required-</span><br><span class="line">     Label selector <span class="keyword">for</span> pods. Existing ReplicaSets whose pods are selected by</span><br><span class="line">     this will be the ones affected by this deployment. It must match the pod</span><br><span class="line">     template<span class="string">&#x27;s labels.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   strategy	&lt;Object&gt;</span></span><br><span class="line"><span class="string">     The deployment strategy to use to replace existin</span></span><br></pre></td></tr></table></figure>

<h4 id="获取模板"><a href="#获取模板" class="headerlink" title="获取模板"></a>获取模板</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl create deployment nginx --image=nginx -o yaml --dry-run=client</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  strategy: &#123;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">status: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>或者ingress</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl create ingress my-ingress --rule=host/path=app1:80 -o yaml --dry-run=client</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: my-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: host</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: app1</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">        path: /path</span><br><span class="line">        pathType: Exact</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用 <code>kubectl explain</code> 添加<code>--rescursive</code>参数，可以获取各个字段的分层视图：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl explain deployment.spec.template.spec.containers.livenessProbe --recursive | more</span><br><span class="line">KIND:     Deployment</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: livenessProbe &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     Periodic probe of container liveness. Container will be restarted <span class="keyword">if</span> the</span><br><span class="line">     probe fails. Cannot be updated. More info:</span><br><span class="line">     https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle<span class="comment">#container-probes</span></span><br><span class="line"></span><br><span class="line">     Probe describes a health check to be performed against a container to</span><br><span class="line">     determine whether it is alive or ready to receive traffic.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   <span class="built_in">exec</span>	&lt;Object&gt;</span><br><span class="line">      <span class="built_in">command</span>	&lt;[]string&gt;</span><br><span class="line">   failureThreshold	&lt;<span class="built_in">integer</span>&gt;</span><br><span class="line">   httpGet	&lt;Object&gt;</span><br><span class="line">      host	&lt;string&gt;</span><br><span class="line">      httpHeaders	&lt;[]Object&gt;</span><br><span class="line">         name	&lt;string&gt;</span><br><span class="line">         value	&lt;string&gt;</span><br><span class="line">      path	&lt;string&gt;</span><br><span class="line">      port	&lt;string&gt;</span><br><span class="line">      scheme	&lt;string&gt;</span><br><span class="line">   initialDelaySeconds	&lt;<span class="built_in">integer</span>&gt;</span><br><span class="line">   periodSeconds	&lt;<span class="built_in">integer</span>&gt;</span><br><span class="line">   successThreshold	&lt;<span class="built_in">integer</span>&gt;</span><br><span class="line">   tcpSocket	&lt;Object&gt;</span><br><span class="line">      host	&lt;string&gt;</span><br><span class="line">      port	&lt;string&gt;</span><br><span class="line">   timeoutSeconds	&lt;<span class="built_in">integer</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果想进一步了解更详细的信息，可以继续拼接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-node-217 ~]<span class="comment"># kubectl explain deployment.spec.template.spec.containers.lifecycle</span></span><br><span class="line">KIND:     Deployment</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: lifecycle &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     Actions that the management system should take <span class="keyword">in</span> response to container</span><br><span class="line">     lifecycle events. Cannot be updated.</span><br><span class="line"></span><br><span class="line">     Lifecycle describes actions that the management system should take <span class="keyword">in</span></span><br><span class="line">     response to container lifecycle events. For the PostStart and PreStop</span><br><span class="line">     lifecycle handlers, management of the container blocks <span class="keyword">until</span> the action is</span><br><span class="line">     complete, unless the container process fails, <span class="keyword">in</span> <span class="built_in">which</span> <span class="keyword">case</span> the handler is</span><br><span class="line">     aborted.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   postStart	&lt;Object&gt;</span><br><span class="line">     PostStart is called immediately after a container is created. If the</span><br><span class="line">     handler fails, the container is terminated and restarted according to its</span><br><span class="line">     restart policy. Other management of the container blocks <span class="keyword">until</span> the hook</span><br><span class="line">     completes. More info:</span><br><span class="line">     https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/<span class="comment">#container-hooks</span></span><br><span class="line"></span><br><span class="line">   preStop	&lt;Object&gt;</span><br><span class="line">     PreStop is called immediately before a container is terminated due to an</span><br><span class="line">     API request or management event such as liveness/startup probe failure,</span><br><span class="line">     preemption, resource contention, etc. The handler is not called <span class="keyword">if</span> the</span><br><span class="line">     container crashes or exits. The reason <span class="keyword">for</span> termination is passed to the</span><br><span class="line">     handler. The Pod<span class="string">&#x27;s termination grace period countdown begins before the</span></span><br><span class="line"><span class="string">     PreStop hooked is executed. Regardless of the outcome of the handler, the</span></span><br><span class="line"><span class="string">     container will eventually terminate within the Pod&#x27;</span>s termination grace</span><br><span class="line">     period. Other management of the container blocks <span class="keyword">until</span> the hook completes</span><br><span class="line">     or <span class="keyword">until</span> the termination grace period is reached. More info:</span><br><span class="line">     https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/<span class="comment">#container-hooks</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>整个编排文件分为四个字段或者四部分：</p>
<ol>
<li>apiVersion API组及版本</li>
<li>kind  资源类型</li>
<li>metadata 资源注解</li>
<li>spec 定义和管理资源</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取API 版本</span></span><br><span class="line">kubectl api-versions</span><br><span class="line"><span class="comment"># 获取资源类型和API版本</span></span><br><span class="line">kubectl api-resources</span><br><span class="line"><span class="comment"># 获取资源详情</span></span><br><span class="line">kubectl explain --api-version=apps/v1 replicaset</span><br><span class="line"><span class="comment"># 根据资源创建基础模板</span></span><br><span class="line">kubectl create deployment nginx --image=nginx -o yaml --dry-run=client</span><br><span class="line"><span class="comment"># 获取资源详情</span></span><br><span class="line">kubectl explain deployment.spec.selector.matchExpressions.operator</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Kubernetes的Jenkins实现动态slave</title>
    <url>/%E5%9F%BA%E4%BA%8EKubernetes%E7%9A%84Jenkins%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81slave.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般情况下都是在物理机或者虚拟机上部署Jenkins，但是这种部署方式会存在一些缺点，比如：</p>
<ol>
<li>master节点故障，整体不可用</li>
<li>每个slave都需要维护，较为繁琐</li>
<li>资源分配不均衡，且资源利用率低</li>
</ol>
<p>因此需要更可靠和高效的方式来完成CI&#x2F;CD流程。</p>
<p><img data-src="https://img.econow.cn/medivh/1649815494764.png" alt="1649815494764.png"></p>
<p>如图所示，master和slave以Pod的形式运行在kubernetes集群中，并且将配置数据存储到PV中。但是其中slave运行在多个节点，但是不是一直运行的状态，会根据需求动态创建并自动删除。</p>
<p>工作流程：</p>
<ol>
<li>master接收到build请求，会根据配置的label动态创建一个slave的Pod并注册到master</li>
<li>slave运行完job，该Pod自动注销并且删除</li>
<li>恢复到最初的状态</li>
</ol>
<p>架构优点：</p>
<ol>
<li>高可用。当master故障时，kubernetes 会自动创建一个新的Pod，并且将之前的PV分配给新的Pod，保证数据的完整</li>
<li>动态伸缩。根据job来动态创建slave的Pod，并且完成后自动释放资源，提供资源利用率</li>
<li>可扩展。当资源不足时，可以通过增加node的方式快速增加slave</li>
</ol>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="编排文件"><a href="#编排文件" class="headerlink" title="编排文件"></a>编排文件</h3><ol>
<li>PV&#x2F;PVC 提供数据持久化</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: jenkins-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  persistentVolumeReclaimPolicy: Delete</span><br><span class="line">  nfs:</span><br><span class="line">    server: x.x.x.x</span><br><span class="line">    path: /Public/jenkins</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: jenkins-pvc</span><br><span class="line">  namespace: devops</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 500Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>角色授权</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: jenkins-sa</span><br><span class="line">  namespace: devops</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: jenkins-cr</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [<span class="string">&quot;extensions&quot;</span>, <span class="string">&quot;apps&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;deployments&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;services&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;create&quot;</span>,<span class="string">&quot;delete&quot;</span>,<span class="string">&quot;get&quot;</span>,<span class="string">&quot;list&quot;</span>,<span class="string">&quot;patch&quot;</span>,<span class="string">&quot;update&quot;</span>,<span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;pods/exec&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;create&quot;</span>,<span class="string">&quot;delete&quot;</span>,<span class="string">&quot;get&quot;</span>,<span class="string">&quot;list&quot;</span>,<span class="string">&quot;patch&quot;</span>,<span class="string">&quot;update&quot;</span>,<span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;pods/log&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;get&quot;</span>,<span class="string">&quot;list&quot;</span>,<span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;get&quot;</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: jenkins-crd</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: jenkins-cr</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: jenkins-sa</span><br><span class="line">  namespace: devops</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建deployment</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: jenkins</span><br><span class="line">  namespace: devops </span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: jenkins</span><br><span class="line">    spec:</span><br><span class="line">      terminationGracePeriodSeconds: 10</span><br><span class="line">      serviceAccount: jenkins-sa</span><br><span class="line">      containers:</span><br><span class="line">      - name: jenkins</span><br><span class="line">        image: jenkins/jenkins:lts</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">        - name:JAVA_OPTS</span><br><span class="line">          value: -XshowSettings:vm -Dhudson.slaves.NodeProvisioner.initialDelay=0 -Dhudson.slaves.NodeProvisioner.MARGIN=50 -Dhudson.slaves.NodeProvisioner.MARGIN0=0.85 -Duser.timezone=Asia/Shanghai -Dhudson.model.DownloadService.noSignatureCheck=<span class="literal">true</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">          name: web</span><br><span class="line">          protocol: TCP</span><br><span class="line">        - containerPort: 50000</span><br><span class="line">          name: agent</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1000m</span><br><span class="line">            memory: 1Gi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 512Mi</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /login</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          failureThreshold: 12</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /login</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          failureThreshold: 12</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: jenkinshome</span><br><span class="line">          mountPath: /var/jenkins_home</span><br><span class="line">      securityContext:</span><br><span class="line">        fsGroup: 1000</span><br><span class="line">      volumes:</span><br><span class="line">      - name: jenkinshome</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: jenkins-pvc</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: jenkins</span><br><span class="line">  namespace: devops </span><br><span class="line">  labels:</span><br><span class="line">    app: jenkins</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: jenkins</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: web</span><br><span class="line">    port: 8080</span><br><span class="line">    targetPort: web</span><br><span class="line">    nodePort: 30002</span><br><span class="line">  - name: agent</span><br><span class="line">    port: 50000</span><br><span class="line">    targetPort: agent</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>依次执行上述编排文件即可。需要注意PV的文件目录权限是否需要单独修改。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>Jenkins启动后先进行初步配置，此处不在详细描述。需要注意的是：</p>
<ul>
<li>访问的地址是使用的nodePort：30002端口</li>
<li>初始化的密码文件可以从nfs目录上获取</li>
<li>必要插件Pipline和kubernetes</li>
</ul>
<h4 id="配置kubernetes"><a href="#配置kubernetes" class="headerlink" title="配置kubernetes"></a>配置kubernetes</h4><p>节点管理-》Configure Clouds -》kubernetes</p>
<p><img data-src="https://img.econow.cn/medivh/1649817346433.png" alt="1649817346433.png"></p>
<p>Kubernetes Cloud details</p>
<p><img data-src="https://img.econow.cn/medivh/1649817406288.png" alt="1649817406288.png"></p>
<blockquote>
<ol>
<li>注意此处填写的是kubernetes 集群6443的地址。</li>
<li>由于之前创建了account，因此此处无需填写凭据</li>
<li>命名空间可以独立</li>
<li>信息填写完成后注意测试一下。如果测试失败，很可能是权限问题，需要把ServiceAccount的凭证jenkins-sa添加进来。</li>
</ol>
</blockquote>
<p><img data-src="https://img.econow.cn/medivh/1649817519819.png" alt="1649817519819.png"></p>
<blockquote>
<p>注意此处的Jenkins地址，要填写 <a href="http://jenkins.devops.svc.cluster.local:8080/">http://jenkins.devops.svc.cluster.local:8080</a> 。因为之后slave的Pod是需要访问master节点的，只有这种域名的形式才能更灵活的满足需求。如果想不明白为什么是这样的域名，可以思考一下域名解析的过程。</p>
</blockquote>
<p><img data-src="https://img.econow.cn/medivh/1649817671870.png" alt="1649817671870.png"></p>
<p><img data-src="https://img.econow.cn/medivh/1649817705400.png" alt="1649817705400.png"></p>
<blockquote>
<p>这两部分是配置slave的Pod的，重点部分在于镜像。jnlp是Jenkins的slave访问master的一种方式。</p>
</blockquote>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img data-src="https://img.econow.cn/medivh/1649817799601.png" alt="1649817799601.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl get pods -n devops</span><br><span class="line">NAME                       READY   STATUS        RESTARTS   AGE</span><br><span class="line">jenkins-666657ffdd-vvdx8   1/1     Running       0          16h</span><br><span class="line">test-6-5gh46-qfs4k-jz13z   0/2     Terminating   0          61s</span><br></pre></td></tr></table></figure>

<p>此时slave的Pod已经运行完成，自动终止了，之后会自动释放。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="使用podTemplate"><a href="#使用podTemplate" class="headerlink" title="使用podTemplate"></a>使用podTemplate</h3><p>根据标签，调度到其他节点，且使用Jenkins-slave的label</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">podTemplate(cloud: <span class="string">&#x27;kubernetes&#x27;</span>, inheritFrom: <span class="string">&#x27;jenkins-slave&#x27;</span>, label: <span class="string">&#x27;jenkins-slave&#x27;</span>, name: <span class="string">&#x27;test-label&#x27;</span>, namespace: <span class="string">&#x27;devops&#x27;</span>) &#123;</span><br><span class="line">    // some block</span><br><span class="line">&#125;</span><br><span class="line">node(<span class="string">&#x27;jenkins-slave&#x27;</span>) &#123;</span><br><span class="line">    stage(<span class="string">&#x27;get code&#x27;</span>) &#123;</span><br><span class="line">      git credentialsId: <span class="string">&#x27;04bfb304-3573-4876-ad8c-52e43d047d6a&#x27;</span>, url: <span class="string">&#x27;http://192.168.1.110/SystemProject/joyshebao/DiscoveryServer.git&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">      container(<span class="string">&#x27;maven381&#x27;</span>) &#123;</span><br><span class="line">          sh <span class="string">&#x27;mvn -Dmaven.test.skip=true clean package  -f  pom.xml&#x27;</span></span><br><span class="line">          archiveArtifacts <span class="string">&#x27;**/target/*.jar&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调度后的Pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME                       READY   STATUS    RESTARTS   AGE     IP               NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">jenkins-666657ffdd-vvdx8   1/1     Running   0          2d17h   10.200.128.174   uat-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">jenkins-slave-6pz0c        2/2     Running   0          19s     10.200.229.150   pre-205      &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纠结了好几天，总算调试出一些结果。</p>
<ol>
<li>事实证明，label的作用是决定是否使用模板，和kubernetes中的label毫无关系；</li>
<li>脚本式的pipeline和声明式的pipeline存在很大的不同，至少语法上就有很大差别；</li>
<li>解决了maven项目重复下载依赖的问题，挂载.m2目录即可；</li>
</ol>
<p>目前仍存在的问题：</p>
<ol>
<li>如何决定让slave不运行在某些机器上？</li>
<li>哪种pipeline才是主流呢？</li>
</ol>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（一）</title>
    <url>//%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89</url>
    <content><![CDATA[<p>NAS专栏：</p>
<ul>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（一）</a></li>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（二）</a></li>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（三）</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接触到 NAS 这种硬件设备还是在工作以后开始使用的，只不过当时的定义就等于存储，用来扩展服务器的存储空间。随着工作年限的增长，接触NAS的几乎越来越多，从低端的组装 NAS 到高端的企业存储，无外乎最终最主要的功能——存储。</p>
<p>随着工作和生活的变化，意识到自己可能需要拥有一台自己的NAS，虽然折腾组装 NAS 的终点是成品 NAS 。首先工作上会经常遇到一些容器的问题，有了一个 all in one 的平台后就可以创建N台虚拟机来实现一些技术的模拟，比当初刚入行的时候条件好多了。其次一些云盘会和谐一些照片，并且说不定什么时候可能就关门歇业了，虽然只是为了记录大崽的成长，所以除了iCloud以外增加一份保险也是很好的。</p>
<p>综上所述，于公于私有了理由搞个 NAS 。陆续折腾了半个月，终于有个大概的样子，其中的也遇到了一些坎坷，在此记录下来。</p>
<h2 id="系统选型"><a href="#系统选型" class="headerlink" title="系统选型"></a>系统选型</h2><p>首先来聊一下架构，我的目的很简单，就是用最少的成本组装成一台PC，PC上运行虚拟化平台可以创建虚拟机。但最重要的一点是这台PC必须有可扩展性，比如增加硬盘盘位或者多个网卡直通。</p>
<h3 id="软件选型"><a href="#软件选型" class="headerlink" title="软件选型"></a>软件选型</h3><h4 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h4><p>对 All in One 来说最主要的就是底层的虚拟化平台，该平台会决定以后用的舒不舒服或者挖不挖坑。</p>
<p>常见的虚拟化平台有 hype-v、ESXi 、unRaid 和 PVE .其中 hype-v 是微软平台的虚拟化技术，对微软的产品不太感冒也不擅长，因此不做考虑。</p>
<p>ESXi，注重企业支持，界面简单易用，自身功能较强，对硬件要求较高，扩展性较低，但是性能损耗最小。<br>适合初学者、不想太折腾的、有服务器主板的（例如Gen8这种家用服务器）。迷茫的时候，优选ESXi吧。但是需要注意的是该产品面向企业，默认有60天的免费期限，多个节点的话需要考虑付费的问题。</p>
<p>PVE，兼容性最好，扩展性好，界面友善度欠佳，需要一定Linux基础，性能损耗略高于ESXI。<br>适合低端机型、懂Linux的、爱折腾的。PVE玩得溜了之后，看其它的系统都像是弟弟。而且该平台是基于kvm的，这个我用的较多，好感倍增。</p>
<p>unRaid，Docker、磁盘阵列、显卡直通、虚拟U盘等都是亮点。必须U盘引导有点麻烦（廉价U盘7x24工作，心还是很慌）。特色功能多，出新快，因此问题也多。<br>适合直接做NAS、玩PT，尤其适合做家庭影视库、HTPC，玩一拖二也是个不错的选择。比较有可玩性，又不会难度特别高。需要注意该平台是需要付费的。</p>
<p>综上所述，虚拟化平台最终选择了擅长的PVE。</p>
<h4 id="NAS系统"><a href="#NAS系统" class="headerlink" title="NAS系统"></a>NAS系统</h4><h5 id="黑群晖-Xpenology"><a href="#黑群晖-Xpenology" class="headerlink" title="黑群晖&#x2F;Xpenology"></a>黑群晖&#x2F;Xpenology</h5><p>对于新手，DSM永远是最推荐的系统。对于我来说，真的不想考虑破解的问题，谁愿意谁干。而且不知道对虚拟机支持的是否友好，之后扩展硬件可能也没那么容易。</p>
<h5 id="unRaid"><a href="#unRaid" class="headerlink" title="unRaid"></a>unRaid</h5><p>UNRAID是少有的对新手、老手都比较友好的系统。</p>
<p>它有最完善的VM&#x2F;Docker&#x2F;APP支持，活跃的社区。它拥有灵活的拓展性（新增硬盘直接插），更加适合没法一次性购置完全硬盘的家庭用户。 但是它需要付费！</p>
<h5 id="OpenMediaVault-OMV"><a href="#OpenMediaVault-OMV" class="headerlink" title="OpenMediaVault&#x2F;OMV"></a>OpenMediaVault&#x2F;OMV</h5><p>这个系统完全免费开源，基于Debian，并且可以直接装在Debian上面，无需middleware，只要加个Source就行。真纯粹。加了Extras还支持ZFS w&#x2F;WEBUI。但缺点也是纯粹。实际上，它就是一个打包了一堆services和webui的Debian。这就决定了，它的功能很少，或者说需要折腾。对新、老手完全不友好，只推荐给喜欢原生Debian、喜欢折腾的人。总之不推荐。</p>
<h4 id="TrueNas-FreeNas"><a href="#TrueNas-FreeNas" class="headerlink" title="TrueNas&#x2F;FreeNas"></a>TrueNas&#x2F;FreeNas</h4><p>TrueNas Core 基于freebed，稳定并且性能强大，但是由于freebed系统本身趋于没落，所以很多硬件不能得到第一时间支持，且jail的管理方式也不太适合扩展.安装了几个插件，尝试了N次，几乎都没有成功的，要么是网络问题，要么就是各种错误，从官方市场上获取的还能这么多错误，真的有点对不起自己的身份。所以最终选择了TrueNas Scale。</p>
<p>TrueNAS Scale拥有TrueNAS Core的所有优势。包括ZFS等等，在此基础上增加了原生Docker支持，虚拟机也是基于QEMU Kvm，支持功能与性能与PVE相同。</p>
<p>缺点是上手成本高（仍比PVE&#x2F;OMV低）；硬件利用效率比Core略低（等待优化）；Docker是K3S(K8S简化版)，默认禁用iptables，你需要Portainer或者Docker in Docker。</p>
<p>综上所述，NAS系统我最终选择了 TrueNAS Scale 。</p>
<h3 id="电脑硬件知识普及"><a href="#电脑硬件知识普及" class="headerlink" title="电脑硬件知识普及"></a>电脑硬件知识普及</h3><p>在组装PC的过程中遇到了很多问题，因此总结记录一下。</p>
<h4 id="主板分类"><a href="#主板分类" class="headerlink" title="主板分类"></a>主板分类</h4><p>首先聊一下主板规格，只有确定主板尺寸才能确定机箱。</p>
<h5 id="标准型主板ATX-30-5×24-4cm"><a href="#标准型主板ATX-30-5×24-4cm" class="headerlink" title="标准型主板ATX 30.5×24.4cm"></a>标准型主板ATX 30.5×24.4cm</h5><p>标准型主板一般适用于常规尺寸的主机，接口丰富，价格也略高</p>
<h5 id="紧凑型主板M-ATX-24-4x-22-6cm"><a href="#紧凑型主板M-ATX-24-4x-22-6cm" class="headerlink" title="紧凑型主板M-ATX 24.4x 22.6cm"></a>紧凑型主板M-ATX 24.4x 22.6cm</h5><p>M-ATX主板，俗称紧凑型主板，也叫小板，其结构为方形，尺寸大约24.4x 22.6cm，适合小机型用户推荐。紧凑型主板正如其名，接口紧凑、物件够用。</p>
<h5 id="迷你型主板MINI-ITX-17-0×17-0cm"><a href="#迷你型主板MINI-ITX-17-0×17-0cm" class="headerlink" title="迷你型主板MINI-ITX 17.0×17.0cm"></a>迷你型主板MINI-ITX 17.0×17.0cm</h5><p>体积迷你且设计难度大，因此骨架虽小的mini主板，价格往往比很多大号主板还贵，mini型主板并非主流装机之选。</p>
<p>下图是一张包含大部分规格的示意图：</p>
<p><img data-src="https://img.econow.cn/medivh/1669255122079.png" alt="1669255122079.png"></p>
<p>而我已经拥有的主板种，其中华擎的这块属于M-ATX，但比一般的该标准的主板略小一点点。</p>
<h4 id="主板接口"><a href="#主板接口" class="headerlink" title="主板接口"></a>主板接口</h4><p>下面是一块常规主板的展示图片。</p>
<p><img data-src="https://img.econow.cn/medivh/1669213876000.png" alt="1669213876000.png"></p>
<p>其中cpu插槽和cpu是一一对应的，英特尔和amd的cpu不能共用同一张主板，所以刚才介绍H310的时候注明了Intel。</p>
<p>sata接口都是扁L形状的，装3.5寸的sata硬盘需要用两根线，分别是电源线和数据线。但是2.5寸硬盘或固态硬盘就不需要供电了，至于为什么，以后再聊。</p>
<p><img data-src="https://img.econow.cn/medivh/1669214072351.png" alt="1669214072351.png"></p>
<p>重要的接口就这几种，其余的也没啥可聊的，或者遇到了再说吧。</p>
<h4 id="机箱电源"><a href="#机箱电源" class="headerlink" title="机箱电源"></a>机箱电源</h4><p>ATX电源，目前市面上销售的家用电脑电源，一般都遵循 ATX 规范。标准尺寸为 150x140x86mm。</p>
<p>SFX电源，100×125×63.5mm。</p>
<p>1U&#x2F;FLEX电源，150×81.5×40.5mm。</p>
<p>按转换效率的大小层级进行划分，主要分为钛金牌（94%）、白金牌（92%）、金牌（90%）、银牌（88%）、铜牌（85%）、白牌（80%）而低于80%的则属于其它。</p>
<h4 id="硬盘分类"><a href="#硬盘分类" class="headerlink" title="硬盘分类"></a>硬盘分类</h4><p>按原理分类：</p>
<ul>
<li>机械硬盘 HDD 传统硬盘，成本相对较低，读写速度较慢</li>
</ul>
<p><img data-src="https://img.econow.cn/medivh/1669252647401.png" alt="1669252647401.png"></p>
<ul>
<li>固态硬盘 SDD 相对机械硬盘，读取速度更快，寻道时间更小，可加快操作系统启动速度和软件启动速度</li>
</ul>
<p><img data-src="https://img.econow.cn/medivh/1669252659142.png" alt="1669252659142.png"></p>
<ul>
<li>混合硬盘 SSHD 机械硬盘与固态硬盘的结合体，采用容量较小的闪存颗粒用来存储常用常用文件，而磁盘才是最重要的存储介质，闪存仅起到了缓冲作用，将更多的常用文件保存到闪存内减小寻道时间，从而提升效率</li>
</ul>
<p><img data-src="https://img.econow.cn/medivh/1669252671070.png" alt="1669252671070.png"></p>
<p>按接口分类：</p>
<ul>
<li>IDE 并口，以前的服务器用的较多，现在的使用范围极少</li>
</ul>
<p><img data-src="https://img.econow.cn/medivh/1669253256765.png" alt="1669253256765.png"></p>
<ul>
<li>SATA 串口，主流硬盘，传输速度大约是并口的30倍，PC和服务器使用场景较多</li>
</ul>
<p><img data-src="https://img.econow.cn/medivh/1669253265935.png" alt="1669253265935.png"></p>
<ul>
<li>SAS 是并行SCSI接口之后开发出的全新接口。此接口的设计是为了改善存储系统的效能、可用性和扩充性，并且提供与SATA硬盘的兼容性，主要应用场景在服务器。</li>
</ul>
<p>SATA硬盘数据和供电接口都是一样的，3.5英寸一般用于尺寸较大的台式机主机，笔记本也不是说不能用，只不过放不下而已。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>2.5寸</th>
<th>3.5寸</th>
</tr>
</thead>
<tbody><tr>
<td>尺寸</td>
<td>70mm（宽）<em>100mm（长）</em> 9.5mm或7mm（厚）</td>
<td>147mm（长）<em>102mm（宽）</em>26mm（厚）</td>
</tr>
<tr>
<td>转速</td>
<td>5400</td>
<td>7200</td>
</tr>
<tr>
<td>缓存</td>
<td>较小</td>
<td>较大</td>
</tr>
<tr>
<td>性价比</td>
<td>较低</td>
<td>较高</td>
</tr>
</tbody></table>
<h4 id="为什么有的硬盘盒需要单独供电？"><a href="#为什么有的硬盘盒需要单独供电？" class="headerlink" title="为什么有的硬盘盒需要单独供电？"></a>为什么有的硬盘盒需要单独供电？</h4><p>常见的2.5寸硬盘需要0.5~0.9A的5V供电启动。现在的主板一般都有USB 3.0接口，可以提供0.9A的5V供电，过了启动阶段，这个电源需求更低。就算是插在USB 2.0的接口上，一般主板也都支持提供比标准USB 2.0约定的0.5A 5V更大的电流——USB 3.0能给。</p>
<p>3.5寸硬盘，同时要求12V和5V供电，并且启动瞬时功率需要30W以上，12V还可以用变压电路实现，但功率方面，现在的主板都无法提供这么高的功率，自然就需要额外供电了。</p>
<h3 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h3><p>基本原则是利用手上已经拥有的一切硬件，比如：</p>
<ul>
<li>一台J1900平台小机箱<ul>
<li>1 * 128G的SSD</li>
<li>1 * 4G笔记本内存条</li>
<li>1 * mini pcie</li>
<li>1 * msata</li>
<li>1 * 无线网卡</li>
<li>DC电源 12v&#x2F;1A</li>
</ul>
</li>
<li>华擎 H310CM-HDV 主板<ul>
<li>1 * 1T 3.5寸硬盘</li>
<li>1 * 8G DDR4 内存条</li>
<li>1 * 4G DDR4 内存条</li>
<li>1 * 6 x Intel(R) Core(TM) i5-8400 CPU @ 2.80GHz</li>
<li>1 * TFX电源 200W</li>
</ul>
</li>
</ul>
<h4 id="J1900"><a href="#J1900" class="headerlink" title="J1900"></a>J1900</h4><p>这是一台多年前年少无知高价买的小主机，很久没用过了。</p>
<p><img data-src="https://img.econow.cn/medivh/1669194302147.png" alt="1669194302147.png"></p>
<p>该主机功耗很小，大约只有10W。但是这个机箱实在太小了，只适合安装2~3块2.5寸硬盘或者固态硬盘，并且只有一个内存插槽。这样就导致扩展能力很弱，虽然还有一个msata接口，但是整体来说磁盘和内存扩容的成本很高。所以，这台小主机就有点鸡肋了，索性就放在一边需要的时候再拆零件吧。</p>
<h4 id="华擎-H310CM-HDV"><a href="#华擎-H310CM-HDV" class="headerlink" title="华擎 H310CM-HDV"></a>华擎 H310CM-HDV</h4><p>这块主板不错，对于组装NAS来说，提供的接口：</p>
<ul>
<li>支持第九代与第八代 Intel® 酷睿™ 处理器 (1151 插槽)</li>
<li>支持 DDR4 2666 &#x2F; 2400 &#x2F; 2133，最大32G</li>
<li>1 PCIe 3.0 x16, 1 PCIe 2.0 x1</li>
<li>显示输出选项: DVI-D, D-Sub, HDMI，对我来说HDMI是最重要的</li>
<li>4 x SATA3 6.0 Gb&#x2F;s 接口，满足了基本的硬盘扩展能力，何况之后还可以使用转接头来扩容</li>
<li>1 x Realtek RTL8111H 千兆网卡，支持网络唤醒</li>
<li>4 USB 3.1 Gen1 (2 前置, 2 后置)</li>
</ul>
<p>主板规格Micro ATX 规格: 7.5-in x 7.4-in, 19.1 cm x 18.8 cm，选择机箱的时候需要注意尺寸。</p>
<p>可惜H310的这块板的机箱也比较小，只适合放1块3.5寸硬盘+1块2.5寸硬盘，无法容纳多块3.5寸硬盘，这就很难受。</p>
<p>综上所述，基本硬件都满足，但是机箱是必须要买一个新的。</p>
<h4 id="机箱选型"><a href="#机箱选型" class="headerlink" title="机箱选型"></a>机箱选型</h4><p>有了主板规格：7.5-in x 7.4-in, 19.1 cm x 18.8 cm，现在可以确定机箱尺寸了，必须得容纳M-ATX的机箱。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>蜗牛星际A</th>
<th>乔伯斯</th>
<th>金河田N1</th>
</tr>
</thead>
<tbody><tr>
<td>主板</td>
<td>ITX</td>
<td>ITX</td>
<td>M-ATX</td>
</tr>
<tr>
<td>电源</td>
<td>1U</td>
<td>SFX</td>
<td>SFX</td>
</tr>
<tr>
<td>硬盘位</td>
<td>4</td>
<td>1~4</td>
<td>2~6</td>
</tr>
<tr>
<td>价格</td>
<td>100~500</td>
<td>100~400</td>
<td>100~200</td>
</tr>
</tbody></table>
<p>特别漂亮的一款机箱，乔伯斯N1支持1+5盘位，就是价格有点不美丽，得6百多左右。</p>
<p>其实对于机箱来说只要主板放的下，硬盘的摆放位置并不局限于机箱的硬盘位，完全可以使用硬盘支架等方式来灵活摆放。</p>
<p><img data-src="https://img.econow.cn/medivh/1669259101960.png" alt="1669259101960.png"></p>
<p>最终选择的是金河田N1一番魔改后，装上6~8块盘不成问题。小黄鱼上虽然价格低，但基本都得自提，快递不合适。PDD上的价格还行，到手100出头。</p>
<p><img data-src="https://img.econow.cn/medivh/1669259440233.png" alt="1669259440233.png"></p>
<p><img data-src="https://img.econow.cn/medivh/1669259453509.png" alt="1669259453509.png"></p>
<p><img data-src="https://img.econow.cn/medivh/1669259478218.png" alt="1669259478218.png"></p>
<h2 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h2><p><img data-src="https://img.econow.cn/medivh/1669259885359.png" alt="1669259885359.png"></p>
<p>电源的规格其实不太适合手头上有的这个STX电源，没办法，只能找东西在下面撑住。</p>
<p><img data-src="https://img.econow.cn/medivh/1669259893408.png" alt="1669259893408.png"></p>
<p>手里暂时只有一块硬盘，之后有了新的再装上。</p>
<p><img data-src="https://img.econow.cn/medivh/1669259903256.png" alt="1669259903256.png"></p>
<p>走线有点凌乱，但是先点亮再说吧。</p>
<p>安装完成的背板。</p>
<p><img data-src="https://img.econow.cn/medivh/1669259910747.png" alt="1669259910747.png"></p>
<p>接线的时候大部分接口都没啥问题，但是机箱的电源线就有点复杂了，可以参考说明书。好在主板上会有说明：</p>
<p><img data-src="https://img.econow.cn/medivh/1669260754443.png" alt="1669260754443.png"></p>
<p>对照着上下两张图接线即可，如果一次失败就检查一下是哪部分的问题。</p>
<p><img data-src="https://img.econow.cn/medivh/1669260764163.png" alt="1669260764163.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从开始到点亮用了挺长一段时间，大部分时间用来查找资料，小部分时间用来等快递了。纠结了挺长一段时间的机箱选型，最终才决定了金河田N1.</p>
<p>下一篇具体记录一下系统的安装和配置，以及避坑操作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.asrockchina.com.cn/mb/Intel/H310CM-HDV/index.cn.asp#Specification">华擎 H310CM-HDV主板的详细资料</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/333489243">主板接口科普</a></li>
</ul>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nas</tag>
        <tag>pve</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（三）</title>
    <url>//%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89</url>
    <content><![CDATA[<p>NAS专栏：</p>
<ul>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（一）</a></li>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（二）</a></li>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（三）</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虚拟化平台搭建好了，现在开始创建一台trues的虚拟机。TruesNAS 是之前选择的系统，其中Enterprise 是付费版，Scale是要使用的系统。</p>
<p><img data-src="https://img.econow.cn/medivh/1669279439301.png" alt="1669279439301.png"></p>
<p>功能概览：</p>
<p><img data-src="https://img.econow.cn/medivh/1669280893833.png" alt="1669280893833.png"></p>
<p>路线图</p>
<p><img data-src="https://img.econow.cn/medivh/1669280910986.png" alt="1669280910986.png"></p>
<p>下载</p>
<p><img data-src="https://img.econow.cn/medivh/1669281008839.png" alt="1669281008839.png"></p>
<p><a href="https://download.truenas.com/TrueNAS-SCALE-Angelfish/22.02.4/TrueNAS-SCALE-22.02.4.iso">下载链接</a></p>
<p>网盘目录里存放了从官网下载的系统镜像，可以直接下载<a href="https://pan.baidu.com/s/1apBdslCrIvDhZ8ii5hGAlQ?pwd=1gtj">百度网盘</a> 提取码: 1gtj 。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>该部分很简单，在PVE创建虚拟机的时候选择镜像，基本按照默认选择安装即可。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>访问登录地址<a href="http://ip/">http://ip</a></p>
<p><img data-src="https://img.econow.cn/medivh/1669281872868.png" alt="1669281872868.png"></p>
<p>登录后就会看到Dashboard</p>
<p><img data-src="https://img.econow.cn/medivh/1669281972621.png" alt="1669281972621.png"></p>
<p>本地化设置在 系统设置-》常规-》本地化—》选择语言和时区</p>
<h4 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h4><p>网络-》接口，点击</p>
<p><img data-src="https://img.econow.cn/medivh/1669282030229.png" alt="1669282030229.png"></p>
<p>取消勾选DHCP，添加新的IP，然后应用</p>
<p><img data-src="https://img.econow.cn/medivh/1669282087934.png" alt="1669282087934.png"></p>
<p>注意点击应用后要点击测试更改，然后在60s内使用新的IP访问，否则修改无效。</p>
<p><img data-src="https://img.econow.cn/medivh/1669282158314.png" alt="1669282158314.png"></p>
<p>根据自己需要填写DNS和网关。需要注意的是NetBIOS-NS需要勾选，否则部分设备无法发现，比如小米摄像头。</p>
<p><img data-src="https://img.econow.cn/medivh/1669282252379.png" alt="1669282252379.png"></p>
<h4 id="Docker源"><a href="#Docker源" class="headerlink" title="Docker源"></a>Docker源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;data-root&quot;</span>: <span class="string">&quot;/mnt/free/ix-applications/docker&quot;</span>, <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=cgroupfs&quot;</span>], <span class="string">&quot;iptables&quot;</span>: <span class="literal">false</span>, <span class="string">&quot;bridge&quot;</span>: <span class="string">&quot;none&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="存储设置"><a href="#存储设置" class="headerlink" title="存储设置"></a>存储设置</h4><p>TrueNAS存储顺序为内存-&gt;缓存存储池-&gt;数据存储池。</p>
<p>一个存储池可以由多个Vdev组成，而Vdev可以有多种类型。</p>
<p><img data-src="https://img.econow.cn/medivh/1669604121682.png" alt="1669604121682.png"></p>
<h5 id="Vdev类型"><a href="#Vdev类型" class="headerlink" title="Vdev类型"></a>Vdev类型</h5><p>Vdev有以下六种类型：<br>参考：Creating Pools | (truenas.com)</p>
<h6 id="1、Data"><a href="#1、Data" class="headerlink" title="1、Data"></a>1、Data</h6><p>基础Vdev，用于存储数据，一个存储池至少有一个Data Vdev。</p>
<p>可以在一个池里添加多个Data Vdev，多个Data Vdev可以组成相关阵列，而一个Data Vdev又可以由多块硬盘组成的阵列构成。</p>
<h6 id="2、Cache"><a href="#2、Cache" class="headerlink" title="2、Cache"></a>2、Cache</h6><p>ZFS L2ARC读取缓存可与快速设备一起使用以加速读取操作。相当于二级缓存，保存从内存里面调出的数据，下次直接从固态硬盘中调出。建议64G内存以上的用户使用此Vdev，不要超过内存的5倍。推荐用固态硬盘当缓存Vdev，容量不需太大，64G存最好不要超过300G容量，多了反而会增加内存的消耗。</p>
<p>How Does L2ARC Work?<br>当系统收到读请求时，ZFS使用ARC (RAM)来处理这些请求。当ARC满了，并且有L2ARC驱动器分配给ZFS池时，ZFS使用L2ARC来处理从ARC溢出的读请求。这减少了使用较慢的硬盘驱动器，从而提高了系统性能。</p>
<p>更多内容可查看官方说明：L2ARC | (truenas.com)</p>
<h6 id="3、Log"><a href="#3、Log" class="headerlink" title="3、Log"></a>3、Log</h6><p>ZFS日志设备，提高同步写速度，日志设备的最小大小与池中每个设备的最小大小 (64 MB) 相同。可能存储在日志设备中的相关的数据量相对较小。提交日志事务（系统调用）时将释放日志块。日志设备的最大大小应大约为物理内存大小的 1&#x2F;2，因为这是可存储的最大潜在相关的数据量。例如，如果系统的物理内存为 16 GB，请考虑 8 GB 的最大日志设备大小。</p>
<p>ZFS intent log（ZIL）通常被称为日志，其主要目的是数据完整性。ZIL的存在是为了跟踪正在进行的同步写操作。如果系统崩溃或断电，ZIL可以重放操作。当您在电源故障时丢失一个标准的系统缓存时，一个ZIL在系统重新启动时仍然存在。</p>
<p>ZFS数据池使用一个存储在磁盘上的ZIL来记录同步写入，然后再刷新到存储中的最终位置。这意味着同步写操作以存储池的速度进行，并且必须写入存储池两次或两次以上(取决于磁盘冗余)。</p>
<p>更多内容可查看官方说明：SLOG Devices | (truenas.com)</p>
<h6 id="4、Hot-Spare"><a href="#4、Hot-Spare" class="headerlink" title="4、Hot Spare"></a>4、Hot Spare</h6><p>热备盘是指当主用磁盘故障时，预留插入Data vdev的磁盘。热备盘用于临时替换故障驱动器，以防止出现更大的池和数据丢失的情况。 当新硬盘替换故障硬盘时，热备盘恢复为非激活状态，重新作为热备盘使用。 当故障驱动器仅从池中分离时，临时热备盘将被提升为Data vdev的成员，不再作为热备盘可用。</p>
<h6 id="5、Metadata"><a href="#5、Metadata" class="headerlink" title="5、Metadata"></a>5、Metadata</h6><p>用于创建Fusion Pools的特殊分配类，以提高元数据和小块 i&#x2F;o 性能。</p>
<h6 id="6、Dedup"><a href="#6、Dedup" class="headerlink" title="6、Dedup"></a>6、Dedup</h6><p>Dedup vde用于存储ZFS池中的重复删除数据。需要为每X TiB的通用存储分配X GiB。例如，1 GiB的Dedup vdev容量对应1 TiB的Data vdev可用容量。</p>
<p>根据特定的池用例，添加到vdev中的磁盘以不同的布局排列。不支持将多个具有不同布局的vdev添加到池中。当需要不同的vdev布局时，创建一个新的池。例如，pool1中有一个镜像布局的数据vdev，新创建一个poo2，将raid-z布局的vdev添加到pool2中。</p>
<h5 id="RAID介绍"><a href="#RAID介绍" class="headerlink" title="RAID介绍"></a>RAID介绍</h5><p>条带：与RAID0类似，不过可以不同大小的硬盘组<br>镜像：与RAID1类似，磁盘镜像，至少需要两个磁盘。<br>RAIDZ1：与RAID5类似，一重奇偶校验，至少需要三块磁盘；可以坏一块硬盘不丢数据。容量和速度为N-1(N为硬盘数量)<br>RAIDZ2：与RAID6类似，双重奇偶校验，至少需要四个磁盘；可以坏2块硬盘不丢数据。容量和速度为N-2(N为硬盘数量)<br>RAIDZ3：ZFS特有的，三重奇偶校验，至少需要5个磁盘；可以坏3块盘不丢数据。容量和速度为N-3(N为硬盘数量)</p>
<p>创建新的池，选择磁盘，此处磁盘已经使用，所以显示为空。</p>
<p><img data-src="https://img.econow.cn/medivh/1669282473343.png" alt="1669282473343.png"></p>
<p>下面是使用了一段时间后的情况</p>
<p><img data-src="https://img.econow.cn/medivh/1669282672229.png" alt="1669282672229.png"></p>
<h4 id="SMB服务"><a href="#SMB服务" class="headerlink" title="SMB服务"></a>SMB服务</h4><p>首先需要创建用户，我这里是给摄像头使用的</p>
<p><img data-src="https://img.econow.cn/medivh/1669282731973.png" alt="1669282731973.png"></p>
<p>该部分需要注意主目录的位置，可以输入后自动创建并使用，其他保持默认即可。</p>
<p><img data-src="https://img.econow.cn/medivh/1669282798780.png" alt="1669282798780.png"></p>
<p>下一步需要启动服务</p>
<p><img data-src="https://img.econow.cn/medivh/1669282892634.png" alt="1669282892634.png"></p>
<p>对于小米摄像头来说需要启动SMB1。</p>
<p><img data-src="https://img.econow.cn/medivh/1669282926386.png" alt="1669282926386.png"></p>
<p>输入账号密码，很完美。</p>
<p><img data-src="https://img.econow.cn/medivh/1669283126821.png" alt="1669283126821.png"></p>
<h3 id="NextCloud"><a href="#NextCloud" class="headerlink" title="NextCloud"></a>NextCloud</h3><p>选择应用-》nextcloud</p>
<p><img data-src="https://img.econow.cn/medivh/1669284054845.png" alt="1669284054845.png"></p>
<p>账号密码和IP都可以自定义，也可以不修改</p>
<p><img data-src="https://img.econow.cn/medivh/1669284154262.png" alt="1669284154262.png"></p>
<p>添加两个环境变量<code>PHP_UPLOAD_LIMIT</code>和<code>PHP_MEMORY_LIMIT</code>，为了之后上传大文件</p>
<p><img data-src="https://img.econow.cn/medivh/1669284183021.png" alt="1669284183021.png"></p>
<p>存储这块建议使用host模式，自定义存储路径</p>
<p><img data-src="https://img.econow.cn/medivh/1669284272303.png" alt="1669284272303.png"></p>
<p>其余项目使用默认设置即可，保存后系统会自动部署。</p>
<p>当此处展示为ACTIVE，点击Web Portal即可</p>
<p><img data-src="https://img.econow.cn/medivh/1669284354369.png" alt="1669284354369.png"></p>
<h4 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h4><p>修改config.php文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;memcache.distributed&#x27;</span> =&gt; <span class="string">&#x27;\OC\Memcache\Redis&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;redis&#x27;</span> =&gt; array(</span><br><span class="line"><span class="string">&#x27;host&#x27;</span> =&gt; 192.168.31.82,</span><br><span class="line"><span class="string">&#x27;port&#x27;</span> =&gt; 6379,</span><br></pre></td></tr></table></figure>

<h4 id="开启上传不限速"><a href="#开启上传不限速" class="headerlink" title="开启上传不限速"></a>开启上传不限速</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> --user www-data CONTAINER_ID  php occ config:app:<span class="built_in">set</span> files max_chunk_size --value 0</span><br></pre></td></tr></table></figure>

<h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><ul>
<li>镜像下载不下来<ul>
<li>修改docker为国内源</li>
</ul>
</li>
<li>上传大文件提示服务器错误<ul>
<li>添加参数<ul>
<li>PHP_UPLOAD_LIMIT&#x3D;16G</li>
<li>PHP_MEMORY_LIMIT&#x3D;16G</li>
<li>LimitRequestBody 0 添加至html目录下的.htaccess文件</li>
</ul>
</li>
</ul>
</li>
<li>为Nextcloud手动添加文件-使后台上传的文件在Nextcloud中显示<ul>
<li>sudo -u www-data php occ files:scan –all</li>
</ul>
</li>
<li>为Nextcloud添加其他目录<ul>
<li>可以在应用添加扩展host挂载目录</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>安装系统其实没什么难度，困难的是后续的应用配置。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.truenas.com/">https://www.truenas.com/</a></li>
<li><a href="https://www.truenas.com/truenas-scale/">https://www.truenas.com/truenas-scale/</a></li>
<li><a href="https://www.truenas.com/docs/">https://www.truenas.com/docs/</a></li>
</ul>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nas</tag>
        <tag>pve</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（二）</title>
    <url>//%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89</url>
    <content><![CDATA[<p>NAS专栏：</p>
<ul>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（一）</a></li>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（二）</a></li>
<li><a href="https://econow.cn/%E5%9F%BA%E4%BA%8EPVE%E5%B9%B3%E5%8F%B0%E7%9A%84TrueNAS_Scale+NextCloud%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89.html#more">基于PVE平台的TrueNAS_Scale+NextCloud的实践总结（三）</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章中记录了软件和硬件的选型，这篇记录虚拟化系统安装和使用的坎坷。</p>
<h3 id="PVE简介"><a href="#PVE简介" class="headerlink" title="PVE简介"></a>PVE简介</h3><p>Proxmox VE is a complete, open-source server management platform for enterprise virtualization. It tightly integrates the KVM hypervisor and Linux Containers (LXC), software-defined storage and networking functionality, on a single platform. With the integrated web-based user interface you can manage VMs and containers, high availability for clusters, or the integrated disaster recovery tools with ease.</p>
<p>啥意思呢？就是说PVE是一个成型和开源的虚拟化管理平台。它将KVM管理程序和Linux容器（LXC）、软件定义的存储和网络功能紧密集成在一个平台上。使用集成的基于web的用户界面，您可以轻松管理VM和容器、群集的高可用性或集成的灾难恢复工具。</p>
<p><img data-src="https://img.econow.cn/medivh/1669274054326.png" alt="1669274054326.png"></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>KVM&amp;Container<ul>
<li>PVE 基于Debian系统</li>
<li>KVM是业界领先的用于完全虚拟化的Linux虚拟化技术。它是一个内核模块，被合并到主线Linux内核中，在所有支持Intel VT-x或AMD-V虚拟化的x86硬件上以接近本机的性能运行</li>
<li>Proxmox VE自2008年项目开始（即从0.9beta2版开始）就包含了KVM支持</li>
<li>基于容器的虚拟化技术是全机虚拟化的轻量级替代方案，因为它共享主机系统的内核</li>
<li>LXC是一个操作系统级虚拟化环境，用于在单个Linux控制主机上运行多个独立的Linux系统。LXC作为Linux内核包含特性的用户空间界面。用户可以使用强大的API和简单的工具轻松创建和管理系统或应用程序容器</li>
</ul>
</li>
<li>管理<ul>
<li>web页面管理</li>
<li>命令行操作</li>
<li>移动端操作（HTML5）</li>
<li>离线&#x2F;在线迁移到不同节点</li>
<li>Rest API</li>
<li>角色管理</li>
<li>认证管理</li>
</ul>
</li>
<li>HA 集群</li>
<li>网络 每个节点最多支持4094个桥接</li>
<li>存储<ul>
<li>网络存储<ul>
<li>LVM Group (network backing with iSCSI targets)</li>
<li>iSCSI target</li>
<li>NFS Share</li>
<li>SMB&#x2F;CIFS</li>
<li>Ceph RBD</li>
<li>Direct to iSCSI LUN</li>
<li>GlusterFS</li>
<li>CephFS</li>
</ul>
</li>
<li>本地存储<ul>
<li>LVM</li>
<li>Directory (storage on an existing filesystem)</li>
<li>ZFS</li>
</ul>
</li>
</ul>
</li>
<li>备份</li>
<li>防火墙</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>访问官网<a href="https://www.proxmox.com/en/downloads">下载链接</a>，注意选择的是Proxmox VE，不要选择成Proxmox Backup Server。</p>
<p><img data-src="https://img.econow.cn/medivh/1669272337063.png" alt="1669272337063.png"></p>
<p>网盘目录里存放了从官网下载的系统镜像，可以直接下载<a href="https://pan.baidu.com/s/1apBdslCrIvDhZ8ii5hGAlQ?pwd=1gtj">百度网盘</a> 提取码: 1gtj 。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装最小需求：</p>
<ul>
<li>CPU: 64bit (Intel EMT64 or AMD64)</li>
<li>Intel VT&#x2F;AMD-V capable CPU&#x2F;Mainboard for KVM full virtualization support</li>
<li>RAM: 1 GB RAM, plus additional RAM needed for guests</li>
<li>Hard drive</li>
<li>One network card (NIC)</li>
</ul>
<h3 id="镜像刻录"><a href="#镜像刻录" class="headerlink" title="镜像刻录"></a>镜像刻录</h3><p>推荐使用balenaEtcher，真的很好用，极简模式。<br><img data-src="https://img.econow.cn/medivh/1669273791797.png" alt="1669273791797.png"></p>
<h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><blockquote>
<p>截图是从官网来的，配置信息仅供参考</p>
</blockquote>
<p>选择install</p>
<p><img data-src="https://img.econow.cn/medivh/1669274996097.png" alt="1669274996097.png"></p>
<p>选择时区</p>
<p><img data-src="https://img.econow.cn/medivh/1669275081131.png" alt="1669275081131.png"></p>
<p>输入密码和邮箱</p>
<p><img data-src="https://img.econow.cn/medivh/1669275107625.png" alt="1669275107625.png"></p>
<p>配置网络</p>
<p><img data-src="https://img.econow.cn/medivh/1669275182405.png" alt="1669275182405.png"></p>
<p>继续安装</p>
<p><img data-src="https://img.econow.cn/medivh/1669275132232.png" alt="1669275132232.png"></p>
<p>确认信息</p>
<p><img data-src="https://img.econow.cn/medivh/1669275233980.png" alt="1669275233980.png"></p>
<p>安装完成后重启即可，访问地址为<a href="https://ip:8006/">https://IP:8006</a></p>
<p><img data-src="https://img.econow.cn/medivh/1669275401416.png" alt="1669275401416.png"></p>
<p>上面是我已经运行了一段时间的截图。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先在登录界面可以先把语言设置成简体中文，输入用户名和密码登录，用户名为root，密码就是安装时设置的密码。</p>
<p><img data-src="https://img.econow.cn/medivh/1669278628372.png" alt="1669278628372.png"></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="cpu模式"><a href="#cpu模式" class="headerlink" title="cpu模式"></a>cpu模式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install cpufrequtils  <span class="comment">#安装驱动</span></span><br><span class="line"></span><br><span class="line">ondemand：系统默认的超频模式，按需调节，内核提供的功能，不是很强大，但有效实现了动态频率调节，平时以低速方式运行，当系统负载提高时候自动提高频率。以这种模式运行不会因为降频造成性能降低，同时也能节约电能和降低温度。一般官方内核默认的方式都是ondemand。</span><br><span class="line"> </span><br><span class="line">interactive：交互模式，直接上最高频率，然后看CPU负荷慢慢降低，比较耗电。Interactive 是以 CPU 排程数量而调整频率，从而实现省电。InteractiveX 是以 CPU 负载来调整 CPU 频率，不会过度把频率调低。所以比 Interactive 反应好些，但是省电的效果一般。</span><br><span class="line"> </span><br><span class="line">conservative：保守模式，类似于ondemand，但调整相对较缓，想省电就用他吧。Google官方内核，kang内核默认模式。</span><br><span class="line"> </span><br><span class="line">smartass：聪明模式，是I和C模式的升级，该模式在比interactive 模式不差的响应的前提下会做到了更加省电。</span><br><span class="line"> </span><br><span class="line">performance：性能模式！只有最高频率，从来不考虑消耗的电量，性能没得说，但是耗电量。</span><br><span class="line"> </span><br><span class="line">powersave 省电模式，通常以最低频率运行。</span><br><span class="line"> </span><br><span class="line">userspace：用户自定义模式，系统将变频策略的决策权交给了用户态应用程序，并提供了相应的接口供用户态应用程序调节CPU 运行频率使用。也就是长期以来都在用的那个模式。可以通过手动编辑配置文件进行配置</span><br><span class="line"> </span><br><span class="line">Hotplug：类似于ondemand, 但是cpu会在关屏下尝试关掉一个cpu，并且带有deep <span class="built_in">sleep</span>，比较省电。</span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpufreq-info <span class="comment"># 查看信息</span></span><br></pre></td></tr></table></figure>

<h4 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h4><p>配置文件位置 &#x2F;etc&#x2F;init.d&#x2F;cpufrequtils  查找GOVERNOR内容替换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/init.d/cpufrequtils</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">ENABLE=<span class="string">&quot;true&quot;</span>   </span><br><span class="line">GOVERNOR=<span class="string">&quot;conservative&quot;</span>  <span class="comment">#运行模式,依照需求调整</span></span><br><span class="line">MAX_SPEED=<span class="string">&quot;2800&quot;</span>         <span class="comment">#上限</span></span><br><span class="line">MIN_SPEED=<span class="string">&quot;1200&quot;</span>         <span class="comment">#下限</span></span><br><span class="line"> </span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h3 id="解除弹窗"><a href="#解除弹窗" class="headerlink" title="解除弹窗"></a>解除弹窗</h3><p>登陆后会弹出一个恼人的提示，不会有什么影响但是每次登录都弹窗也是很烦的，还有在概要里面看不到CPU的温度也很不方便，接下来用大佬的一个脚本来解决这两个问题。</p>
<p><img data-src="https://img.econow.cn/medivh/1669278673588.png" alt="1669278673588.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 JS 源码</span></span><br><span class="line">sed -Ezi.bak <span class="string">&quot;s/(Ext.Msg.show\(\&#123;\s+title: gettext\(&#x27;No valid sub)/void\(\&#123; \/\/\1/g&quot;</span> /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 PVE 服务</span></span><br><span class="line">systemctl restart pveproxy.service</span><br></pre></td></tr></table></figure>

<h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释企业源</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#deb https://enterprise.proxmox.com/debian/pve bullseye pve-enterprise&quot;</span> &gt; /etc/apt/sources.list.d/pve-enterprise.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># PVE 软件源更换</span></span><br><span class="line">wget https://mirrors.ustc.edu.cn/proxmox/debian/proxmox-release-bullseye.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bullseye.gpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/pve bullseye pve-no-subscription&quot;</span> &gt; /etc/apt/sources.list.d/pve-no-subscription.list</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/ceph-pacific bullseye main&quot;</span> &gt; /etc/apt/sources.list.d/ceph.list</span><br><span class="line"></span><br><span class="line">sed -i.bak <span class="string">&quot;s#http://download.proxmox.com/debian#https://mirrors.ustc.edu.cn/proxmox/debian#g&quot;</span> /usr/share/perl5/PVE/CLI/pveceph.pm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debian 系统源更换</span></span><br><span class="line">sed -i.bak <span class="string">&quot;s#ftp.debian.org/debian#mirrors.aliyun.com/debian#g&quot;</span> /etc/apt/sources.list</span><br><span class="line">sed -i <span class="string">&quot;s#security.debian.org#mirrors.aliyun.com/debian-security#g&quot;</span> /etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://download.proxmox.com/debian/pve bullseye pve-no-subscription&quot;</span> &gt;&gt;  /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新测试一下</span></span><br><span class="line">apt update</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><p>首先需要系统镜像，可以上传，也可以从URL下载：<br><img data-src="https://img.econow.cn/medivh/1669275824568.png" alt="1669275824568.png"></p>
<p>名称是必填的，VM ID 是按照从100开始按照顺序来的，如果创建后删除再创建，那么ID还是100.开机启动，自己来决定是否需要。</p>
<p><img data-src="https://img.econow.cn/medivh/1669276037929.png" alt="1669276037929.png"></p>
<p>点击下拉选择镜像，如果是Linux 系统的话，默认即可。但是如果是Windows系统，则需要注意选择正确的系统版本，否则会报无法引导的错误。</p>
<p><img data-src="https://img.econow.cn/medivh/1669276255434.png" alt="1669276255434.png"></p>
<p>磁盘可以填写合适的大小。</p>
<p><img data-src="https://img.econow.cn/medivh/1669276343155.png" alt="1669276343155.png"></p>
<p>下一步选择CPU类别，注意选择host，以及核心数。</p>
<p><img data-src="https://img.econow.cn/medivh/1669277576600.png" alt="1669277576600.png"></p>
<p>内存就正常写就可以了。</p>
<p><img data-src="https://img.econow.cn/medivh/1669277606801.png" alt="1669277606801.png"></p>
<p>网络模式默认即可。</p>
<p><img data-src="https://img.econow.cn/medivh/1669277629216.png" alt="1669277629216.png"></p>
<p>最后确认启动就可以了。</p>
<p><img data-src="https://img.econow.cn/medivh/1669277652385.png" alt="1669277652385.png"></p>
<h3 id="虚拟机的使用"><a href="#虚拟机的使用" class="headerlink" title="虚拟机的使用"></a>虚拟机的使用</h3><p>以105这台机器举例：</p>
<ul>
<li>概要 展示虚拟机的监控，比如CPU、内存、网络和磁盘</li>
<li>控制台</li>
<li>硬件  展示硬件的详情</li>
</ul>
<p><img data-src="https://img.econow.cn/medivh/1669277751784.png" alt="1669277751784.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，成功的创建了虚拟机，为后续的NAS系统安装打下了基础。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pve.proxmox.com/pve-docs/pve-admin-guide.html">https://pve.proxmox.com/pve-docs/pve-admin-guide.html</a></li>
<li><a href="https://www.proxmox.com/en/proxmox-ve">https://www.proxmox.com/en/proxmox-ve</a></li>
</ul>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nas</tag>
        <tag>pve</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>基于registry的Harbor镜像仓库部署</title>
    <url>/%E5%9F%BA%E4%BA%8Eregistry%E7%9A%84Harbor%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<blockquote>
<p>Harbor 是 Vmwar 公司开源的 企业级的 Docker Registry 管理项目 它主要 提供 Dcoker Registry 管理UI，可基于角色访问控制, AD&#x2F;LDAP 集成，日志审核等功能，完全的支持中文。 Harbor 的所有组件都在 Dcoker 中部署，所以 Harbor 可使用 Docker Compose 快速部署。</p>
</blockquote>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Harbor，是一个英文单词，意思是港湾，港湾是干什么的呢，就是停放货物的，而货物呢，是装在集装箱中的，说到集装箱，就不得不提到Docker容器，因为docker容器的技术正是借鉴了集装箱的原理。所以，Harbor正是一个用于存储Docker镜像的企业级Registry服务。</p>
<p>Registry是Dcoker官方的一个私有仓库镜像，可以将本地的镜像打标签进行标记然后push到以Registry起的容器的私有仓库中。企业可以根据自己的需求，使用Dokcerfile生成自己的镜像，并推到私有仓库中，这样可以大大提高拉取镜像的效率。</p>
<h3 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h3><p>Harbor和Registry都是Docker的镜像仓库，但是Harbor作为更多企业的选择，是因为相比较于Regisrty来说，它具有很多的优势。</p>
<ul>
<li>1.提供分层传输机制，优化网络传输<br>Docker镜像是是分层的，而如果每次传输都使用全量文件(所以用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定传输的对象。</li>
<li>2.提供WEB界面，优化用户体验<br>只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界面可以支持登陆、搜索功能，包括区分公有、私有镜像。</li>
<li>3.支持水平扩展集群<br>当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。</li>
<li>4.良好的安全机制<br>企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。</li>
<li>5.Harbor提供了基于角色的访问控制机制，并通过项目来对镜像进行组织和访问权限的控制。kubernetes中通过namespace来对资源进行隔离，在企业级应用场景中，通过将两者进行结合可以有效将kubernetes使用的镜像资源进行管理和访问控制，增强镜像使用的安全性。尤其是在多租户场景下，可以通过租户、namespace和项目相结合的方式来实现对多租户镜像资源的管理和访问控制。</li>
</ul>
<h3 id="2、核心组件"><a href="#2、核心组件" class="headerlink" title="2、核心组件"></a>2、核心组件</h3><ul>
<li>Proxy：他是一个nginx的前端代理，代理Harbor的registry,UI, token等服务。</li>
<li>db：负责储存用户权限、审计日志、Dockerimage分组信息等数据。</li>
<li>UI：提供图形化界面，帮助用户管理registry上的镜像, 并对用户进行授权。</li>
<li>jobsevice：jobsevice是负责镜像复制工作的，他和registry通信，从一个registry pull镜像然后push到另一个registry，并记录job_log。</li>
<li>Adminserver：是系统的配置管理中心附带检查存储用量，ui和jobserver启动时候回需要加载adminserver的配置。</li>
<li>Registry：镜像仓库，负责存储镜像文件。</li>
<li>Log：为了帮助监控Harbor运行，负责收集其他组件的log，供日后进行分析。</li>
</ul>
<h2 id="二、安装部署"><a href="#二、安装部署" class="headerlink" title="二、安装部署"></a>二、安装部署</h2><h3 id="1、环境要求"><a href="#1、环境要求" class="headerlink" title="1、环境要求"></a>1、环境要求</h3><h4 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h4><table>
<thead>
<tr>
<th>Resource</th>
<th>Capacity</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>minimal 2 CPU</td>
<td>4 CPU is preferred</td>
</tr>
<tr>
<td>Mem</td>
<td>minimal 4GB</td>
<td>8GB is preferred</td>
</tr>
<tr>
<td>Disk</td>
<td>minimal 40GB</td>
<td>160GB is preferred</td>
</tr>
</tbody></table>
<h4 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h4><table>
<thead>
<tr>
<th>Software</th>
<th>Version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Python</td>
<td>version 2.7 or higher</td>
<td>Note that you may have to install Python on Linux distributions (Gentoo, Arch) that do not come with a Python interpreter installed by default</td>
</tr>
<tr>
<td>Docker engine</td>
<td>version 1.10 or higher</td>
<td>For installation instructions, please refer to: <a href="https://docs.docker.com/engine/installation/">https://docs.docker.com/engine/installation/</a></td>
</tr>
<tr>
<td>Docker Compose</td>
<td>version 1.6.0 or higher</td>
<td>For installation instructions, please refer to: <a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></td>
</tr>
<tr>
<td>Openssl</td>
<td>latest is preferred</td>
<td>Generate certificate and keys for Harbor</td>
</tr>
</tbody></table>
<h4 id="Network-ports"><a href="#Network-ports" class="headerlink" title="Network ports"></a>Network ports</h4><table>
<thead>
<tr>
<th>Port</th>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>443</td>
<td>HTTPS</td>
<td>Harbor portal and core API will accept requests on this port for https protocol</td>
</tr>
<tr>
<td>4443</td>
<td>HTTPS</td>
<td>Connections to the Docker Content Trust service for Harbor, only needed when Notary is enabled</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>Harbor portal and core API will accept requests on this port for http protocol</td>
</tr>
</tbody></table>
<h4 id="Docker-相关"><a href="#Docker-相关" class="headerlink" title="Docker 相关"></a>Docker 相关</h4><p>安装docker-compose</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install python-pip</span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>

<h3 id="2、安装方式"><a href="#2、安装方式" class="headerlink" title="2、安装方式"></a>2、安装方式</h3><h4 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h4><p>该方式从Docker hub下载Harbor相关镜像，安装包较小。</p>
<h4 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h4><ul>
<li>正常安装版 <a href="https://img.econow.cn/harbor-offline-installer-v1.2.2.tgz">https://img.econow.cn/harbor-offline-installer-v1.2.2.tgz</a> 推荐使用此方式靠谱。</li>
<li>github下载最新版 <a href="https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.5.tgz">Harbor offline installer</a></li>
</ul>
<h3 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src</span><br><span class="line">wget https://img.econow.cn/harbor-offline-installer-v1.2.2.tgz](https://img.econow.cn/harbor-offline-installer-v1.2.2.tgz</span><br><span class="line">tar -zxvf  harbor-offline-installer-v1.2.2.tgz -C /opt/harbor</span><br></pre></td></tr></table></figure>

<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>vim harbor.cfg</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Configuration file of Harbor</span></span><br><span class="line"><span class="comment"># hostname 设置访问地址，支持IP，域名，主机名，禁止设置127.0.0.1</span></span><br><span class="line"><span class="comment"># 必须修改！！！</span></span><br><span class="line">hostname = 内网ip</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 访问协议，可设置 http,https</span></span><br><span class="line">ui_url_protocol = http</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 邮件通知, 配置邮件通知。</span></span><br><span class="line">email_server = smtp.mydomain.com</span><br><span class="line">email_server_port = 25</span><br><span class="line">email_username = sample_admin@mydomain.com</span><br><span class="line">email_password = abc</span><br><span class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># harbor WEB UI登陆使用的密码</span></span><br><span class="line">harbor_admin_password = Harbor12345</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 认证方式，这里支持多种认证方式，默认是 db_auth ，既mysql数据库存储认证。</span></span><br><span class="line"><span class="comment"># 这里还支持 ldap 以及 本地文件存储方式。</span></span><br><span class="line">auth_mode = db_auth</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql root 账户的 密码</span></span><br><span class="line">db_password = root123</span><br><span class="line"><span class="comment"># 默认密码应该是root，反正root123的时候我登不进去</span></span><br><span class="line">self_registration = on</span><br><span class="line">use_compressed_js = on</span><br><span class="line">max_job_workers = 3</span><br><span class="line">verify_remote_cert = on</span><br><span class="line">customize_crt = on</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 一些显示的设置.</span></span><br><span class="line">crt_country = CN</span><br><span class="line">crt_state = State</span><br><span class="line">crt_location = CN</span><br><span class="line">crt_organization = organization</span><br><span class="line">crt_organizationalunit = organizational unit</span><br><span class="line">crt_commonname = example.com</span><br><span class="line">crt_email = example@example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1、修改80端口为5000"><a href="#1、修改80端口为5000" class="headerlink" title="1、修改80端口为5000"></a>1、修改80端口为5000</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim docker-compose.yml</span></span><br><span class="line">proxy:</span><br><span class="line">image: vmware/nginx-photon:1.11.13</span><br><span class="line">container_name: nginx</span><br><span class="line">restart: always</span><br><span class="line">volumes:</span><br><span class="line">- ./common/config/nginx:/etc/nginx:z</span><br><span class="line">networks:</span><br><span class="line">- harbor</span><br><span class="line">ports:</span><br><span class="line">- 5000:80</span><br><span class="line">- 443:443</span><br><span class="line">- 4443:4443</span><br><span class="line">depends_on:</span><br><span class="line">- mysql</span><br><span class="line">- registry</span><br><span class="line">- ui</span><br><span class="line">- <span class="built_in">log</span></span><br><span class="line">logging:</span><br><span class="line">driver: <span class="string">&quot;syslog&quot;</span></span><br><span class="line">options:</span><br><span class="line">syslog-address: <span class="string">&quot;tcp://127.0.0.1:1514&quot;</span></span><br><span class="line">tag: <span class="string">&quot;proxy&quot;</span></span><br></pre></td></tr></table></figure>

<p>处理模板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim common/templates/registry/config.yml</span></span><br><span class="line">auth:</span><br><span class="line">token:</span><br><span class="line">issuer: registry-token-issuer</span><br><span class="line">realm: <span class="variable">$ui_url</span>:5000/service/token</span><br><span class="line">rootcertbundle: /etc/registry/root.crt</span><br><span class="line">service: token-service</span><br></pre></td></tr></table></figure>

<p>启动，执行安装，加载镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>更改配置后执行 prepare 脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./prepare</span><br><span class="line"></span><br><span class="line">Generated configuration file: ./config/ui/env</span><br><span class="line">Generated configuration file: ./config/ui/app.conf</span><br><span class="line">Generated configuration file: ./config/registry/config.yml</span><br><span class="line">Generated configuration file: ./config/db/env</span><br><span class="line">Generated configuration file: ./config/jobservice/env</span><br><span class="line">Clearing the configuration file: ./config/ui/private_key.pem</span><br><span class="line">Clearing the configuration file: ./config/registry/root.crt</span><br><span class="line">Generated configuration file: ./config/ui/private_key.pem</span><br><span class="line">Generated configuration file: ./config/registry/root.crt</span><br><span class="line">The configuration files are ready, please use docker-compose to start the service.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose up -d 启动</span></span><br><span class="line"><span class="comment"># docker-compose ps 查看信息</span></span><br><span class="line"></span><br><span class="line">Name Command State Ports</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">harbor-adminserver /harbor/harbor_adminserver Up</span><br><span class="line">harbor-db docker-entrypoint.sh mysqld Up 3306/tcp</span><br><span class="line">harbor-jobservice /harbor/harbor_jobservice Up</span><br><span class="line">harbor-log /bin/sh -c crond &amp;&amp; <span class="built_in">rm</span> -f ... Up 127.0.0.1:1514-&gt;514/tcp</span><br><span class="line">harbor-ui /harbor/harbor_ui Up</span><br><span class="line">nginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:5000-&gt;80/tcp</span><br><span class="line">registry /entrypoint.sh serve /etc/ ... Up 5000/tcp</span><br></pre></td></tr></table></figure>

<p>访问ip:5000 就可以了<br>默认帐号密码admin&#x2F;Harbor12345<br>然后创建用户和项目，注意区分公开还是私有。</p>
<h4 id="2、修改存储目录"><a href="#2、修改存储目录" class="headerlink" title="2、修改存储目录"></a>2、修改存储目录</h4><p>默认情况下存在在&#x2F;data目录，很多时候还是需要修改一下目录的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">registry:</span><br><span class="line">    image: vmware/registry:2.6.2-photon</span><br><span class="line">    container_name: registry</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - /joyfs/oam/harbor/registry:/storage:z</span><br><span class="line">      - ./common/config/registry/:/etc/registry/:z</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">adminserver:</span><br><span class="line">    image: vmware/harbor-adminserver:v1.2.2</span><br><span class="line">    container_name: harbor-adminserver</span><br><span class="line">    env_file:</span><br><span class="line">      - ./common/config/adminserver/env</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/config/:/etc/adminserver/config/:z</span><br><span class="line">      - /data/secretkey:/etc/adminserver/key:z</span><br><span class="line">      - /joyfs/oam/harbor/data/:/data/:z</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、修改数据库为外置MySQL"><a href="#3、修改数据库为外置MySQL" class="headerlink" title="3、修改数据库为外置MySQL"></a>3、修改数据库为外置MySQL</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker exec -i -t 6e1e4b576315 bash</span></span><br><span class="line">在db container中：</span><br><span class="line"><span class="comment"># mysqldump -u root -p --databases registry &gt; registry.dump</span></span><br><span class="line">回到node，将dump文件从container中copy出来：</span><br><span class="line"><span class="comment">#docker cp 6e1e4b576315:/root/registry.dump ./</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> common/templates/adminserver</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">env</span> env.bak</span><br><span class="line">vim <span class="built_in">env</span></span><br><span class="line"><span class="comment">#修改以下内容</span></span><br><span class="line">MYSQL_HOST=x.x.x.x</span><br><span class="line">MYSQL_PORT=3306</span><br><span class="line">MYSQL_USR=new name</span><br><span class="line">MYSQL_PWD=new password</span><br><span class="line">MYSQL_DATABASE=registry</span><br><span class="line">....</span><br><span class="line">RESET=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>docker-compose.yml删除 MySQL部分配置，包括proxy里面的- mysql。<br>不过需要注意需要删除 &#x2F;data&#x2F;config&#x2F;config.json 文件。</p>
<p>重启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">./prepare</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>验证登录正常，OK！！！</p>
<img data-src="https://img.econow.cn/medivh/1555837828882.png"  />

<h2 id="三、推送镜像"><a href="#三、推送镜像" class="headerlink" title="三、推送镜像"></a>三、推送镜像</h2><p>1、检查是否包含镜像地址，如果不包含则执行第2步<br><img data-src="https://img.econow.cn/medivh/1555838409977.png"  /></p>
<p>2、增加仓库地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry x.x.x.x:5000</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br></pre></td></tr></table></figure>

<p>部分低版本的则是修改其他文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim  /etc/docker/daemon.json</span></span><br><span class="line">&#123; <span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;ip:5000&quot;</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>3、构建并推送</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t ip:5000/base/jdk .</span><br><span class="line">docker login ip:5000 </span><br><span class="line"><span class="comment"># 输入账号密码</span></span><br><span class="line">docker push ip:5000/base/jdk </span><br></pre></td></tr></table></figure>

<p>之后在浏览器检查是否正常即可。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md">github</a></p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>多环境下的Kubernetes网络打通方案研究</title>
    <url>/%E5%A4%9A%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Kubernetes%E7%BD%91%E7%BB%9C%E6%89%93%E9%80%9A%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文中的Kubernetes集群统称为集群。</p>
</blockquote>
<p>现实的工作环境中，我们可能会在开发环境使用Kubernetes，也会在测试和开发环境使用Kubernetes。而一般来说，大部分人不会直接去连接或访问生产环境的集群，但是对于开发环境就不一样了。很多开发人员需要经常访问开发环境，而不是在本地起一堆依赖的服务。而且真的只有这么一个问题吗？</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>整理了若干常见的问题：</p>
<ol>
<li>开发人员本地服务访问开发环境</li>
<li>新集群和旧集群的网络互通，或者迁移</li>
<li>域名访问</li>
</ol>
<p>因此，我们需要解决以上问题，才能更安心的使用Kubernetes。</p>
<h2 id="网络互通"><a href="#网络互通" class="headerlink" title="网络互通"></a>网络互通</h2><p>首先来解决最主要的问题，如何实现不同网络环境下的互通问题？</p>
<p>众所周知，集群暴露服务的方式有以下几种：</p>
<ol>
<li>NodePort 每个服务维护一个端口，服务越多端口越多</li>
<li>LoadBalancer 在nodePort的基础上使用公有云的负载均衡器</li>
<li>ClusterIP 每个service有一个虚拟IP</li>
<li>Ingress 一个服务暴露多个service的服务，本质是一种路由转发机制</li>
</ol>
<h3 id="场景一、注册中心eureka的应用"><a href="#场景一、注册中心eureka的应用" class="headerlink" title="场景一、注册中心eureka的应用"></a>场景一、注册中心eureka的应用</h3><p>首先eureka可以使用StatefulSet的方式，实现一个集群的部署。以下文件可以直接使用：</p>
<ul>
<li>服务配置文件 <a href="https://img.econow.cn/k8s/eureka/eureka-svc-np.yaml">https://img.econow.cn/k8s/eureka/eureka-svc-np.yaml</a></li>
<li>StatefulSet 文件 <a href="https://img.econow.cn/k8s/eureka/eureka-sts.yaml">https://img.econow.cn/k8s/eureka/eureka-sts.yaml</a></li>
<li>Service 文件 <a href="https://img.econow.cn/k8s/eureka/eureka-svc-np.yaml">https://img.econow.cn/k8s/eureka/eureka-svc-np.yaml</a></li>
</ul>
<h4 id="1-办公网访问应用"><a href="#1-办公网访问应用" class="headerlink" title="1. 办公网访问应用"></a>1. 办公网访问应用</h4><p>开发人员本地访问的时候可以使用NodePort的方式访问，也可以使用Ingress的方式访问。</p>
<p><img data-src="https://img.econow.cn/medivh/1651052056989.png" alt="1651052056989.png"></p>
<p>如图所示，创建了两个Python的应用，并注册到eureka。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time:2022/04/27</span></span><br><span class="line"><span class="string">@file:test_eureka.py</span></span><br><span class="line"><span class="string">@author:medivh</span></span><br><span class="line"><span class="string">@IDE:PyCharm </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> py_eureka_client.eureka_client <span class="keyword">as</span> eureka_client</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setEureka</span>():</span><br><span class="line">    eureka_client.init(eureka_server=<span class="string">&quot;http://192.168.1.217:31331/eureka&quot;</span>,</span><br><span class="line">                       app_name=<span class="string">&quot;flask_server-2&quot;</span>,</span><br><span class="line">                       <span class="comment"># 当前组件的主机名，可选参数，如果不填写会自动计算一个，如果服务和 eureka 服务器部署在同一台机器，请必须填写，否则会计算出 127.0.0.1</span></span><br><span class="line">                       instance_host=<span class="string">&#x27;10.1.3.141&#x27;</span>,</span><br><span class="line">                       instance_port=<span class="number">5001</span>,</span><br><span class="line">                       <span class="comment"># 调用其他服务时的高可用策略，可选，默认为随机</span></span><br><span class="line">                       ha_strategy=eureka_client.HA_STRATEGY_RANDOM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setEureka()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/info&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_info</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello Info!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>, threaded=<span class="literal">True</span>, port=<span class="number">5001</span>, host=<span class="string">&quot;0.0.0.0&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外一个测试脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time:2022/04/27</span></span><br><span class="line"><span class="string">@file:test_eureka-service.py</span></span><br><span class="line"><span class="string">@author:medivh</span></span><br><span class="line"><span class="string">@IDE:PyCharm </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> py_eureka_client.eureka_client <span class="keyword">as</span> eureka_client</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">eureka_client.init(eureka_server=<span class="string">&quot;http://192.168.1.109:31331/eureka&quot;</span>, app_name=<span class="string">&#x27;do_service&#x27;</span>, instance_host=<span class="string">&quot;10.1.3.141&quot;</span>,</span><br><span class="line">                   instance_port=<span class="number">5011</span>)</span><br><span class="line"><span class="comment"># get请求的调用</span></span><br><span class="line">res = eureka_client.do_service(<span class="string">&quot;flask_server-2&quot;</span>, <span class="string">&quot;/info&quot;</span>,</span><br><span class="line">                               <span class="comment"># 返回类型，默认为 `string`，可以传入 `json`，如果传入值是 `json`，那么该方法会返回一个 `dict` 对象</span></span><br><span class="line">                               return_type=<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">res = eureka_client.do_service(<span class="string">&quot;O2O-SERVICE&quot;</span>, <span class="string">&quot;/env-path/actuator/info&quot;</span>,</span><br><span class="line">                               <span class="comment"># 返回类型，默认为 `string`，可以传入 `json`，如果传入值是 `json`，那么该方法会返回一个 `dict` 对象</span></span><br><span class="line">                               return_type=<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment">## post请求的调用</span></span><br><span class="line"><span class="comment"># d = &#123;&#x27;a&#x27;: 1&#125;</span></span><br><span class="line"><span class="comment"># res = eureka_client.do_service(&#x27;helloindex&#x27;, &#x27;/user&#x27;, return_type=&#x27;string&#x27;, method=&#x27;POST&#x27;, data=json.dumps(d))</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line">res = eureka_client.do_service(<span class="string">&quot;O2O-SERVICE&quot;</span>, <span class="string">&quot;/env-path/actuator/info&quot;</span>,</span><br><span class="line">                               <span class="comment"># 返回类型，默认为 `string`，可以传入 `json`，如果传入值是 `json`，那么该方法会返回一个 `dict` 对象</span></span><br><span class="line">                               return_type=<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<p>调用测试结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python test_eureka-service.py</span><br><span class="line">Hello Info!</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/medivh/github/box/test_eureka-service.py&quot;</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    res = eureka_client.do_service(<span class="string">&quot;O2O-SERVICE&quot;</span>, <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  File <span class="string">&quot;/Users/medivh/github/box/venv/lib/python3.8/site-packages/py_eureka_client/eureka_client.py&quot;</span>, line 1736, <span class="keyword">in</span> do_service</span><br><span class="line">    <span class="built_in">return</span> cli.do_service(app_name=app_name, service=service, return_type=return_type,</span><br><span class="line">  File <span class="string">&quot;/Users/medivh/github/box/venv/lib/python3.8/site-packages/py_eureka_client/eureka_client.py&quot;</span>, line 1467, <span class="keyword">in</span> do_service</span><br><span class="line">    <span class="built_in">return</span> self.walk_nodes(app_name, service, prefer_ip, prefer_https, walk_using_urllib)</span><br><span class="line">  File <span class="string">&quot;/Users/medivh/github/box/venv/lib/python3.8/site-packages/py_eureka_client/eureka_client.py&quot;</span>, line 1415, <span class="keyword">in</span> walk_nodes</span><br><span class="line">    raise http_client.URLError(<span class="string">&quot;Try all up instances in registry, but all fail&quot;</span>)</span><br><span class="line">urllib.error.URLError: &lt;urlopen error Try all up instances <span class="keyword">in</span> registry, but all fail&gt;</span><br><span class="line">[2022-04-27 17:32:39]-[eureka_client]-[line:1409] -WARNING: <span class="keyword">do</span> service / <span class="keyword">in</span> node [o2o-service-287077292-hj7q7:o2o-service:8080] error, use next node. Error: &lt;urlopen error timed out&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候说明注册中心是可以正常使用的，但是如果调用集群的服务就无法访问了，毕竟不在一个网段，也没有合适的路由。接下来就去解决这个问题。</p>
<h4 id="2-办公网访问集群Pod-Service"><a href="#2-办公网访问集群Pod-Service" class="headerlink" title="2.办公网访问集群Pod&#x2F;Service"></a>2.办公网访问集群Pod&#x2F;Service</h4><p>在网关和路由器上添加路由，把属于集群的Pod和Service的子网IP全部转发给其中某个node，这样访问Pod IP和Service IP，网络包会到达某个node，而集群内的node中，CNI会与这些目的地址互通。</p>
<p>网段：</p>
<table>
<thead>
<tr>
<th>网段名称</th>
<th>网段范围</th>
</tr>
</thead>
<tbody><tr>
<td>办公网段</td>
<td>10.1.3.0&#x2F;24</td>
</tr>
<tr>
<td>Pod地址池</td>
<td>10.200.0.0&#x2F;16</td>
</tr>
<tr>
<td>Svc地址池</td>
<td>10.96.0.0&#x2F;12</td>
</tr>
</tbody></table>
<p>如果不记得当时设置的网段是多少，可以用以下方式查询：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl get cm kubeadm-config -n kube-system -o yaml | grep -i podsub</span><br><span class="line">      podSubnet: 10.200.0.0/16</span><br><span class="line">~ kubectl get cm kubeadm-config -n kube-system -o yaml | grep -i servicesub</span><br><span class="line">      serviceSubnet: 10.96.0.0/12</span><br></pre></td></tr></table></figure>

<h5 id="steps-1"><a href="#steps-1" class="headerlink" title="steps 1"></a>steps 1</h5><p>选择集群中的一个节点进行路由转发，可以使用一台配置不高的节点，打上污点不允许调度占用资源。本文中使用的是master节点。</p>
<ol>
<li>设置污点 <code>kubectl taint nodes k8s-master forward=k8s-node5:NoSchedule</code></li>
<li>开启路由转发 <code>echo &quot;net.ipv4.ip_forward = 1&quot;  &gt;&gt; /etc/sysctl.conf</code></li>
<li>查看是否生效 <code>sysctl -p</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启转发</span></span><br><span class="line">~ vim /etc/sysctl.d/k8s.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">~ sysctl -p</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在k8s-master上设置snat</span></span><br><span class="line">~ iptables -t nat -A POSTROUTING -s 10.200.0.0/16  -d 10.1.3.0/24   -j MASQUERADE</span><br><span class="line">~ iptables -t nat -A POSTROUTING -s 10.96.0.0/12 -d 110.1.3.0/24   -j MASQUERADE</span><br><span class="line"> </span><br><span class="line"><span class="comment"># (可选)查看设置的snat</span></span><br><span class="line">~ iptables -t nat -L -n --line-numbers | grep -A 10 <span class="string">&quot;Chain POSTROUTING&quot;</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination        </span><br><span class="line">1    ......</span><br><span class="line">2    ......</span><br><span class="line">3    ......</span><br><span class="line">4    MASQUERADE  all  --  10.1.3.0/24          10.200.0.0/16</span><br><span class="line">5    MASQUERADE  all  --  10.1.3.0/24          10.96.0.0/12</span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选)如配置失误可删除已设置的snat条目</span></span><br><span class="line">~ iptables -t nat -D POSTROUTING 4</span><br></pre></td></tr></table></figure>

<h5 id="setps-2"><a href="#setps-2" class="headerlink" title="setps 2"></a>setps 2</h5><p>在办公网的出口路由上设置静态路由，将集群的Pod和Service网段，路由到master节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由器上需要做的配置：</span></span><br><span class="line">ip route add -net  10.200.0.0/16 gw 192.168.1.109</span><br><span class="line">ip route add -net  10.96.0.0/12 gw 192.168.1.109</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.econow.cn/medivh/1651115644098.png" alt="1651115644098.png"></p>
<h5 id="setps-3"><a href="#setps-3" class="headerlink" title="setps 3"></a>setps 3</h5><p>这个时候在办公网主机上<code>ping</code> 集群中的Pod或者service的IP，理论上就是通的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pod </span></span><br><span class="line">➜  ~ traceroute 10.200.96.148</span><br><span class="line">traceroute to 10.200.96.148 (10.200.96.148), 64 hops max, 52 byte packets</span><br><span class="line"> 1  10.1.3.1 (10.1.3.1)  2.781 ms  2.422 ms  2.388 ms</span><br><span class="line"> 2  bogon (192.168.1.109)  2.723 ms  3.352 ms  3.647 ms</span><br><span class="line"> 3  bogon (10.200.96.128)  3.724 ms  3.485 ms  3.417 ms</span><br><span class="line"> 4  10.200.96.148 (10.200.96.148)  3.551 ms  3.440 ms  3.390 ms</span><br><span class="line"></span><br><span class="line"> <span class="comment"># service </span></span><br><span class="line"></span><br><span class="line"> ➜  ~ traceroute 10.96.230.195</span><br><span class="line">traceroute to 10.96.230.195 (10.96.230.195), 64 hops max, 52 byte packets</span><br><span class="line"> 1  10.1.3.1 (10.1.3.1)  5.698 ms  2.482 ms  2.375 ms</span><br><span class="line"> 2  10.96.230.195 (10.96.230.195)  2.774 ms  2.807 ms  2.834 ms</span><br></pre></td></tr></table></figure>

<h5 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h5><p>如果以上操作都执行了，但是还是不通，请检查以下项目：</p>
<ol>
<li>转发是否开启</li>
<li>iptables的规则是否正确</li>
<li>iptables规则是否有<code> MASQUERADE  all  --  192.168.1.0/24       0.0.0.0/0</code> 这么一条</li>
</ol>
<p>至此，解决了开发人员无法在办公网访问集群环境的IP问题。</p>
<h2 id="跨集群访问"><a href="#跨集群访问" class="headerlink" title="跨集群访问"></a>跨集群访问</h2><p>如果我们有多个集群，这个时候如果实现网络打通呢，比如新旧集群迁移的时候？</p>
<h3 id="以IP形式访问"><a href="#以IP形式访问" class="headerlink" title="以IP形式访问"></a>以IP形式访问</h3><p>其实我们依然可以采用之前的方案，添加静态路由。</p>
<p>网段：</p>
<table>
<thead>
<tr>
<th>网段名称</th>
<th>网段范围</th>
</tr>
</thead>
<tbody><tr>
<td>办公网段</td>
<td>10.1.3.0&#x2F;24</td>
</tr>
<tr>
<td>集群A Pod地址池</td>
<td>10.200.0.0&#x2F;16</td>
</tr>
<tr>
<td>集群A Svc地址池</td>
<td>10.96.0.0&#x2F;12</td>
</tr>
<tr>
<td>集群B Pod地址池</td>
<td>10.100.0.0&#x2F;16</td>
</tr>
<tr>
<td>集群B Svc地址池</td>
<td>10.254.0.0&#x2F;16</td>
</tr>
</tbody></table>
<p>主要实现逻辑是每个集群选择一个节点，开启路由转发，实现办公网段可以访问集群中的IP。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ iptables -t nat -A POSTROUTING -s 10.1.3.0/24 -d 10.254.0.0/16 -j MASQUERADE -w</span><br><span class="line">~ iptables -t nat -A POSTROUTING -s 10.1.3.0/24 -d 10.100.0.0/16 -j MASQUERADE -w</span><br><span class="line">~ iptables -t nat -L -n --line-numbers | grep -A 10 <span class="string">&quot;Chain POSTROUTING&quot;</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">1    MASQUERADE  all  --  10.100.72.0/24       0.0.0.0/0</span><br><span class="line">2    KUBE-POSTROUTING  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */</span><br><span class="line">3    MASQUERADE  all  --  10.1.3.0/24          10.254.0.0/16</span><br><span class="line">4    MASQUERADE  all  --  10.1.3.0/24          10.100.0.0/16</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">1    RETURN     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">~ iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -d 0.0.0.0/0  -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 办公网</span></span><br><span class="line">➜  ~ traceroute 10.100.5.7</span><br><span class="line">traceroute to 10.100.5.7 (10.100.5.7), 64 hops max, 52 byte packets</span><br><span class="line"> 1  bogon (10.1.3.1)  2.699 ms  2.201 ms  2.140 ms</span><br><span class="line"> 2  *.demo.yourdomain.com (192.168.1.243)  2.213 ms  7.957 ms  7.389 ms</span><br><span class="line"> 3  bogon (10.100.5.0)  2.902 ms  4.637 ms  2.616 ms</span><br><span class="line"> 4  bogon (10.100.5.7)  4.109 ms  3.944 ms  2.782 ms</span><br><span class="line"></span><br><span class="line"> <span class="comment"># A集群到B集群</span></span><br><span class="line">~ tracepath 10.100.5.7</span><br><span class="line"> 1?: [LOCALHOST]                                         pmtu 1500</span><br><span class="line"> 1:  gateway                                               0.365ms</span><br><span class="line"> 1:  gateway                                               2.044ms</span><br><span class="line"> 2:  192.168.1.243                                         0.767ms</span><br><span class="line"> 3:  192.168.1.243                                         0.848ms pmtu 1450</span><br><span class="line"> 3:  10.100.5.0                                            1.536ms</span><br><span class="line"> 4:  10.100.5.7                                            1.382ms reached</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>办公网通过注册中心调用</p>
<p><img data-src="https://img.econow.cn/medivh/1651117439545.png" alt="1651117439545.png"></p>
<h3 id="以域名形式访问Service"><a href="#以域名形式访问Service" class="headerlink" title="以域名形式访问Service"></a>以域名形式访问Service</h3><p>实现了办公网和集群的网络互通后，就可以实现自由访问Pod和Service了。但是由于Pod IP会经常变化，Service IP也不是很容易记住，所以希望通过内网DNS的形式访问<code>*.cluser.local</code>时自动解析相应的IP。</p>
<h4 id="steps-1-获取coredns的IP"><a href="#steps-1-获取coredns的IP" class="headerlink" title="steps 1. 获取coredns的IP"></a>steps 1. 获取coredns的IP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ kubectl get svc -n kube-system -l k8s-app=kube-dns</span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   34d</span><br></pre></td></tr></table></figure>

<h4 id="steps-2-部署DNS服务dnsmasq"><a href="#steps-2-部署DNS服务dnsmasq" class="headerlink" title="steps 2. 部署DNS服务dnsmasq"></a>steps 2. 部署DNS服务dnsmasq</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install dnsmasq</span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;dnsmasq.conf：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resolv-file=/etc/resolv.dnsmasq.conf   <span class="comment">#指定上游dns服务器</span></span><br><span class="line">strict-order   <span class="comment">#严格按照resolv-file文件中的顺序进行从上到下解析，直到成功为止</span></span><br><span class="line">server=/cluster.local/10.96.0.10  <span class="comment">#指定以cluster.local为后缀的域名，使用coredns的地址解析,这里可以不配直接把coredns配置在/etc/resolv.dnsmasq.conf 里面。</span></span><br><span class="line">listen-address=192.168.1.109   <span class="comment">#指定本地IP地址</span></span><br><span class="line">addn-hosts=/etc/dnsmasq.hosts   <span class="comment">#自定义dns记录文件</span></span><br><span class="line">conf-dir=/etc/dnsmasq.d    <span class="comment">#所有的解析记录都会存在此目录下</span></span><br></pre></td></tr></table></figure>

<p>修改resolv.dnsmasq.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nameserver 61.139.2.69</span><br><span class="line">nameserver 202.106.0.20</span><br><span class="line">nameserver 192.168.1.109</span><br></pre></td></tr></table></figure>

<p>开机并启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> dnsmasq &amp;&amp; systemctl start dnsmasq</span><br></pre></td></tr></table></figure>

<h4 id="steps-3-验证"><a href="#steps-3-验证" class="headerlink" title="steps 3. 验证"></a>steps 3. 验证</h4><p>在其他机器上测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ traceroute eureka.default.svc.cluster.local</span><br><span class="line">traceroute to eureka.default.svc.cluster.local (10.200.229.155), 30 hops max, 60 byte packets</span><br><span class="line"> 1  192.168.1.1 (192.168.1.1)  0.151 ms  0.145 ms  0.137 ms</span><br><span class="line"> 2  new.eureka.com (192.168.1.109)  0.622 ms  0.595 ms *</span><br><span class="line"> 3  bogon (10.200.229.128)  1.311 ms  1.972 ms  2.019 ms</span><br><span class="line"> 4  bogon (10.200.229.155)  2.075 ms  2.743 ms  2.741 ms</span><br><span class="line"></span><br><span class="line">curl -I eureka.default.svc.cluster.local:8761</span><br><span class="line">HTTP/1.1 200</span><br><span class="line">X-Application-Context: DiscoveryServer:8761</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Language: en-US</span><br><span class="line">Content-Length: 7451</span><br><span class="line">Date: Thu, 28 Apr 2022 05:47:08 GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后来在其他的服务器上测试可以正常访问，在Mac下能使用nslookup解析，但是无法访问，也无法路由跟踪，以后再解决。</p>
<p>后来发现如果是Mac的话，直接在网络设置-高级-DNS，添加dns地址并拖到上面即可实现访问。只是奇怪的是手动修改<code>/etc/resolv.conf</code> 并没有实现访问，这种界面的形式反而可以，总之，解决了问题。</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>将Python作为一个便利工具的应用——抢购</title>
    <url>//%E5%B0%86Python%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%BE%BF%E5%88%A9%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%8A%A2%E8%B4%AD</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近来无意中看到一些Python的应用场景——抢购。这的确是一个恰当的应用，因此本文从一个开源项目库来入手分析项目是如何运行的。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><img data-src="https://img.econow.cn/medivh/1662716093305.png" alt="1662716093305.png"></p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       oooo oooooooooo.            .oooooo..o                     oooo         o8o  oooo  oooo  </span></span><br><span class="line"><span class="string">       `888 `888&#x27;   `Y8b          d8P&#x27;    `Y8                     `888         `&quot;&#x27;  `888  `888  </span></span><br><span class="line"><span class="string">        888  888      888         Y88bo.       .ooooo.   .ooooo.   888  oooo  oooo   888   888  </span></span><br><span class="line"><span class="string">        888  888      888          `&quot;Y8888o.  d88&#x27; `88b d88&#x27; `&quot;Y8  888 .8P&#x27;   `888   888   888  </span></span><br><span class="line"><span class="string">        888  888      888 8888888      `&quot;Y88b 888ooo888 888        888888.     888   888   888  </span></span><br><span class="line"><span class="string">        888  888     d88&#x27;         oo     .d8P 888    .o 888   .o8  888 `88b.   888   888   888  </span></span><br><span class="line"><span class="string">    .o. 88P o888bood8P&#x27;           8&quot;&quot;88888P&#x27;  `Y8bod8P&#x27; `Y8bod8P&#x27; o888o o888o o888o o888o o888o </span></span><br><span class="line"><span class="string">    `Y888P                                                                                                                                                  </span></span><br><span class="line"><span class="string">                                               </span></span><br><span class="line"><span class="string">功能列表：                                                                                </span></span><br><span class="line"><span class="string"> 1.预约商品</span></span><br><span class="line"><span class="string"> 2.秒杀抢购商品</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">    jd_seckill = JdSeckill()</span><br><span class="line">    choice_function = <span class="built_in">input</span>(<span class="string">&#x27;请选择:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> choice_function == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        jd_seckill.reserve()</span><br><span class="line">    <span class="keyword">elif</span> choice_function == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        jd_seckill.seckill_by_proc_pool()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;没有此功能&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这一段代码很简单：</p>
<ol>
<li>首先输出一段提示，让用户稍后选择预约还送抢购；</li>
<li>然后实例化<code>jd_seckill = JdSeckill()</code>;</li>
<li>根据输入选择功能</li>
</ol>
<h3 id="主功能（预约）"><a href="#主功能（预约）" class="headerlink" title="主功能（预约）"></a>主功能（预约）</h3><p>接下来先看一下预约功能，调用了<code>reserve()</code>，这段代码使用了装饰器，判断是否登录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@check_login</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reserve</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    预约</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self._reserve()</span><br><span class="line"></span><br><span class="line"><span class="meta">@check_login</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">seckill</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抢购</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self._seckill()</span><br><span class="line"></span><br><span class="line"><span class="meta">@check_login</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">seckill_by_proc_pool</span>(<span class="params">self, work_count=<span class="number">5</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    多进程进行抢购</span></span><br><span class="line"><span class="string">    work_count：进程数量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(work_count) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(work_count):</span><br><span class="line">            pool.submit(self.seckill)</span><br></pre></td></tr></table></figure>

<p>可以看到预约、抢购和多线程抢购这些功能都使用了装饰器。</p>
<h4 id="登录判断"><a href="#登录判断" class="headerlink" title="登录判断"></a>登录判断</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_login</span>(<span class="params">func</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      用户登陆态校验装饰器。若用户未登陆，则调用扫码登陆</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">      @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">new_func</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> self.qrlogin.is_login:</span><br><span class="line">              logger.info(<span class="string">&quot;&#123;0&#125; 需登陆后调用，开始扫码登陆&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">              self.login_by_qrcode()</span><br><span class="line">          <span class="keyword">return</span> func(self, *args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> new_func</span><br></pre></td></tr></table></figure>

<p>这里记录一下<code>@functools.wraps(fun)</code>的作用，主要因为增加了装饰器的函数其实就变成了另外一个函数，<code>____name__</code>和<code>__doc__</code>都发生了变化。因此增加了<code>@functools.wraps(fun)</code>之后就可以防止此类情况的发生。</p>
<p>执行步骤：</p>
<p>首先判断<code>self.qrlogin.is_login</code>是否<code>True</code>，默认为<code>False</code>。<code>self.qrlogin = QrLogin(self.spider_session)</code>会调用<code>QrLogin -&gt; SpiderSession</code>.</p>
<p><code>QrLogin()</code>功能：</p>
<ol>
<li>初始化扫码目录<ol>
<li>定义二维码文件名称</li>
<li>设置session</li>
<li>设置默认登录状态为<code>False</code></li>
<li>刷新登录状态</li>
</ol>
</li>
<li>刷新是否登录的状态</li>
<li>验证cookie(是否登录)</li>
<li>获取登录页面</li>
<li>缓存并展示登录二维码</li>
<li>通过token获取ticket</li>
<li>校验ticket</li>
<li>使用二维码登录</li>
</ol>
<h4 id="session处理"><a href="#session处理" class="headerlink" title="session处理"></a>session处理</h4><p><code>SpiderSession()</code>这个类功能是为了处理session：</p>
<ol>
<li>初始化<ol>
<li>定义cookie目录</li>
<li>从配置文件获取<code>user-agent</code></li>
<li>初始化session。</li>
</ol>
</li>
<li>初始化session</li>
<li>获取并设置header</li>
<li>获取<code>user_agent</code></li>
<li>获取cookie</li>
<li>设置cookie</li>
<li>从本地加载cookie</li>
<li>保存cookie到本地</li>
</ol>
<p>session的处理这一段代码不太熟悉，之前没有接触过，下面分析一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_init_session</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 实例化对象</span></span><br><span class="line">    session = requests.session()</span><br><span class="line">    <span class="comment"># 给 requests.session() 对象设置header信息</span></span><br><span class="line">    session.headers = self.get_headers()</span><br><span class="line">    <span class="keyword">return</span> session</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_headers</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;User-Agent&quot;</span>: self.user_agent,</span><br><span class="line">            <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;&quot;</span></span><br><span class="line">                      <span class="string">&quot;q=0.9,image/webp,image/apng,*/*;&quot;</span></span><br><span class="line">                      <span class="string">&quot;q=0.8,application/signed-exchange;&quot;</span></span><br><span class="line">                      <span class="string">&quot;v=b3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Python数据结构和算法的笔记（一）</title>
    <url>//%E5%AD%A6%E4%B9%A0Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然学习和使用Python已经多年，但是对于算法这一块基本上已经忘的差不多了，正好有机会阅读 <em>用Python解决数据结构和算法</em> 来巩固一下知识点。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>学习的目标是什么，或者动力是什么？</p>
<ol>
<li>了解计算机科学、程序设计和问题解决的基本概念；</li>
<li>理解抽象和抽象在问题解决过程中的作用；</li>
<li>理解抽象数据类型的概念以及运用</li>
</ol>
<p><strong>算法</strong> 即写出一组解决问题可能出现的任何情况的步步为营的指令。算法通过有线的过程解决问题，是一种解决方案。<br><strong>程序设计</strong> 将算法编码为计算机可执行的表示法或编程语言的过程。</p>
<h3 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h3><p>为什么要学习算法？<br>通过研究大量不同的算法，可以发展出模式识别机制，当以后出现相似问题时可以更好的解决掉。</p>
<p>Python是一种支持面向对象的编程范式，意味着Python把数据当做问题解决过程的重点。<strong>类</strong> 去描述数据的外观（状态）和功能（行为）。“类”类似于抽象数据类型，“类”的用户只能看到数据项的状态和行为。数据项在面向对象的范式里被称为<strong>对象</strong>(objects)。对象是类的一个实例。</p>
<p>接下来的内容讲述了Python的基本数据类型：</p>
<ul>
<li>int和float</li>
<li>list和set</li>
<li>string</li>
<li>dict</li>
</ul>
<h4 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h4><p>现在尝试解决一些问题。修改代码，是最终列表只包含字母的单一副本<code>[&#39;c&#39;,&#39;a&#39;,&#39;t&#39;,&#39;d&#39;,&#39;o&#39;,&#39;g&#39;,&#39;r&#39;,&#39;b&#39;,&#39;i&#39;]</code>，源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wordlist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;rabbit&#x27;</span>]</span><br><span class="line">letterlist = [ ]</span><br><span class="line"><span class="keyword">for</span> aword <span class="keyword">in</span> wordlist:</span><br><span class="line">    <span class="keyword">for</span> aletter <span class="keyword">in</span> aword:</span><br><span class="line">        letterlist.append(aletter)</span><br><span class="line"><span class="built_in">print</span>(letterlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>修改后的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wordlist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;rabbit&#x27;</span>]</span><br><span class="line">letterlist = [ ]</span><br><span class="line"><span class="keyword">for</span> aword <span class="keyword">in</span> wordlist:</span><br><span class="line">    <span class="keyword">for</span> aletter <span class="keyword">in</span> aword:</span><br><span class="line">        letterlist.append(aletter)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(letterlist)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实，作者的本意可能是让使用列表解析的方式来达到目的，但是我们有更好的方法，使用<code>set()</code>来去重后再转为<code>list()</code>类型就可以了。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>在列表中，存在一种替代方法使用迭代和选择结构创建列表，被称为<strong>列表解析</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">newlist = [Expression <span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">list</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明如下：</p>
<ul>
<li>newlist 新生成的列表名称</li>
<li>Expression 表达式，用于计算新列表的元素</li>
<li>var 变量，值为后面列表的每个元素值</li>
<li>list 用于生成新列表的原列表</li>
</ul>
<p>带有条件的解析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">newlist = [Expression <span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">list</span> <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>

<p>condition 条件表达式，用于筛选条件。</p>
<h5 id="解析规则"><a href="#解析规则" class="headerlink" title="解析规则"></a>解析规则</h5><p>Python中内置类型的解析规则：</p>
<ol>
<li>如果使用中括号，表示为列表解析；</li>
<li>如果使用大括号，表示为集合解析</li>
<li>如果使用大括号且元素为k:v形式，表示为字典解析。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 集合解析</span></span><br><span class="line">&gt;&gt;&gt; &#123; i*2 <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;abcd&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;dd&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典解析</span></span><br><span class="line">&gt;&gt;&gt; &#123; k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> zip((&quot;one&quot;,&quot;two&quot;,&quot;three&quot;),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) &#125;</span><br><span class="line">&#123;<span class="string">&#x27;one&#x27;</span>: 1, <span class="string">&#x27;two&#x27;</span>: 2, <span class="string">&#x27;three&#x27;</span>: 3&#125;</span><br><span class="line">&gt;&gt;&gt; &#123; k: k*2 <span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&quot;abcd&quot;</span> &#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;dd&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h5><p>首先用迭代工具for对容器中的元素进行跌打，每个元素都经过筛选，对符合条件的元素执行外部表达式，每个外部表达式都生成一个新的元素，然后昨晚新列表的一个元素，从而推导出一个新的列表。</p>
<p>列表解析可以让你创建基于某些处理或选择条件的列表。比如创建一个小于10的整数的平方的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sqlist = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    sqlist.append(i*i)</span><br><span class="line"><span class="built_in">print</span>(sqlist)</span><br><span class="line"></span><br><span class="line">sqlist = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"><span class="built_in">print</span>(sqlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>上面的代码中，第一段是先循环出一个整数，计算后再塞入list。第二段代码其实也是差不多，先取出一个整数，计算平方后再塞入新建的列表中。列表解析还可以使用选择语句，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sqlist = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> i%<span class="number">2</span> !=<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(sqlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">9</span>, <span class="number">25</span>, <span class="number">49</span>, <span class="number">81</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中取整数后判断是否为奇数，如果是则进行平方计算并塞入新的列表中。</p>
<h5 id="练习——列表解析"><a href="#练习——列表解析" class="headerlink" title="练习——列表解析"></a>练习——列表解析</h5><p>删除重复元素：<code>[&#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;d&#39;, &#39;o&#39;, &#39;g&#39;, &#39;r&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;i&#39;, &#39;t&#39;]</code></p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常规方案</span></span><br><span class="line">s = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]</span><br><span class="line">sqlist = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> sqlist:</span><br><span class="line">        sqlist.append(i)</span><br><span class="line"><span class="built_in">print</span>(sqlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表解析</span></span><br><span class="line">animal = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]</span><br><span class="line">newlist = <span class="built_in">list</span>()</span><br><span class="line">sqlist = [newlist.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> animal <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> newlist]</span><br><span class="line"><span class="built_in">print</span>(newlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里和之前不一样的是，步骤如下：</p>
<ol>
<li>循环取出一个元素；</li>
<li>判断元素是否属于定义的newlist;</li>
<li>如果不属于则插入到newlist;</li>
<li>输出newlist.</li>
</ol>
<h5 id="练习——函数"><a href="#练习——函数" class="headerlink" title="练习——函数"></a>练习——函数</h5><p>编写一个函数，该函数生成一个27个字符长度的字符串，从26个字母和空格中随机选择一个字符。编写另一个函数，比较随机生成的字符串和目标字符串。第三个函数将反复调用生成和比较函数，那么如果所有目标字母都在随机字符串中出现了，那么就完成了。如果字母没有全部出现，那么会生成一个全新的字符串。</p>
<ol>
<li>第一个函数生成随机字符，从26个字母和空格里；</li>
<li>第二个函数来比较随机生成的字符和目标字符；</li>
<li>第三个函数返回目前为止能匹配上的字符串以及尝试次数。</li>
</ol>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现匹配出所有字符，并非对应所有字符</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_chars</span>():</span><br><span class="line">    <span class="comment"># 获取26个字符，使用ASCII码表来定位，并生成列表</span></span><br><span class="line">    chars = [<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>, <span class="number">123</span>)]</span><br><span class="line">    <span class="comment"># 添加空格至列表</span></span><br><span class="line">    chars.append(<span class="built_in">chr</span>(<span class="number">32</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.choice(chars) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">diff_chars</span>(<span class="params">chars_list, random_chars</span>):</span><br><span class="line">    new_chars_list = <span class="built_in">list</span>()</span><br><span class="line">    [new_chars_list.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> chars_list <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> new_chars_list]</span><br><span class="line">    random_chars_list = <span class="built_in">list</span>()</span><br><span class="line">    [random_chars_list.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> random_chars <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> random_chars_list]</span><br><span class="line"></span><br><span class="line">    successful_chars = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> new_chars_list:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> random_chars_list:</span><br><span class="line">            successful_chars.append(i)</span><br><span class="line">    score = <span class="string">&#x27;%.2f&#x27;</span> % (<span class="built_in">len</span>(successful_chars) / <span class="built_in">len</span>(new_chars_list) * <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_result</span>():</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    chars = <span class="string">&#x27;methinks it is a weasel&#x27;</span></span><br><span class="line">    chars_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> chars]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        random_chars = get_chars()</span><br><span class="line">        res = <span class="built_in">float</span>(diff_chars(chars_list, random_chars))</span><br><span class="line">        <span class="comment"># 如果得分为100或次数等于10000则退出</span></span><br><span class="line">        <span class="keyword">if</span> math.isclose(res, <span class="number">100.0</span>, abs_tol=<span class="number">0</span>) <span class="keyword">or</span> num &gt;= <span class="number">10000</span>:</span><br><span class="line">            <span class="built_in">print</span>(num, random_chars)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_result()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line"><span class="number">323</span>  wc uhtveaimrzvmbrsbmcnlnky</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>小熊加湿器的复活</title>
    <url>/%E5%B0%8F%E7%86%8A%E5%8A%A0%E6%B9%BF%E5%99%A8%E7%9A%84%E5%A4%8D%E6%B4%BB.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>上周空气有点干燥，打算把加湿器拿出来用上，但是它不出雾了！<br>明明上个月的时候还用过呢，咋就不行了呢？</p>
</blockquote>
<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p><strong>推测</strong><br>根据以往和查阅资料得出的经验：</p>
<ol>
<li>缺水</li>
<li>有雾气但是出不来，风扇故障</li>
<li>无雾，像喷泉，雾化片存留过多水碱或者雾化片故障</li>
</ol>
<blockquote>
<p>大部分情况都是由于雾化片的缘故，极少数是因为电路板或者其他组件的问题</p>
</blockquote>
<p><strong>原理</strong><br>基本原理主要由两部分组成：</p>
<ul>
<li>陶瓷振荡器通电振荡，产生水雾</li>
<li>风扇转动，送出水雾</li>
</ul>
<p><strong>排查</strong><br>根据当前的现象进行逐一排除：</p>
<ol>
<li>出水正常，不缺水，无效</li>
<li>用醋和食盐混合后擦拭雾化片，依然像喷泉一样，无效</li>
</ol>
<p>最终经过各方面检查，判断雾化片故障。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>推测是雾化片的问题后，查询京东订单，发现之前买的时候只有60多，而现在90多，这个反差！真恶心！</p>
<p>买一个雾化片吧，也就十块钱左右，总比再花90块钱强，咨询一下客服看看需要多大尺寸的。经过一系列咨询，客服的意思是集成的，无法更换零部件，总之就是坏了就买新的吧。再花90块钱，我不同意，那就自己拆下来量一下尺寸吧。</p>
<p>想象中的雾化片是这个样子的，基本都是在10块钱左右。</p>
<p><img data-src="https://img.econow.cn/medivh/1638155846311.png" alt="1638155846311.png"></p>
<ol>
<li><p>拆开底座。拿掉胶垫，就能看到螺丝，拧下来，这个螺丝的洞很深，螺丝刀需要长一点。而且需要注意的是小熊加湿器的螺丝在底部的四个缓冲垫下面藏着的。最开始的时候没找到螺丝，怎么也打不开底座。</p>
</li>
<li><p>拆卸雾化片。实际上小熊的雾化片真是集成的，螺丝都快拧坏了也没拆下来。雾化片的集成板上有很多连接线和卡扣，可以直接拆下来，不用担心还原的问题。因为每种卡扣基本都是独立的颜色，按照颜色插就可以了。</p>
<p> <img data-src="https://img.econow.cn/medivh/1638155925408.png" alt="1638155925408.png"></p>
<p> 这个是反面，基本和我的这一款一致</p>
<p> <img data-src="https://img.econow.cn/medivh/1638155962363.png" alt="1638155962363.png"></p>
<p> 另外一块是电源板，应该没有什么问题。<br> <img data-src="https://img.econow.cn/medivh/1638156032131.png" alt="1638156032131.png"></p>
<p> 最后是我拆下来的废弃的雾化片集成板，暂时先留着就当个纪念吧，虽然知道以后也不会用得到。</p>
<p> <img data-src="https://img.econow.cn/medivh/1638156097228.png" alt="1638156097228.png"></p>
</li>
<li><p>把所有的零件都插回去，注意雾化片集成板的方向一定要插对，否则是无法正常装上底座的</p>
</li>
<li><p>加水，通电。最开始的十几秒内并没有出现很多雾，当时一度担心不是雾化片的原因，可能是水温低吧，很快大股水雾就出来了。完美！</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多东西都要先了解一下原理，如果有的话。其次，如果能了解到更多的前因后果，那就更好了。<br>在很多场景下下会遇到维修成本的问题，如果可以接受那么久去做，就算没做好也当学习的经验了。</p>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>玩具</tag>
      </tags>
  </entry>
  <entry>
    <title>批量抓取优美图库</title>
    <url>//%E6%89%B9%E9%87%8F%E6%8A%93%E5%8F%96%E4%BC%98%E7%BE%8E%E5%9B%BE%E5%BA%93</url>
    <content><![CDATA[<blockquote>
<p>以前尝试过一些多线程的方式进行爬虫，现在体验一下协程的方式。</p>
</blockquote>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><h3 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h3><p>协程，Coroutine，又称微线程，是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复之前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，即局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态。协程本质上是个单线程，相对于多进程来说，无需线程的上下文切换的开销，无需原子操作锁定及同步的开销。可以使用的场景，比如在网络爬虫的场景，发出一个请求之后，需要等待一定的实际才能得到响应。但是在等待过程中，程序可以做一些其他的事情，等到响应后再切回来继续处理，这样可以充分利用CPU和其他资源，也就是协程的优势所在。</p>
<p><img data-src="https://img.econow.cn/medivh/1664418664734.png" alt="1664418664734.png"></p>
<h3 id="协程的用法"><a href="#协程的用法" class="headerlink" title="协程的用法"></a>协程的用法</h3><p>协程相关的概念:</p>
<ul>
<li>event_loop 事件循环，相当于一个无限循环，可以把一些函数注册到这个事件循环上，当满足条件时，就会调用对应的处理方法。</li>
<li>coroutine 协程，在 Python 中常指代为协程对象类型，可以将协程对象注册到事件循环中，会被事件循环调用。使用 async 关键字来定义一个方法，在调用时不会立即被执行，而是先放回一个协程对象。</li>
<li>task 任务，是对协程对象的进一步封装，包含了任务的所有状态。<br>future 代表将来执行或没有执行任务的任务的结果，和task没有本质的区别。</li>
</ul>
<p>详细讲解参考 <a href="https://econow.cn/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5.html">关于协程的认知</a></p>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><p>XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</p>
<h4 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h4><p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nodename</td>
<td>选取此节点的所有子节点。</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>从根节点选取（取子节点）。</td>
</tr>
<tr>
<td>&#x2F;&#x2F;</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置（取子孙节点）。</td>
</tr>
<tr>
<td>.</td>
<td>选取当前节点.</td>
</tr>
<tr>
<td>..</td>
<td>选取当前节点的父节点。</td>
</tr>
<tr>
<td>@</td>
<td>选取属性</td>
</tr>
</tbody></table>
<p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;bookstore&#x2F;book[1]</td>
<td>选取属于 bookstore 子元素的第一个 book 元素。</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[last()]</td>
<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[last()-1]</td>
<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[position()&lt;4]</td>
<td>选取最前面的3个属于 bookstore 元素的子元素的 book 元素。</td>
</tr>
<tr>
<td>&#x2F;&#x2F;title[@lang]</td>
<td>选取所有拥有名为 lang 的属性的 title 元素。</td>
</tr>
<tr>
<td>&#x2F;&#x2F;title[@lang&#x3D;’eng’]</td>
<td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[price&gt;35.00]</td>
<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[price&gt;35.00]&#x2F;&#x2F;title选取 bookstore 元素中的 book 元素的所有</td>
<td>title 元素，且其中的 price 元素的值须大于 35.00</td>
</tr>
</tbody></table>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>首先需要先分析一下要爬取的目标是什么？当然是所有的图片。<br>那么图片是怎么展示的呢？通过各个专栏，每个专栏有N页，每页上N个链接，访问链接后就会展示目标图片的链接。</p>
<p>综上所述，流程如下：</p>
<ol>
<li>获取专栏所有页面链接</li>
<li>获取每页上所有图片所属页面的链接</li>
<li>根据图片的链接进行下载和存储</li>
</ol>
<h3 id="获取专栏所有页面链接"><a href="#获取专栏所有页面链接" class="headerlink" title="获取专栏所有页面链接"></a>获取专栏所有页面链接</h3><p><img data-src="https://img.econow.cn/medivh/1664419499404.png" alt="1664419499404.png"></p>
<p>本次示例目标是电脑壁纸专栏。</p>
<p>根据页面按钮获取第一页和最后一页的URL。其中第一页需要单独处理，之后的任意页都是递增的逻辑。而尾页直接提示767，直接使用即可，也可以复杂点使用xpath提取。<br><img data-src="https://img.econow.cn/medivh/1664419554458.png" alt="1664419554458.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">page_urls = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page_urls1</span>(<span class="params">page_num</span>):</span><br><span class="line">    <span class="keyword">if</span> page_num == <span class="number">1</span>:</span><br><span class="line">        url = <span class="string">&#x27;https://www.umei.cc/bizhitupian/diannaobizhi&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = <span class="string">&#x27;https://www.umei.cc/bizhitupian/diannaobizhi/index_&#123;&#125;.htm&#x27;</span>.<span class="built_in">format</span>(page_num)</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    html = etree.HTML(resp.text)</span><br><span class="line">    table = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;item masonry_brick&quot;)]&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> table:</span><br><span class="line">        url_list = table[<span class="number">0</span>].xpath(<span class="string">&#x27;//div[contains(@class,&quot;img&quot;)]/a/@href&#x27;</span>)</span><br><span class="line">        page_urls.extend(url_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page_urls</span>():</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">100</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>): <span class="comment"># 此处的6为最大页面数，可以自行决定修改，最大值为767</span></span><br><span class="line">            args = [i]</span><br><span class="line">            t.submit(<span class="keyword">lambda</span> p: get_page_urls1(*p), args)</span><br></pre></td></tr></table></figure>

<p>最终获取到了所有页面的链接。</p>
<h3 id="获取每页上所有图片所属页面的链接"><a href="#获取每页上所有图片所属页面的链接" class="headerlink" title="获取每页上所有图片所属页面的链接"></a>获取每页上所有图片所属页面的链接</h3><p><img data-src="https://img.econow.cn/medivh/1664419837995.png" alt="1664419837995.png"><br>根据源代码获取了图片的链接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clean_urls = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pic_url1</span>(<span class="params">url</span>):</span><br><span class="line">    url = <span class="string">&#x27;https://www.umei.cc&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    html = etree.HTML(resp.text)</span><br><span class="line">    pic_link = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;big-pic&quot;)]/a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    clean_urls.append(pic_link)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pic_url</span>():</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">100</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> page_urls:</span><br><span class="line">            args = [i]</span><br><span class="line">            t.submit(<span class="keyword">lambda</span> p: get_pic_url1(*p), args)</span><br></pre></td></tr></table></figure>

<p>最终获取了所有图片的URL。</p>
<h3 id="异步下载"><a href="#异步下载" class="headerlink" title="异步下载"></a>异步下载</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = []</span><br><span class="line">    get_page_urls()</span><br><span class="line">    get_pic_url()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;即将下载的文件总数&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(clean_urls)))</span><br><span class="line">    sem = asyncio.Semaphore(<span class="number">15</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> clean_urls:</span><br><span class="line">        task = asyncio.create_task(download_pic(url, sem))</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_pic</span>(<span class="params">url, sem</span>):</span><br><span class="line">    name = <span class="string">&#x27;../pic/&#x27;</span> + url.rsplit(<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># 右切</span></span><br><span class="line">    timeout = aiohttp.ClientTimeout(total=<span class="number">300</span>)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: random_useragent(),</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    conn = aiohttp.TCPConnector(limit=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=conn, timeout=timeout) <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers) <span class="keyword">as</span> resp:  <span class="comment"># requests.get()</span></span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">await</span> f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 读取内容异步需要挂起</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;下载完成&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br></pre></td></tr></table></figure>

<p>在处理这一步的时候遇到了一些问题，可能是并发太高，导致经常遇到链接断开或者超时的情况，因此使用了Semaphore来控制协程的并发。</p>
<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time:2022/09/28</span></span><br><span class="line"><span class="string">@file:aiohttp_umei.cc.py</span></span><br><span class="line"><span class="string">@author:medivh</span></span><br><span class="line"><span class="string">@IDE:PyCharm </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiofiles</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> random_useragent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_pic</span>(<span class="params">url, sem</span>):</span><br><span class="line">    name = <span class="string">&#x27;../pic/&#x27;</span> + url.rsplit(<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># 右切</span></span><br><span class="line">    timeout = aiohttp.ClientTimeout(total=<span class="number">300</span>)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: random_useragent(),</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    conn = aiohttp.TCPConnector(limit=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=conn, timeout=timeout) <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers) <span class="keyword">as</span> resp:  <span class="comment"># requests.get()</span></span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">await</span> f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 读取内容异步需要挂起</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;下载完成&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page_url</span>():</span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> page_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> page_num == <span class="number">1</span>:</span><br><span class="line">            url = <span class="string">&#x27;https://www.umei.cc/bizhitupian/diannaobizhi&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            url = <span class="string">&#x27;https://www.umei.cc/bizhitupian/diannaobizhi/index_&#123;&#125;.htm&#x27;</span>.<span class="built_in">format</span>(page_num)</span><br><span class="line">        resp = requests.get(url)</span><br><span class="line">        html = etree.HTML(resp.text)</span><br><span class="line">        table = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;item masonry_brick&quot;)]&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> table:</span><br><span class="line">            url_list = table[<span class="number">0</span>].xpath(<span class="string">&#x27;//div[contains(@class,&quot;img&quot;)]//@href&#x27;</span>)</span><br><span class="line">            urls.extend(url_list)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">page_urls = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page_urls1</span>(<span class="params">page_num</span>):</span><br><span class="line">    <span class="keyword">if</span> page_num == <span class="number">1</span>:</span><br><span class="line">        url = <span class="string">&#x27;https://www.umei.cc/bizhitupian/diannaobizhi&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = <span class="string">&#x27;https://www.umei.cc/bizhitupian/diannaobizhi/index_&#123;&#125;.htm&#x27;</span>.<span class="built_in">format</span>(page_num)</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    html = etree.HTML(resp.text)</span><br><span class="line">    table = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;item masonry_brick&quot;)]&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> table:</span><br><span class="line">        url_list = table[<span class="number">0</span>].xpath(<span class="string">&#x27;//div[contains(@class,&quot;img&quot;)]/a/@href&#x27;</span>)</span><br><span class="line">        page_urls.extend(url_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page_urls</span>():</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">100</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">            args = [i]</span><br><span class="line">            t.submit(<span class="keyword">lambda</span> p: get_page_urls1(*p), args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clean_urls = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pic_url1</span>(<span class="params">url</span>):</span><br><span class="line">    url = <span class="string">&#x27;https://www.umei.cc&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    html = etree.HTML(resp.text)</span><br><span class="line">    pic_link = html.xpath(<span class="string">&#x27;//div[contains(@class,&quot;big-pic&quot;)]/a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    clean_urls.append(pic_link)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pic_url</span>():</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">100</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> page_urls:</span><br><span class="line">            args = [i]</span><br><span class="line">            t.submit(<span class="keyword">lambda</span> p: get_pic_url1(*p), args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = []</span><br><span class="line">    get_page_urls()</span><br><span class="line">    get_pic_url()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;即将下载的文件总数&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(clean_urls)))</span><br><span class="line">    sem = asyncio.Semaphore(<span class="number">15</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> clean_urls:</span><br><span class="line">        task = asyncio.create_task(download_pic(url, sem))</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. 拼接URL 1-767</span></span><br><span class="line"><span class="string">    2. 从URL获取图片链接</span></span><br><span class="line"><span class="string">    3. 下载图片</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    start = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(start)</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    end = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(end)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;抓取耗时：&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>user-agent 可以自定义<br>Semaphore 数值可以根据实际情况来决定，比如带宽</p>
</blockquote>
<p>最终下载了5页图片，149张。<br><img data-src="https://img.econow.cn/medivh/1664420426755.png" alt="1664420426755.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>参考：</p>
<ul>
<li><a href="https://www.51cto.com/article/675758.html">https://www.51cto.com/article/675758.html</a></li>
</ul>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>批量抓取免费小说</title>
    <url>//%E6%89%B9%E9%87%8F%E6%8A%93%E5%8F%96%E5%85%8D%E8%B4%B9%E5%B0%8F%E8%AF%B4</url>
    <content><![CDATA[<blockquote>
<p>之前尝试过用scrapy抓取过一些网站，实在有点杀鸡焉用牛刀。现在用asyncio的方式再来一遍。</p>
</blockquote>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><p>任务使用到的技术点：</p>
<ul>
<li>asyncio</li>
<li>aiohttp</li>
<li>lxml</li>
<li>shutil</li>
</ul>
<p>所使用的技术点基本和之前的文章差不多，此处不再过多介绍。</p>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>起初是想抓取一本小说，后来决定就选择整个专栏吧，其实技术难度也没增加多少。下面先从一本小说开始分析。</p>
<p>首先要获取章节目录的URL。<br><img data-src="https://img.econow.cn/medivh/1664444705074.png" alt="1664444705074.png"></p>
<p>根据源代码获取章节的URL<br><img data-src="https://img.econow.cn/medivh/1664444768654.png" alt="1664444768654.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_page_urls</span>(<span class="params">url, sem</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers) <span class="keyword">as</span> resp:</span><br><span class="line">                html = etree.HTML(<span class="keyword">await</span> resp.content.read())</span><br><span class="line">                urls = []</span><br><span class="line">                title_of_book = html.xpath(<span class="string">&#x27;//div[@class=&quot;Main List&quot;]/h1/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="built_in">print</span>(title_of_book)</span><br><span class="line">                td_html = html.xpath(<span class="string">&#x27;//div[@class=&quot;Main List&quot;]/dl[1]/dd[1]/a/@href&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> td_html:</span><br><span class="line">                    url = <span class="string">&#x27;https://www.17k.com&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">                    urls.append(url)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;共获取 &#123;&#125; 章节&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(urls)))</span><br><span class="line">                book_info = &#123;</span><br><span class="line">                    <span class="string">&#x27;title&#x27;</span>: title_of_book,</span><br><span class="line">                    <span class="string">&#x27;urls&#x27;</span>: urls</span><br><span class="line">                &#125;</span><br><span class="line">                all_book_list.append(book_info)</span><br></pre></td></tr></table></figure>

<p>代码中将书籍信息设置为dict()，方便之后调用。</p>
<p>然后根据章节URL进行下载小说内容。<br><img data-src="https://img.econow.cn/medivh/1664444937905.png" alt="1664444937905.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_target</span>(<span class="params">url, i, book_title, sem</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers) <span class="keyword">as</span> resp:  <span class="comment"># requests.get()</span></span><br><span class="line">                html = etree.HTML(<span class="keyword">await</span> resp.content.read())</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    body_html = html.xpath(<span class="string">&#x27;//div[@class=&quot;readAreaBox content&quot;]&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;body获取失败&#x27;</span>, e, url)</span><br><span class="line">                title = body_html.xpath(<span class="string">&#x27;./h1/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="number">10</span>:</span><br><span class="line">                    num = <span class="string">&#x27;000&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">                <span class="keyword">elif</span> i &lt; <span class="number">100</span>:</span><br><span class="line">                    num = <span class="string">&#x27;00&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">                <span class="keyword">elif</span> i &lt; <span class="number">1000</span>:</span><br><span class="line">                    num = <span class="string">&#x27;0&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">                file_name = <span class="string">&#x27;./novel/&#123;&#125;/&#123;&#125;.txt&#x27;</span>.<span class="built_in">format</span>(book_title, num)</span><br><span class="line">                content_html = body_html.xpath(<span class="string">&#x27;./div[@class=&quot;p&quot;]/p&#x27;</span>)</span><br><span class="line">                content = [i.xpath(<span class="string">&#x27;./text()&#x27;</span>)[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> content_html <span class="keyword">if</span> i.xpath(<span class="string">&#x27;./text()&#x27;</span>)]</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    content.remove(content[-<span class="number">1</span>])</span><br><span class="line">                    <span class="comment"># 大部分情况是因为该章节被锁定，暂时无法查看，忽略即可</span></span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(e, url)</span><br><span class="line">                content.insert(<span class="number">0</span>, title)</span><br><span class="line">                content.append(<span class="string">&#x27;该章节存在问题，已经被锁定，暂时无法查看&#x27;</span>) <span class="keyword">if</span> <span class="built_in">len</span>(content) == <span class="number">1</span> <span class="keyword">else</span> content.append(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(file_name, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">await</span> f.write(<span class="string">&quot;\n&quot;</span>.join(content))  <span class="comment"># 读写内容异步需要挂起</span></span><br></pre></td></tr></table></figure>

<p>下面的代码是为了合并文件排序的目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    num = <span class="string">&#x27;000&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line"><span class="keyword">elif</span> i &lt; <span class="number">100</span>:</span><br><span class="line">    num = <span class="string">&#x27;00&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line"><span class="keyword">elif</span> i &lt; <span class="number">1000</span>:</span><br><span class="line">    num = <span class="string">&#x27;0&#x27;</span> + <span class="built_in">str</span>(i)</span><br></pre></td></tr></table></figure>

<p>经过以上步骤就可以实现抓取一本小说并保存为文件了。</p>
<p>下面聊一下抓取整个专栏的小说的流程。首先获取专栏的所有链接，并且可以从页面可以获取最大页数。</p>
<p><img data-src="https://img.econow.cn/medivh/1664445213703.png" alt="1664445213703.png"></p>
<p>然后从页面获取每一部书籍的章节入口的URL<br><img data-src="https://img.econow.cn/medivh/1664445432003.png" alt="1664445432003.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获取所有书籍的URL</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">35</span>):</span><br><span class="line">    url = <span class="string">&#x27;https://www.17k.com/all/book/3_0_0__3__1__&#123;&#125;.html&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    task = asyncio.create_task(get_book_url(url, sem))</span><br><span class="line">    tasks.append(task)</span><br><span class="line"><span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(all_book_url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_book_url</span>(<span class="params">url, sem</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers) <span class="keyword">as</span> resp:  <span class="comment"># requests.get()</span></span><br><span class="line">                html = etree.HTML(<span class="keyword">await</span> resp.content.read())</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    table_html = html.xpath(<span class="string">&#x27;//tbody/tr[position()&gt;2]&#x27;</span>)</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> table_html:</span><br><span class="line">                        url = i.xpath(<span class="string">&#x27;./td[3]/span/a/@href&#x27;</span>)[<span class="number">0</span>].replace(<span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;list&#x27;</span>)  <span class="comment"># 处理为书籍的章节页面链接</span></span><br><span class="line">                        url = <span class="string">&#x27;https:&#x27;</span> + url</span><br><span class="line">                        all_book_url.append(url)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;body获取失败&#x27;</span>, e, url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取书籍的所有目录的URL</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> all_book_url:</span><br><span class="line">    task = asyncio.create_task(get_page_urls(i, sem))</span><br><span class="line">    tasks.append(task)</span><br><span class="line"><span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(all_book_list))</span><br></pre></td></tr></table></figure>

<p>到此为止，我们已经拿到了专栏里所有的书籍的章节URL，然后调用之前的内容下载函数就可以了。</p>
<p>此外还有一步需要处理，合并章节为一本小说。逻辑很简单，适用<code>os.listdir()</code>遍历每个目录下的章节，然后写入到新的文件里即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_file</span>(<span class="params">path</span>):</span><br><span class="line">    top_file_list = os.listdir(path)</span><br><span class="line">    <span class="built_in">print</span>(top_file_list)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> book <span class="keyword">in</span> top_file_list:</span><br><span class="line">            file_list = os.listdir(path + <span class="string">&#x27;/&#x27;</span> + book)</span><br><span class="line">            file_list.sort()</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> file_list:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./book/&#123;&#125;.txt&#x27;</span>.<span class="built_in">format</span>(book), <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./novel/&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(book) + file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file_f:</span><br><span class="line">                        f.write(file_f.read())</span><br><span class="line">            shutil.rmtree(path + <span class="string">&#x27;/&#x27;</span> + book)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time:2022/09/29</span></span><br><span class="line"><span class="string">@file:17k.com.py</span></span><br><span class="line"><span class="string">@author:medivh</span></span><br><span class="line"><span class="string">@IDE:PyCharm </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiofiles</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> random_useragent</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: random_useragent(),</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_target</span>(<span class="params">url, i, book_title, sem</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers) <span class="keyword">as</span> resp:  <span class="comment"># requests.get()</span></span><br><span class="line">                html = etree.HTML(<span class="keyword">await</span> resp.content.read())</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    body_html = html.xpath(<span class="string">&#x27;//div[@class=&quot;readAreaBox content&quot;]&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;body获取失败&#x27;</span>, e, url)</span><br><span class="line">                title = body_html.xpath(<span class="string">&#x27;./h1/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="number">10</span>:</span><br><span class="line">                    num = <span class="string">&#x27;000&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">                <span class="keyword">elif</span> i &lt; <span class="number">100</span>:</span><br><span class="line">                    num = <span class="string">&#x27;00&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">                <span class="keyword">elif</span> i &lt; <span class="number">1000</span>:</span><br><span class="line">                    num = <span class="string">&#x27;0&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">                file_name = <span class="string">&#x27;./novel/&#123;&#125;/&#123;&#125;.txt&#x27;</span>.<span class="built_in">format</span>(book_title, num)</span><br><span class="line">                content_html = body_html.xpath(<span class="string">&#x27;./div[@class=&quot;p&quot;]/p&#x27;</span>)</span><br><span class="line">                content = [i.xpath(<span class="string">&#x27;./text()&#x27;</span>)[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> content_html <span class="keyword">if</span> i.xpath(<span class="string">&#x27;./text()&#x27;</span>)]</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    content.remove(content[-<span class="number">1</span>])</span><br><span class="line">                    <span class="comment"># 大部分情况是因为该章节被锁定，暂时无法查看，忽略即可</span></span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(e, url)</span><br><span class="line">                content.insert(<span class="number">0</span>, title)</span><br><span class="line">                content.append(<span class="string">&#x27;该章节存在问题，已经被锁定，暂时无法查看&#x27;</span>) <span class="keyword">if</span> <span class="built_in">len</span>(content) == <span class="number">1</span> <span class="keyword">else</span> content.append(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(file_name, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">await</span> f.write(<span class="string">&quot;\n&quot;</span>.join(content))  <span class="comment"># 读写内容异步需要挂起</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all_book_list = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_page_urls</span>(<span class="params">url, sem</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers) <span class="keyword">as</span> resp:</span><br><span class="line">                html = etree.HTML(<span class="keyword">await</span> resp.content.read())</span><br><span class="line">                urls = []</span><br><span class="line">                title_of_book = html.xpath(<span class="string">&#x27;//div[@class=&quot;Main List&quot;]/h1/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="built_in">print</span>(title_of_book)</span><br><span class="line">                td_html = html.xpath(<span class="string">&#x27;//div[@class=&quot;Main List&quot;]/dl[1]/dd[1]/a/@href&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> td_html:</span><br><span class="line">                    url = <span class="string">&#x27;https://www.17k.com&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">                    urls.append(url)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;共获取 &#123;&#125; 章节&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(urls)))</span><br><span class="line">                book_info = &#123;</span><br><span class="line">                    <span class="string">&#x27;title&#x27;</span>: title_of_book,</span><br><span class="line">                    <span class="string">&#x27;urls&#x27;</span>: urls</span><br><span class="line">                &#125;</span><br><span class="line">                all_book_list.append(book_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all_book_url = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_book_url</span>(<span class="params">url, sem</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers) <span class="keyword">as</span> resp:  <span class="comment"># requests.get()</span></span><br><span class="line">                html = etree.HTML(<span class="keyword">await</span> resp.content.read())</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    table_html = html.xpath(<span class="string">&#x27;//tbody/tr[position()&gt;2]&#x27;</span>)</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> table_html:</span><br><span class="line">                        url = i.xpath(<span class="string">&#x27;./td[3]/span/a/@href&#x27;</span>)[<span class="number">0</span>].replace(<span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;list&#x27;</span>)  <span class="comment"># 处理为书籍的章节页面链接</span></span><br><span class="line">                        url = <span class="string">&#x27;https:&#x27;</span> + url</span><br><span class="line">                        all_book_url.append(url)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;body获取失败&#x27;</span>, e, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = []</span><br><span class="line">    sem = asyncio.Semaphore(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取所有书籍的URL</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">35</span>):</span><br><span class="line">        url = <span class="string">&#x27;https://www.17k.com/all/book/3_0_0__3__1__&#123;&#125;.html&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">        task = asyncio.create_task(get_book_url(url, sem))</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(all_book_url))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取书籍的所有目录的URL</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> all_book_url:</span><br><span class="line">        task = asyncio.create_task(get_page_urls(i, sem))</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(all_book_list))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> all_book_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./novel/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(book[<span class="string">&#x27;title&#x27;</span>])):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;./novel/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(book[<span class="string">&#x27;title&#x27;</span>]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;处理 &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(book[<span class="string">&#x27;title&#x27;</span>]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(book[<span class="string">&#x27;urls&#x27;</span>])):</span><br><span class="line">            task = asyncio.create_task(download_target(book[<span class="string">&#x27;urls&#x27;</span>][i], i, book[<span class="string">&#x27;title&#x27;</span>], sem))</span><br><span class="line">            tasks.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_file</span>(<span class="params">path</span>):</span><br><span class="line">    top_file_list = os.listdir(path)</span><br><span class="line">    <span class="built_in">print</span>(top_file_list)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> book <span class="keyword">in</span> top_file_list:</span><br><span class="line">            file_list = os.listdir(path + <span class="string">&#x27;/&#x27;</span> + book)</span><br><span class="line">            file_list.sort()</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> file_list:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./book/&#123;&#125;.txt&#x27;</span>.<span class="built_in">format</span>(book), <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./novel/&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(book) + file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file_f:</span><br><span class="line">                        f.write(file_f.read())</span><br><span class="line">            shutil.rmtree(path + <span class="string">&#x27;/&#x27;</span> + book)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    version 1.0:</span></span><br><span class="line"><span class="string">    1. 获取章节URL</span></span><br><span class="line"><span class="string">    2. 从URL获取章节内容</span></span><br><span class="line"><span class="string">    3. 存储</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    version 1.5:</span></span><br><span class="line"><span class="string">    1. 获取所有免费小说的URL</span></span><br><span class="line"><span class="string">    2. 从URL获取章节内容</span></span><br><span class="line"><span class="string">    3. 存储</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    start = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(start)</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br><span class="line">    merge_file(<span class="string">&#x27;./novel&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    end = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(end)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;抓取耗时：&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此项任务中遇到了几次<code>nodename nor servname provided, or not known</code>的问题，可能是由于大量并发造成DNS解析出现的问题，适用gevent来解决。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>批量抓取新发地菜价</title>
    <url>//%E6%89%B9%E9%87%8F%E6%8A%93%E5%8F%96%E6%96%B0%E5%8F%91%E5%9C%B0%E8%8F%9C%E4%BB%B7</url>
    <content><![CDATA[<p>此篇是之前写的另外一个爬虫项目，只不过后来又了若干版本的演变，因此记录下来。</p>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><ul>
<li>多线程</li>
<li>asyncio</li>
<li>aiohttp</li>
<li>aiofiles</li>
</ul>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>该项目抓取的逻辑比较简单，直接根据api获取数据后存储即可，无需从源代码上筛选节点。</p>
<h2 id="多线程的方式"><a href="#多线程的方式" class="headerlink" title="多线程的方式"></a>多线程的方式</h2><blockquote>
<p>需要注意线程数量和limit值，否则容易把网站搞崩！</p>
</blockquote>
<p>下列代码实现两种功能，全量和增量，适用flag来标识：</p>
<ul>
<li>全量数据，抓取全部，如果出现失败的会最终进行重试，直到指定list为空；</li>
<li>增量数据，默认抓取今天，但是如果没有今天的则抓取前一天的，并和已有文件进行比对，不存在对应日期则存储。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time:2022/09/26</span></span><br><span class="line"><span class="string">@file:xinfadi.py</span></span><br><span class="line"><span class="string">@author:medivh</span></span><br><span class="line"><span class="string">@IDE:PyCharm </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> random_useragent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page_total</span>():</span><br><span class="line">    url = <span class="string">&quot;http://xinfadi.com.cn/getPriceData.html&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(</span><br><span class="line">            url,</span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&quot;User-Agent&quot;</span>: random_useragent(),</span><br><span class="line">                <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line">        content = response.json()</span><br><span class="line">        <span class="keyword">return</span> content[<span class="string">&#x27;count&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">cols</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xfd.csv&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&quot;&quot;</span>.join(cols))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">pages, current_num, limit_num, flag</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param current_num: 当前页</span></span><br><span class="line"><span class="string">    :param limit_num: 限制返回数量</span></span><br><span class="line"><span class="string">    :param flag: True 全量，False 增量</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        data = download_one_page(current_num, limit_num)</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">and</span> save_data(data):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;完成第&#123;&#125;页&#x27;</span>.<span class="built_in">format</span>(current_num))</span><br><span class="line">            pages.remove(current_num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行增量逻辑&#x27;</span>)</span><br><span class="line">        data = download_one_page(<span class="number">1</span>, <span class="number">300</span>)</span><br><span class="line">        <span class="comment"># 获得当前时间</span></span><br><span class="line">        now = datetime.datetime.now()</span><br><span class="line">        <span class="comment"># 转换为指定的格式:</span></span><br><span class="line">        days = now.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">        new_data = [col <span class="keyword">for</span> col <span class="keyword">in</span> data <span class="keyword">if</span> days <span class="keyword">in</span> col]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> new_data:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;没有今天的数据，重新拉取昨天的数据&#x27;</span>)</span><br><span class="line">            one_day_ago = (datetime.datetime.now() - datetime.timedelta(days=<span class="number">1</span>))</span><br><span class="line">            days = one_day_ago.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">            new_data = [col <span class="keyword">for</span> col <span class="keyword">in</span> data <span class="keyword">if</span> days <span class="keyword">in</span> col]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;xfd.csv&#x27;</span>) <span class="keyword">or</span> <span class="keyword">not</span> os.path.getsize(<span class="string">&#x27;xfd.csv&#x27;</span>):</span><br><span class="line">                <span class="comment"># 如果文件不存在或者文件为空，则全部存储</span></span><br><span class="line">                save_data(new_data)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xfd.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    1. 如果查询到的第一行不为空不包含指定日期，则存储</span></span><br><span class="line"><span class="string">                    2. 如果查询到的第一行为空，则存储</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> days <span class="keyword">not</span> <span class="keyword">in</span> f.readline():</span><br><span class="line">                        save_data(new_data)</span><br><span class="line">                    <span class="keyword">elif</span> days <span class="keyword">not</span> <span class="keyword">in</span> f.readline():</span><br><span class="line">                        save_data(new_data)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_one_page</span>(<span class="params">current_num, limit_num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param current_num: 当前页</span></span><br><span class="line"><span class="string">    :param limit_num: 总数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = <span class="string">&quot;http://xinfadi.com.cn/getPriceData.html&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(</span><br><span class="line">            url,</span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&quot;User-Agent&quot;</span>: random_useragent(),</span><br><span class="line">                <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            data=&#123;</span><br><span class="line">                <span class="string">&quot;current&quot;</span>: current_num,</span><br><span class="line">                <span class="string">&quot;limit&quot;</span>: limit_num</span><br><span class="line">            &#125;,</span><br><span class="line">            timeout=<span class="number">10</span></span><br><span class="line">        )</span><br><span class="line">        content = response.json()</span><br><span class="line">        cols = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> content[<span class="string">&#x27;list&#x27;</span>]:</span><br><span class="line">            col = <span class="string">&#x27;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125; \n&#x27;</span>.<span class="built_in">format</span>(i[<span class="string">&#x27;id&#x27;</span>], i[<span class="string">&#x27;prodName&#x27;</span>], i[<span class="string">&#x27;prodCatid&#x27;</span>], i[<span class="string">&#x27;prodCat&#x27;</span>],</span><br><span class="line">                                                            i[<span class="string">&#x27;lowPrice&#x27;</span>],</span><br><span class="line">                                                            i[<span class="string">&#x27;highPrice&#x27;</span>], i[<span class="string">&#x27;avgPrice&#x27;</span>], i[<span class="string">&#x27;place&#x27;</span>],</span><br><span class="line">                                                            i[<span class="string">&#x27;unitInfo&#x27;</span>],</span><br><span class="line">                                                            i[<span class="string">&#x27;pubDate&#x27;</span>])</span><br><span class="line">            cols.append(col)</span><br><span class="line">        response.close()</span><br><span class="line">        <span class="keyword">return</span> cols</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace_price</span>(<span class="params">nums, limit_num</span>):</span><br><span class="line">    <span class="comment"># time.sleep(30) # 重试数据，可等待30秒，也可以不等</span></span><br><span class="line">    r_sleep = [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>]</span><br><span class="line">    <span class="keyword">while</span> nums:</span><br><span class="line">        <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">10</span>) <span class="keyword">as</span> rp_t:</span><br><span class="line">            <span class="keyword">for</span> page_num <span class="keyword">in</span> nums:</span><br><span class="line">                rp_args = [page_num, limit_num]</span><br><span class="line">                rp_t.submit(<span class="keyword">lambda</span> p: download_one_page(*p), rp_args)</span><br><span class="line">                time.sleep(random.choice(r_sleep))</span><br><span class="line">    rp_end = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(rp_end)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最终耗时：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(rp_end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_data</span>():</span><br><span class="line">    limit_num = <span class="number">1000</span></span><br><span class="line">    page_nums = <span class="built_in">int</span>(count / <span class="number">1500</span>) + <span class="number">1</span> + <span class="number">1</span>  <span class="comment"># 此处为页面总数，+1为无法整除的情况，第二个+1为range范围终止位置需要再+1</span></span><br><span class="line">    pages = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">10</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, page_nums):</span><br><span class="line">            args = [pages, i, limit_num, <span class="literal">True</span>]</span><br><span class="line">            pages.append(i)</span><br><span class="line">            t.submit(<span class="keyword">lambda</span> p: get_data(*p), args)</span><br><span class="line">    end = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(end)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;初次抓取耗时：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">    <span class="keyword">if</span> pages:</span><br><span class="line">        replace_price(pages, limit_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">last_day_data</span>():</span><br><span class="line">    <span class="comment"># TODO 增量数据放在文首</span></span><br><span class="line">    limit_num = <span class="number">1000</span></span><br><span class="line">    page_nums = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    pages = <span class="built_in">list</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;初始化page &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pages))</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">10</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, page_nums):</span><br><span class="line">            args = [pages, i, limit_num, <span class="literal">False</span>]</span><br><span class="line">            pages.append(i)</span><br><span class="line">            t.submit(<span class="keyword">lambda</span> p: get_data(*p), args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(start)</span><br><span class="line">    count = get_page_total()</span><br><span class="line">    <span class="keyword">if</span> count:</span><br><span class="line">        <span class="comment"># all_data() # 全量数据</span></span><br><span class="line">        last_day_data() <span class="comment"># 增量数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无法获取总数&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>最终使用了10个线程正常跑完。</p>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作审批规范</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%AE%A1%E6%89%B9%E8%A7%84%E8%8C%83.html</url>
    <content><![CDATA[<h2 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h2><p>为规范生产环境数据库管理和操作，提高审核执行效率，特制定本规范。</p>
<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>本规范中所定义的数据管理内容，指生产环境中的数据库（公司内部项目以及外部项目中的数据库），且包括并不限于 MySQL、Redis、Hive 等。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>普通数据：<ul>
<li>表结构、常规非涉密字段等数据</li>
</ul>
</li>
<li>涉密数据：<ul>
<li>用户信息，包括并不限于手机号、姓名、地址、IP、IMEI 等</li>
<li>公司运行数据，包括并不限于业务订单等</li>
</ul>
</li>
</ul>
<h2 id="操作等级"><a href="#操作等级" class="headerlink" title="操作等级"></a>操作等级</h2><table>
<thead>
<tr>
<th>等级</th>
<th>审核</th>
<th>审核对象</th>
<th>适用类型</th>
<th>数量</th>
<th>是否涉密</th>
<th>可靠性级别</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>否</td>
<td>自行审核</td>
<td>查询表结构、数量、非涉密数据</td>
<td>&lt;1000</td>
<td>否</td>
<td>普通</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>是</td>
<td>项目组长</td>
<td>修改表结构或字段、插入数据，查询大量数据</td>
<td>&lt;5000</td>
<td>否</td>
<td>普通&#x2F;重要</td>
<td>评估后如果影响大，抄送给相关业务线人员，以及技术总监</td>
</tr>
<tr>
<td>2</td>
<td>是</td>
<td>项目组长</td>
<td>查询涉密数据</td>
<td>&lt;100</td>
<td>是</td>
<td>普通</td>
<td>抄送技术总监</td>
</tr>
<tr>
<td>3</td>
<td>是</td>
<td>技术总监</td>
<td>删除表、数据等</td>
<td></td>
<td>否</td>
<td>重要</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>是</td>
<td>技术总监</td>
<td>查询涉密数据</td>
<td>&gt;100</td>
<td>是</td>
<td>普通</td>
<td></td>
</tr>
</tbody></table>
<h2 id="操作规则"><a href="#操作规则" class="headerlink" title="操作规则"></a>操作规则</h2><ul>
<li>所有操作必须通过邮件来传递，运维人员不接受邮件以外的请求;</li>
<li>所有操作必须在主题中表明操作等级，通过操作等级来区分是否需要审核或者其他;</li>
<li>运维人员只接受项目组长或技术总监审核结果，不接受开发者操作请求（可弹性）;</li>
<li>严禁 drop 或者 delete 表操作。如有特殊情况，项目组长在邮件内容中说明操作理由；</li>
<li>SQL 语法错误，不予执行；</li>
<li>SQL 需按照标准语法，必须使用分号结尾,且插入语句不得包含数据库名称。</li>
</ul>
<h3 id="示例如下："><a href="#示例如下：" class="headerlink" title="示例如下："></a>示例如下：</h3><h4 id="开发人员希望查询-A-表的表结构，"><a href="#开发人员希望查询-A-表的表结构，" class="headerlink" title="开发人员希望查询 A 表的表结构，"></a>开发人员希望查询 A 表的表结构，</h4><p>1.邮件需要填写以下内容：</p>
<ul>
<li><p>邮件主题 等级 0+简要目的说明</p>
</li>
<li><p>收件人 项目组长</p>
</li>
<li><p>抄送 运维人员</p>
</li>
<li><p>邮件内容<br> * 查询 SQL</p>
<p>2.项目组长审核</p>
<p>3.上述流程完成，运维人员收到项目组长同意的结果后执行上述查询请求。</p>
</li>
</ul>
<h4 id="开发人员查询用户数据且大于-100-条："><a href="#开发人员查询用户数据且大于-100-条：" class="headerlink" title="开发人员查询用户数据且大于 100 条："></a>开发人员查询用户数据且大于 100 条：</h4><p>1.开发人员发起请求</p>
<ul>
<li><p>邮件主题 等级 4+简要目的说明</p>
</li>
<li><p>收件人 项目组长</p>
</li>
<li><p>抄送 运维人员</p>
</li>
<li><p>邮件内容<br> _ 查询原因<br>_ 查询 SQL</p>
<p>2.项目组长审核</p>
</li>
<li><p>如果审核通过，项目组长发送邮件给技术总监请求审核；</p>
</li>
<li><p>如果未通过，开发者调整 SQL 或取消查询</p>
<p>3.技术总监收到项目组长邮件申请请求</p>
</li>
<li><p>审核结果回复给项目组长</p>
<p>4.上述流程完成，运维人员收到技术总监同意的结果后执行上述查询请求。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>OPS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库设计(Database Design)是指根据用户的需求，在某一具体的数据库管理系统上，设计数据库的结构和建立数据库的过程。数据库系统需要操作系统的支持。</p>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>调查和分析用户的业务活动和数据的使用情况，弄清所用数据的种类、范围、数量以及它们在业务活动中交流的情况，确定用户对数据库系统的使用要求和各种约束条件等，形成用户需求规约。<br>需求分析是在用户调查的基础上，通过分析，逐步明确用户对系统的需求，包括数据需求和围绕这些数据的业务处理需求。在需求分析中，通过自顶向下，逐步分解的方法分析系统，分析的结果采用数据流程图(DFD)进行图形化的描述。</p>
<h3 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h3><p>对用户要求描述的现实世界(可能是一个工厂、一个商场或者一个学校等)，通过对其中诸处的分类、聚集和概括，建立抽象的概念数据模型。这个概念模型应反映现实世界各部门的信息结构、信息流动情况、信息间的互相制约关系以及各部门对信息储存、查询和加工的要求等。所建立的模型应避开数据库在计算机上的具体实现细节，用一种抽象的形式表示出来。以扩充的实体—（E-R 模型）联系模型方法为例，第一步先明确现实世界各部门所含的各种实体及其属性、实体间的联系以及对信息的制约条件等，从而给出各部门内所用信息的局部描述(在数据库中称为用户的局部视图)。第二步再将前面得到的多个用户的局部视图集成为一个全局视图，即用户要描述的现实世界的概念数据模型。</p>
<h3 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h3><p>主要工作是将现实世界的概念数据模型设计成数据库的一种逻辑模式，即适应于某种特定数据库管理系统所支持的逻辑数据模式。与此同时，可能还需为各种数据处理应用领域产生相应的逻辑子模式。这一步设计的结果就是所谓“逻辑数据库”。</p>
<h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><p>根据特定数据库管理系统所提供的多种存储结构和存取方法等依赖于具体计算机结构的各项物理设计措施，对具体的应用任务选定最合适的物理存储结构(包括文件类型、索引结构和数据的存放次序与位逻辑等)、存取方法和存取路径等。这一步设计的结果就是所谓“物理数据库”。</p>
<h3 id="验证设计"><a href="#验证设计" class="headerlink" title="验证设计"></a>验证设计</h3><p>在上述设计的基础上，收集数据并具体建立一个数据库，运行一些典型的应用任务来验证数据库设计的正确性和合理性。一般，一个大型数据库的设计过程往往需要经过多次循环反复。当设计的某步发现问题时，可能就需要返回到前面去进行修改。因此，在做上述数据库设计时就应考虑到今后修改设计的可能性和方便性。</p>
<h3 id="运行与维护设计"><a href="#运行与维护设计" class="headerlink" title="运行与维护设计"></a>运行与维护设计</h3><p>在数据库系统正式投入运行的过程中，必须不断地对其进行调整与修改。<br>至今，数据库设计的很多工作仍需要人工来做，除了关系型数据库已有一套较完整的数据范式理论可用来部分地指导数据库设计之外，尚缺乏一套完善的数据库设计理论、方法和工具，以实现数据库设计的自动化或交互式的半自动化设计。所以数据库设计今后的研究发展方向是研究数据库设计理论，寻求能够更有效地表达语义关系的数据模型，为各阶段的设计提供自动或半自动的设计工具和集成化的开发环境，使数据库的设计更加工程化、更加规范化和更加方便易行，使得在数据库的设计中充分体现软件工程的先进思想和方法。<br>存在问题</p>
<ul>
<li>需求分析阶段:分析客户的业务和数据处理需求.</li>
<li>概要设计阶段:绘制数据库的 E-R 图.</li>
<li>详细设计阶段:应用数据库的三大范式进行审核数据库的结构.</li>
</ul>
<h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><ul>
<li>第一范式<ul>
<li>数据库表中的所有字段都只有单一属性</li>
<li>单一属性的列都是由基本的数据类型所构成</li>
<li>设计出来的表都是简单的二维表</li>
</ul>
</li>
<li>第二范式<ul>
<li>一个表中只具有一个业务主键</li>
</ul>
</li>
<li>第三范式<ul>
<li>每一个非主属性既不部分依赖也不传递依赖业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖</li>
</ul>
</li>
</ul>
<h4 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h4><p>适当遵循范式化的数据库设计，实现了消除数据冗余的目的，但此时数据库的性能和读取效率并不是最优的。为了性能和读取效率的考虑，可以适当对设计范式要求进行违反，而存在少了的数据冗余，用使用空间来换取时间。</p>
<p>总结:在进行数据库的系统分析时,都以下列 4 点位参考的基本步骤.</p>
<ul>
<li>收集信息.</li>
<li>标识实体.</li>
<li>标识每个实体需要储存的详细信息.</li>
<li>标识实体之间的关系.</li>
</ul>
<h2 id="概念设计-E-R-图"><a href="#概念设计-E-R-图" class="headerlink" title="概念设计 E-R 图"></a>概念设计 E-R 图</h2><p>将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计，最后生成的模型是 E-R 图。注意先写局部 E-R 图，再写整体 E-R 图。<br>E-R ：Entity Relationship Diagrams（实体关系模型）<br>E-R 图：实体-联系图<br>E-R 图可以认为是关系模型的雏形，每个实体是一张表，实体与实体之间的关系可以合并到其中一个实体中，也可以是另外一张表，关系表和相关的实体表是通过主键或外键来联系的。</p>
<p>E-R 图 3 个要素：实体，属性，关系。</p>
<ul>
<li>实体：用矩形表示，矩形框内写明实体名。</li>
<li>属性：用椭圆形表示,椭圆内写明属性名称，并用连线与实体连接起来。如果属性较多,为使图形更加简明,有时也将实体与其相应的属性另外单独用列表表示。</li>
<li>联系：用菱形表示，菱形框内写明联系名，并用连线分别与有关实体连接起来，同时在连线旁标上联系的类型。</li>
</ul>
<p>连线：实体和属性之间、实体与联系之间、联系与属性之间用直线连接，并在直线上标注联系的类型。（注意：对于 1：1 的联系，要在两个实体连线方向各写 1，1：n 关系的，要在一的方向写 1，多的方向写 N；对于 N:M 关系的，则要在两个实体连线方向各写 N,M）</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><img data-src="https://img.econow.cn/medivh/1610874775979.png"  />

<p>可以将人表的主键放在身份证表里面，也可以将身份证表的主键放置于人表里面。</p>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>比如一个班级有多个学生，班级是 1 端，学生是多端。多端有 1 端的属性，也就是说多端里面应该放置 1 端的主键，那么学生表里面应该放置班级表里面的主键。<br><img data-src="https://img.econow.cn/medivh/1610874874871.png"  /></p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>例如学生和选修课之间的关系，一个学生可以选择多门课程，而每个选修课又可以被多名学生选择。数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 吴爱华.数据库应用系统开发过程、技术及案例详解.中国人民大学出版社</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派初始化总结</title>
    <url>/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h3 id="修改软件源"><a href="#修改软件源" class="headerlink" title="修改软件源"></a>修改软件源</h3><p>由于默认的软件源在国外，一般速度会略微有点慢，因此最好选择国内的。起初用过阿里云的，但是很多包装不了，因此推荐阿里云以外的其它源。<br>需要修改&#x2F;etc&#x2F;apt&#x2F;sources.list文件，注释并添加。<br>修改示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi</span><br><span class="line"># Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line">#deb-src http://archive.raspbian.org/raspbian/ jessie main contrib non-free rpi</span><br><span class="line">deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free</span><br></pre></td></tr></table></figure>
<h4 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h4 id="国内软件源地址："><a href="#国内软件源地址：" class="headerlink" title="国内软件源地址："></a>国内软件源地址：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中国科学技术大学</span><br><span class="line">Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/</span><br><span class="line">阿里云</span><br><span class="line">Raspbian http://mirrors.aliyun.com/raspbian/raspbian/</span><br><span class="line">清华大学</span><br><span class="line">Raspbian http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</span><br><span class="line">华中科技大学</span><br><span class="line">Raspbian http://mirrors.hustunique.com/raspbian/raspbian/</span><br><span class="line">Arch Linux ARM http://mirrors.hustunique.com/archlinuxarm/</span><br><span class="line">华南农业大学（华南用户）</span><br><span class="line">Raspbian http://mirrors.scau.edu.cn/raspbian/</span><br><span class="line">大连东软信息学院源（北方用户）</span><br><span class="line">Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/</span><br><span class="line">重庆大学源（中西部用户）</span><br><span class="line">Raspbian http://mirrors.cqu.edu.cn/Raspbian/raspbian/</span><br><span class="line">中山大学 已跳转至中国科学技术大学源</span><br><span class="line">Raspbian http://mirror.sysu.edu.cn/raspbian/raspbian/</span><br><span class="line">新加坡国立大学</span><br><span class="line">Raspbian http://mirror.nus.edu.sg/raspbian/raspbian</span><br><span class="line">牛津大学</span><br><span class="line">Raspbian http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/</span><br><span class="line">韩国KAIST大学</span><br><span class="line">Raspbian http://ftp.kaist.ac.kr/raspbian/raspbian/</span><br></pre></td></tr></table></figure>
<h3 id="支持中文"><a href="#支持中文" class="headerlink" title="支持中文"></a>支持中文</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo  raspi-config</span><br><span class="line">change_locale，在Default locale for the system environment:中选择zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<h3 id="修改-bashrc"><a href="#修改-bashrc" class="headerlink" title="修改.bashrc"></a>修改.bashrc</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias ll=&#x27;ls -l&#x27;</span><br><span class="line">#修改ls显示</span><br><span class="line">alias wget=&#x27;wget -c&#x27;</span><br><span class="line">#允许wget断点续传</span><br><span class="line">TZ=&#x27;Asia/Shanghai&#x27;; export TZ</span><br><span class="line">#修改时区</span><br></pre></td></tr></table></figure>
<h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install curl iftop vim git</span><br><span class="line"></span><br><span class="line">#安装nodejs</span><br><span class="line">cd /home/pi/src</span><br><span class="line">wget http://nodejs.org/dist/v6.9.1/node-v6.9.1.tar.gz</span><br><span class="line">tar -zxvf node-v6.9.1.tar.gz</span><br><span class="line">cd node-v6.9.1</span><br><span class="line">./configure   &amp;&amp; make   &amp;&amp; sudo  make install   &amp;&amp; node -v</span><br><span class="line">#安装curl，curl-config  pycurl依赖环境</span><br><span class="line">cd /home/pi/src</span><br><span class="line">sudo wget http://curl.haxx.se/download/curl-7.24.0.tar.gz</span><br><span class="line">tar -zxvf curl-7.24.0.tar.gz</span><br><span class="line">cd curl-7.24.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">#安装pycurl</span><br><span class="line">cd /home/pi/src</span><br><span class="line">sudo wget http://pycurl.sourceforge.net/download/pycurl-7.19.0.tar.gz</span><br><span class="line">tar -zxvf pycurl-7.19.0.tar.gz</span><br><span class="line">cd pycurl-7.19.0</span><br><span class="line">python3 setup.py install --curl-config=/usr/local/bin/curl-config</span><br><span class="line">#安装Python3</span><br><span class="line">cd /home/pi/src</span><br><span class="line">sudo wget https://www.python.org/ftp/python/3.5.3/Python-3.5.3.tar.xz</span><br><span class="line">tar -xvf Python-3.5.3.tar.xz</span><br><span class="line">cd Python-3.5.3</span><br><span class="line">./configure --prefix=/usr/local/python3.5</span><br><span class="line">make</span><br><span class="line">sudo make altinstall</span><br><span class="line">sudo ln -s /usr/local/python3.5/bin/python3.5 /usr/bin/python3</span><br><span class="line">sudo ln -s /usr/local/python3.5/bin/pip3.5   /usr/bin/pip3</span><br></pre></td></tr></table></figure>
<h3 id="安装常用服务"><a href="#安装常用服务" class="headerlink" title="安装常用服务"></a>安装常用服务</h3><p>web</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>
<p>db</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql</span><br></pre></td></tr></table></figure>
<p>samba</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install samba</span><br></pre></td></tr></table></figure>
<p>安装花生壳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/pi/src</span><br><span class="line">wget http://download.oray.com/peanuthull/embed/phddns_rapi_3.0.1.armhf.deb</span><br><span class="line">dpkg -i phddns_rapi_3.0.1.armhf.deb</span><br><span class="line">sudo phddns start</span><br><span class="line">sudo phddns status</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派编译安装Python3.5</title>
    <url>/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Python3-5.html</url>
    <content><![CDATA[<p>刚写了一个天气预报的脚本，想部署在服务器上，但是运行的时候报错，说找不到requests库，奇怪的是装上了也报错。后来发现树莓派自带的是3.2，版本有点老可能会有点不兼容吧。<br>那就装个Python3.5吧！</p>
<h4 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install openssl</span><br><span class="line"></span><br><span class="line">sudo wget https://www.python.org/ftp/python/3.5.3/Python-3.5.3.tar.xz</span><br><span class="line">tar -xvf Python-3.5.3.tar.xz</span><br><span class="line">cd Python-3.5.3</span><br><span class="line">./configure --prefix=/usr/local/python3.5</span><br><span class="line">make</span><br><span class="line">make altinstall</span><br></pre></td></tr></table></figure>
<p>进入&#x2F;usr&#x2F;local&#x2F;python3.5 检查是否完整<br><img data-src='http://7xp3xc.com1.z0.glb.clouddn.com/2016/1493107147483.png' width=873></p>
<h4 id="建立软链"><a href="#建立软链" class="headerlink" title="建立软链"></a>建立软链</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/python3.5/bin/python3.5 /usr/bin/python3</span><br><span class="line">sudo ln -s /usr/local/python3.5/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>
<p>检查版本。<br>安装完成！！！</p>
<h3 id="错误整理"><a href="#错误整理" class="headerlink" title="错误整理"></a>错误整理</h3><p>1、 提示Ignoring ensurepip failure: pip 8.1.1 requires SSL&#x2F;TLS<br><img data-src='http://7xp3xc.com1.z0.glb.clouddn.com/2016/1493103640349.png' width=873><br>错误:<br>    没有安装openssl-devel<br>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install openss</span><br></pre></td></tr></table></figure>
<p>2、libssl-dev无法安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> libssl-dev : Depends: libssl1.0.0 (= 1.0.1-4ubuntu5) but 1.0.1-4ubuntu5.3 is to be installed</span><br><span class="line">              Recommends: libssl-doc but it is not going to be installed</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure>
<p>原因： 已安装的libssl1.0.0版本太高, 无法支持<br>解决： 参考 <a href="http://blog.csdn.net/andy812110/article/details/24842219">这里</a></p>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析kubernetes笔记</title>
    <url>//%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes%E7%AC%94%E8%AE%B0</url>
    <content><![CDATA[<blockquote>
<p>编排永远是容器云项目的灵魂所在，也是kubernetes社区持久生命力的源泉。</p>
</blockquote>
<h2 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h2><blockquote>
<p>IaaS 基础设施服务，Infrastucture-as-a-service<br>PasS 平台服务，Platform-as-a-service<br>SaaS 软件服务，Software-as-a-service</p>
</blockquote>
<p><img data-src="https://img.econow.cn/medivh/1645088256165.png" alt="1645088256165.png"></p>
<p><strong>SaaS</strong> 是软件的开发、管理和部署都交给第三方，不需要关心技术问题，拿来即用。普通用户接触到的互联网服务几乎都是SaaS，比如：微信、钉钉、百度云盘等。</p>
<p><strong>PaaS</strong> 提供软件部署平台，抽象掉了硬件和操作系统细节，可以无缝的扩展。开发者只需要关注自己的业务逻辑，不需要关注底层.比如Google APP Engine、阿里云轻量应用服务器等。</p>
<p><strong>IaaS</strong> 是云服务的最底层，提供一些基础资源。它和PaaS的区别是用户需要自己控制底层，实现基础设施的使用逻辑。比如Amazon EC2、阿里云ECS等。</p>
<p>PaaS项目被大家接纳的主要原因，提供了<strong>应用托管</strong>的能力。主流的做法就是租用一批虚拟机，像管理物理服务器那样，用脚本或者手工的方式在机器上部署应用。</p>
<p>Cloud Foundry 会调用操作系统的Cgroups和Namespace机制为每个应用单独创建一个沙盒的隔离环境，然后在沙盒中启动这些应用经常。这样就实现了把多个用户的应用互不干涉的在虚拟机里批量和自动的运行起来的目的。</p>
<p>PaaS项目的核心能力就是所谓的容器。</p>
<p>Docker 项目崛起的主要原因就是在于镜像。<br>所谓的 Docker 镜像，其实就是一个压缩包。但是压缩包直接包含一个完整操作系统的所有文件和目录，所以这个压缩包的内容和本地开发的和测试环境用的操作系统完全一样。</p>
<p>Docker 镜像的精髓就是本地环境和云端环境高度一致。</p>
<p>但是 Docker 项目固然解决了应用打包的问题，但是并不能代替 PaaS 完成大规模部署应用的职责。</p>
<p>Docker 公司为什么要收购 Fig 并发布 Swarm 项目呢？<br>该公司主要目的还是考虑如何让开发者把应用部署在我的项目上。而 Swarm 项目的最大亮点就是完全使用 Docker 项目原版容器管理 API 来完成集群管理。<br>而 Fig 项目之所以受欢迎是因为第一次提出了容器编排的概念。编排主要指用户如何通过某些工具或者配置来完成一组虚拟机以及关联资源的定义、配置、创建和删除等工作，然后由云计算平台按照这些指定的逻辑来完成的过程。</p>
<p>Swarm 擅长跟 Docker 生态的无缝集成，而 Mesos 擅长大规模集群的调度和管理。</p>
<p>容器本身没有价值，有价值的是容器编排。</p>
<p>容器的核心功能就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。对于 Docker 等大多数 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术是用来修改进程视图的主要方法。</p>
<p>在创建容器进程的时候，指定了这个进程所需要启用的一组 Namespace 参数。这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或者配置。而对于宿主机以及其他不相关的程序就完全看不到了。<br>容器只是一种特殊的进程。</p>
<h3 id="隔离与限制"><a href="#隔离与限制" class="headerlink" title="隔离与限制"></a>隔离与限制</h3><p><img data-src="https://img.econow.cn/medivh/1645094370477.png" alt="虚拟机和容器的对比"></p>
<p>敏捷和高性能是容器相对于虚拟机的最大优势，也是它能够在 PaaS 这种细粒度的资源管理平台上大型起到的重要原因。不过，基于 Namespace 的隔离机制相比于虚拟化技术不足的地方就是，隔离的不彻底。</p>
<p>容器只是允许在宿主机上的一种特殊进程，那么多个容器之间使用的就还是一个宿主机的操作系统内核。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 到底是什么，<strong>其实是一组共享了某些资源的容器。</strong></p>
<p>在一个Pod中，infra容器永远是第一个被创建的容器。</p>
<p><strong>状态类型</strong>的组成</p>
<ol>
<li>Pending。这个状态意味着Pod的YAML文件已经提交给了Kubenetes,API对象已经被创建并保存在ETCD中。但是目前该pod中的容器因为某些原因不能正常创建，比如调度不成功。</li>
<li>Running。这个状态下Pod已经调度成功。所包含的容器都已经创建成功，并且至少有一个正在运行中。</li>
<li>Succeeded。这个状态意味着Pod中所有容易都正常运行完毕，并且已经退出。主要常见于一次性的任务。</li>
<li>Failed。这个状态下，至少有一个容器以不正常的状态退出。</li>
<li>Unknown。这是一个异常状态，意味着Pod的状态不能持续被kubelet汇报给apiserver.很可能是主从节点之间的通信出现问题。</li>
</ol>
<h4 id="特殊的Volume"><a href="#特殊的Volume" class="headerlink" title="特殊的Volume"></a>特殊的Volume</h4><p>有这么几种特殊的Volume，存在的意义不是为了存放容器里的数据，也不是用来进行容器和宿主机之间的数据交换，而是为容器提供预先定义好的数据。主要分为以下四种类型：</p>
<ol>
<li>Secret 把pod想要访问的加密数据存放到etcd中，然后就可以通过在Pod的容器里挂载Volume的方式访问到Secret里保存的信息；</li>
<li>ConfigMap</li>
<li>Dowward API</li>
<li>ServiceAccountToken</li>
</ol>
<h5 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h5><p>可以用来存放数据库账号密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-projected-volume </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - <span class="built_in">sleep</span></span><br><span class="line">    - <span class="string">&quot;86400&quot;</span></span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: <span class="string">&quot;/projected-volume&quot;</span></span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: user</span><br><span class="line">      - secret:</span><br><span class="line">          name: pass</span><br></pre></td></tr></table></figure>

<p>注意挂载的Volume类型是projected。这里用到的数据库用户名和密码，正是以Secret对象的方式交给Kubenetes保存的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> ./username.txt</span><br><span class="line">admin</span><br><span class="line">$ <span class="built_in">cat</span> ./password.txt</span><br><span class="line">c1oudc0w!</span><br><span class="line"></span><br><span class="line">$ kubectl create secret generic user --from-file=./username.txt</span><br><span class="line">$ kubectl create secret generic pass --from-file=./password.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看的话直接get secrets就行可以了</span></span><br><span class="line">[root@uat-109 k8s]<span class="comment"># kubectl get secrets</span></span><br><span class="line">NAME                  TYPE                                  DATA   AGE</span><br><span class="line">default-token-s9c4l   kubernetes.io/service-account-token   3      157m</span><br><span class="line">pass                  Opaque                                1      10s</span><br><span class="line">user                  Opaque                                1      23s</span><br></pre></td></tr></table></figure>

<p>除了from-file的方式还可以使用yaml的方式，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line">data:</span><br><span class="line">  user: YWRtaW4=</span><br><span class="line">  pass: MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意Secret对象爼数据必须是经过Base64转码的，以免出现明文密码的安全隐患。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&#x27;admin&#x27;</span> | <span class="built_in">base64</span></span><br><span class="line">dG9t</span><br><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&#x27;1f2d1e2e67df&#x27;</span> | <span class="built_in">base64</span></span><br><span class="line">dG9t</span><br></pre></td></tr></table></figure>

<h5 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># .properties文件的内容</span></span><br><span class="line">$ <span class="built_in">cat</span> example/ui.properties</span><br><span class="line">color.good=purple</span><br><span class="line">color.bad=yellow</span><br><span class="line">allow.textmode=<span class="literal">true</span></span><br><span class="line">how.nice.to.look=fairlyNice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从.properties文件创建ConfigMap</span></span><br><span class="line">$ kubectl create configmap ui-config --from-file=example/ui.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看这个ConfigMap里保存的信息(data)</span></span><br><span class="line">$ kubectl get configmaps ui-config -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  ui.properties: |</span><br><span class="line">    color.good=purple</span><br><span class="line">    color.bad=yellow</span><br><span class="line">    allow.textmode=<span class="literal">true</span></span><br><span class="line">    how.nice.to.look=fairlyNice</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: ui-config</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>pod 的恢复策略有三种模式：</p>
<ul>
<li>Always 任何情况下只要容器不在运行状态就一定自动重启容器</li>
<li>OnFailure 只有在容器异常是才会自动重启容器</li>
<li>Never 从不重启容器</li>
</ul>
<p>PodPreset 可以实现预定义好部分字段，然后对selector的对象进行自动添加。注意要先创建PodPreset，然后再创建应用Pod。</p>
<blockquote>
<p>只适用于1.11以后的版本。</p>
</blockquote>
<h4 id="健康检查方式"><a href="#健康检查方式" class="headerlink" title="健康检查方式"></a>健康检查方式</h4><p>livenessProbe 和 readinessProbe</p>
<ol>
<li>支持http探测</li>
<li>执行命令command探测</li>
<li>tcp探测端口</li>
</ol>
<h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><p>Deployment是一个两层控制权。首先它通过rs的个数开连上应用的版本，然后再通过rs的属性，比如replicas的值来保证pod的副本数量。</p>
<p>deployment 控制 rs版本,rs 控制pod副本数。</p>
<p>Deployment 控制器实际操纵的是ReplicaSet对象，而不是Pod对象。实际上控制的是ReplicaSet的数目，以及每个ReplicaSet的属性。<br>而每一个应用的版本，对应的证书一个ReplicaSet，这个版本应用的Pod数量，则有ReplicaSet通过它自己的控制器来保证。<br><img data-src="evernotecid://2D277EDE-88BA-4DB6-AE12-A2B952C4D28E/appyinxiangcom/3119051/ENNote/p952?hash=1b6fac0f3400e2e1e7d7fec737d824c6" alt="1b6fac0f3400e2e1e7d7fec737d824c6.jpeg"></p>
<p>将一个集群中正在允许的多个Pod版本，交替的逐一升级的过程，就是滚动更新。</p>
<p><img data-src="https://img.econow.cn/medivh/1661754735804.png" alt="1661754735804.png"></p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解StatefulSet（二）</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%20(%E4%BA%8C).html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了 StatefulSet 的基础原理，但是只使用了应用之一的拓扑状态。这一篇将会介绍使用存储状态。</p>
<h3 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h3><p>应用的多个实例分别绑定了不同的存储数据。典型例子就是一个数据库应用的多个存储实例。StatefulSet 的核心功能就是通过某种方式记录这些状态，然后在Pod被重新创建时，能够为新Pod恢复这些状态。比较典型之一，Redis的主从架构。</p>
<h3 id="知识点解析"><a href="#知识点解析" class="headerlink" title="知识点解析"></a>知识点解析</h3><h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><p><img data-src="https://img.econow.cn/medivh/1649409054685.png" alt="1649409054685.png"></p>
<p>当我们启动多个redis实例的时候，他们相互之间就可以通过slaveof 命令形成主库和从库关系，之后会按照三个阶段完成数据的第一次同步。</p>
<ol>
<li>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立连接，并告诉主库即将建立连接，主库确认回复后，主从库间就可以开始同步了。</li>
<li>在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照RDB。</li>
<li>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成RDB文件发送后，就会把此时replocation buffer中修改操作发送给从库，从库再执行这些操作。这样一来，主从库就实现同步了。</li>
</ol>
<p>之后的同步如果不出现意外，都会采用增量的方式进行同步。</p>
<p>此外，有一些其他注意事项：</p>
<ul>
<li>为避免数据混乱，从节点是默认不允许写的</li>
<li>首次连接需要同步全量 RDB ，此后执行基于长连接的命令传播</li>
<li>建议使用 主-从-从 的级联架构，减轻每一个从节点连进来主节点都要进行一次生成RDB和传输RDB的压力</li>
<li>从节点断连后，如短时间内重新连入，则只需要进行增量更新。如未同步的数据过多 （repl_backlog_buffer中未同步的数据已被覆盖），则需要进行一次全量同步</li>
</ul>
<p>综上所述，Redis主从架构的基本原理在于同步和保持可用性的持久化。</p>
<h4 id="PV-PVC"><a href="#PV-PVC" class="headerlink" title="PV&#x2F;PVC"></a>PV&#x2F;PVC</h4><p>PV (PersistentVolume）是设置的存储，群集的一部分，也是一种资源。场景的PV有很多种，比如NAS、NFS和ceph等等。</p>
<p>PVC 是用户的存储请求，和Pod类似。Pod消耗节点资源，PVC消耗PV资源。并且可以设置请求特定的大小和模式。其主要作用是确保相关Pod正在使用的PVC不会从系统中删除。因为如果被移除的话会导致数据丢失。</p>
<p>PV访问模式:</p>
<ol>
<li>ReadWriteOnce——该卷可以被单个节点以读&#x2F;写模式挂载</li>
<li>ReadOnlyMany——该卷可以被多个节点以只读模式挂载</li>
<li>ReadWriteMany——该卷可以被多个节点以读&#x2F;写模式挂载</li>
</ol>
<p>在命令行中，访问模式缩写为：</p>
<ul>
<li>RWO - ReadWriteOnce</li>
<li>ROX - ReadOnlyMany</li>
<li>RWX - ReadWriteMany</li>
</ul>
<p>PVC回收策略：</p>
<ol>
<li>Retain（保留）——手动回收</li>
<li>Recycle（回收）——基本擦除（ rm -rf &#x2F;thevolume&#x2F;* ）</li>
<li>Delete（删除）——关联的存储资产（例如 AWS EBS、GCE PD、Azure Disk 和 OpenStack Cinder 卷）</li>
</ol>
<p>将被删除当前，只有 NFS 和 HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk 和 Cinder 卷支持删除策略。</p>
<p>PVC的状态：</p>
<ol>
<li>Available（可用）——一块空闲资源还没有被任何声明绑定</li>
<li>Bound（已绑定）——卷已经被声明绑定</li>
<li>Released（已释放）——声明被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）——该卷的自动回收失败</li>
</ol>
<p>使用PVC时需要注意，在每个node节点上都需要安装nfs-utis，不然会报错，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  Warning  FailedMount  54s (x8 over 117s)  kubelet            MountVolume.SetUp failed <span class="keyword">for</span> volume <span class="string">&quot;redis01&quot;</span> : mount failed: <span class="built_in">exit</span> status 32</span><br><span class="line">Mounting <span class="built_in">command</span>: mount</span><br><span class="line">Mounting arguments: -t nfs 192.168.1.10:/Public/redis-master /var/lib/kubelet/pods/0645dd81-4bba-4fd5-bf08-ffeb72367254/volumes/kubernetes.io~nfs/redis01</span><br><span class="line">Output: mount: wrong fs <span class="built_in">type</span>, bad option, bad superblock on 192.168.1.10:/Public/redis-master,</span><br><span class="line">       missing codepage or helper program, or other error</span><br><span class="line">       (<span class="keyword">for</span> several filesystems (e.g. nfs, cifs) you might</span><br><span class="line">       need a /sbin/mount.&lt;<span class="built_in">type</span>&gt; helper program)</span><br><span class="line"></span><br><span class="line">       In some cases useful info is found <span class="keyword">in</span> syslog - try</span><br><span class="line">       dmesg | <span class="built_in">tail</span> or so.</span><br></pre></td></tr></table></figure>

<h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><h4 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: redis01 <span class="comment"># PV名字</span></span><br><span class="line">spec:</span><br><span class="line">  storageClassName: redis <span class="comment">#卷的名字</span></span><br><span class="line">  persistentVolumeReclaimPolicy: Retain <span class="comment">#回收模式</span></span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce <span class="comment"># 访问模式</span></span><br><span class="line">  nfs:</span><br><span class="line">    path: /Public/redis-master <span class="comment"># NFS目录</span></span><br><span class="line">    server: 192.168.1.10 <span class="comment"># nfs 信息</span></span><br><span class="line">----</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: redis02</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: redis</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  nfs:</span><br><span class="line">    path: /Public/redis2</span><br><span class="line">    server: 192.168.1.10</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: redis03</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: redis</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  nfs:</span><br><span class="line">    path: /Public/redis3</span><br><span class="line">    server: 192.168.1.10</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@uat-master ~]# kubectl get pv</span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                               STORAGECLASS   REASON   AGE</span><br><span class="line">redis01   1Gi        RWO            Retain           Bound    default/redis-data-redis-master-0   redis                   60m</span><br><span class="line">redis02   1Gi        RWO            Retain           Bound    default/redis-data-redis-slave-0    redis                   60m</span><br><span class="line">redis03   1Gi        RWO            Retain           Bound    default/redis-data-redis-slave-1    redis                   60m</span><br></pre></td></tr></table></figure>

<h4 id="redis配置文件"><a href="#redis配置文件" class="headerlink" title="redis配置文件"></a>redis配置文件</h4><p>redis-cm.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-config</span><br><span class="line">data:</span><br><span class="line">  master.conf: |</span><br><span class="line">        port 6379</span><br><span class="line">  slave.conf: |</span><br><span class="line">    port 6379</span><br><span class="line">    slaveof redis-master-0.redis-master 6379</span><br></pre></td></tr></table></figure>

<p>redis-master-sts.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: redis-master</span><br><span class="line">  serviceName: redis-master</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: redis-master</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: redis</span><br><span class="line">          image: redis</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">            - sh</span><br><span class="line">          args:</span><br><span class="line">            - -c</span><br><span class="line">            - redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 6379</span><br><span class="line">              name: masterport</span><br><span class="line">              protocol: TCP</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /usr/local/etc/redis</span><br><span class="line">              name: conf</span><br><span class="line">            - name: redis-data</span><br><span class="line">              mountPath: /data</span><br><span class="line">      volumes:</span><br><span class="line">        - name: conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: redis-config</span><br><span class="line">            items:</span><br><span class="line">              - key: master.conf</span><br><span class="line">                path: redis.conf</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: redis-data</span><br><span class="line">    spec: <span class="comment"># 必须满足下面两个，pod才会绑定到pv上面</span></span><br><span class="line">      accessModes: [ <span class="string">&quot;ReadWriteOnce&quot;</span> ] <span class="comment">#读取模式</span></span><br><span class="line">      storageClassName: <span class="string">&quot;redis&quot;</span> <span class="comment"># 绑定pv名字为redis</span></span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure>

<p>redis-slave-sts.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-slave</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: redis-slave</span><br><span class="line">  serviceName: redis-slave</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: redis-slave</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: redis</span><br><span class="line">          image: redis</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">            - sh</span><br><span class="line">          args:</span><br><span class="line">            - -c</span><br><span class="line">            - redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 6379</span><br><span class="line">              name: redis-slave</span><br><span class="line">              protocol: TCP</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /usr/local/etc/redis</span><br><span class="line">              name: conf</span><br><span class="line">            - name: redis-data</span><br><span class="line">              mountPath: /data</span><br><span class="line">      volumes:</span><br><span class="line">        - name: conf</span><br><span class="line">          configMap:</span><br><span class="line">            name: redis-config</span><br><span class="line">            items:</span><br><span class="line">              - key: slave.conf</span><br><span class="line">                path: redis.conf</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: redis-data</span><br><span class="line">    spec: <span class="comment"># 必须满足下面两个，pod才会绑定到pv上面</span></span><br><span class="line">      accessModes: [ <span class="string">&quot;ReadWriteOnce&quot;</span> ] <span class="comment"># 读取模式</span></span><br><span class="line">      storageClassName: <span class="string">&quot;redis&quot;</span> <span class="comment"># 绑定pv名字为redis</span></span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure>

<p>master-head.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: redis-master</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">    - port: 6379</span><br><span class="line">      targetPort: 6379</span><br><span class="line">      name: redis</span><br></pre></td></tr></table></figure>

<p>slave-head.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-slave</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 6379</span><br><span class="line">      targetPort: 6379</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: redis-slave</span><br><span class="line">  clusterIP: None</span><br></pre></td></tr></table></figure>

<p>上述编排文件都apply后，检查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@uat-master ~]<span class="comment"># kubectl get pv</span></span><br><span class="line">NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                               STORAGECLASS   REASON   AGE</span><br><span class="line">redis01   1Gi        RWO            Retain           Bound    default/redis-data-redis-master-0   redis                   72m</span><br><span class="line">redis02   1Gi        RWO            Retain           Bound    default/redis-data-redis-slave-0    redis                   72m</span><br><span class="line">redis03   1Gi        RWO            Retain           Bound    default/redis-data-redis-slave-1    redis                   72m</span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl get pvc</span></span><br><span class="line">NAME                        STATUS   VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">redis-data-redis-master-0   Bound    redis01   1Gi        RWO            redis          54m</span><br><span class="line">redis-data-redis-slave-0    Bound    redis02   1Gi        RWO            redis          51m</span><br><span class="line">redis-data-redis-slave-1    Bound    redis03   1Gi        RWO            redis          40m</span><br></pre></td></tr></table></figure>

<p>登录master pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@uat-master ~]<span class="comment"># kubectl exec -it po/redis-master-0 -- bash</span></span><br><span class="line">root@redis-master-0:/data<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 196 Apr  8 09:01 dump.rdb</span><br><span class="line">root@redis-master-0:/data<span class="comment"># pwd</span></span><br><span class="line">/data</span><br><span class="line">root@redis-master-0:/data<span class="comment"># df -h</span></span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">overlay                             46G   15G   31G  33% /</span><br><span class="line">tmpfs                               64M     0   64M   0% /dev</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">192.168.1.10:/Public/redis-master  1.3T  505G  816G  39% /data</span><br><span class="line">/dev/mapper/centos-root             46G   15G   31G  33% /etc/hosts</span><br><span class="line">shm                                 64M     0   64M   0% /dev/shm</span><br><span class="line">tmpfs                              2.0G   12K  2.0G   1% /run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /proc/acpi</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /proc/scsi</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /sys/firmware</span><br><span class="line">root@redis-master-0:/data<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 196 Apr  8 09:01 dump.rdb</span><br><span class="line">root@redis-master-0:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=10.200.96.163,port=6379,state=online,offset=3668,lag=1</span><br><span class="line">slave1:ip=10.200.96.159,port=6379,state=online,offset=3668,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:33c2abd3e8ee089411772f5b64790d9463400872</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:3668</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:3668</span><br><span class="line">127.0.0.1:6379&gt; info Keyspace</span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=2,expires=0,avg_ttl=0</span><br></pre></td></tr></table></figure>

<p>在显示信息中看到了slave节点的信息，而且生成了rdb文件。之后检查nfs上也存在对应的文件，无论是master pod还是slave pod对应的目录。</p>
<p>解析DNS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># nslookup redis-slave.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      redis-slave.default.svc.cluster.local</span><br><span class="line">Address 1: 10.200.128.144 redis-slave-0.redis-slave.default.svc.cluster.local</span><br><span class="line">Address 2: 10.200.96.162 redis-slave-1.redis-slave.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">/ <span class="comment"># nslookup redis-master.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      redis-master.default.svc.cluster.local</span><br><span class="line">Address 1: 10.200.128.143 redis-master-0.redis-master.default.svc.cluster.local</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>稳定的持久化存储，Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li>
<li>稳定的网络标识符，Pod重新调度后PodName和HostName不变</li>
<li>有序部署和扩展</li>
<li>有序收缩</li>
</ul>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解StatefulSet（一）</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StatefulSet%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先聊一下Deployment，一个应用的所有Pod是完全一样的。它们相互之间没有顺序，也无所谓运行在哪台宿主机上，需要的时候就创建，不需要的时候就可以中止任意一个Pod。</p>
<p>有些分布式应用，在多个实例之间存有依赖关系，比如主从、主备关系。还有些数据库存储类应用，在本地磁盘会存放一些数据，而实例一旦被杀掉，即使重建出来，实例和数据之间的对应关系都已经丢失。</p>
<p>所以实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，被称为有状态应用（Stateful Appication）。</p>
<h3 id="Statefulset"><a href="#Statefulset" class="headerlink" title="Statefulset"></a>Statefulset</h3><p>StatefulSet 将应用状态抽象为两种情况：</p>
<ol>
<li>拓扑状态。意味着应用之间的多个实例之间不是对等关系。这些应用必须按照某些顺序启动，并且新创建的Pod，必须和原来的网络标识一样，这样原来的访问者才能使用同样的方法，访问到这个新的Pod。</li>
<li>存储状态。这种情况意味着，应用的多个实例分别绑定了不同的存储数据。典型例子就是一个数据库应用的多个存储实例。</li>
</ol>
<p>StatefulSet 的核心功能就是通过某种方式记录这些状态，然后在Pod被重新创建时，能够为新Pod恢复这些状态。</p>
<p>StatefulSet中每个Pod的DNS格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local</span><br></pre></td></tr></table></figure>

<ul>
<li>serviceName 为Headless Service name</li>
<li>0…N-1 为Pod的序号，从0开始</li>
<li>statefulSetName 为StatefulSet name</li>
<li>namespace 为服务所在的namespace</li>
<li>cluster.local为Cluster Domain</li>
</ul>
<p>图解</p>
<p><img data-src="https://img.econow.cn/medivh/1649399502095.png" alt="1649399502095.png"></p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p><img data-src="https://img.econow.cn/medivh/1649399564902.png" alt="1649399564902.png"></p>
<h4 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h4><p><img data-src="https://img.econow.cn/medivh/1649399581462.png" alt="1649399581462.png"></p>
<h4 id="持久卷的创建和删除"><a href="#持久卷的创建和删除" class="headerlink" title="持久卷的创建和删除"></a>持久卷的创建和删除</h4><p><img data-src="https://img.econow.cn/medivh/1649399652857.png" alt="1649399652857.png"></p>
<ol>
<li>增加副本时，会创建对应的pvc；</li>
<li>减少副本时，从高索引值的Pod名开始删除Pod，但是PVC不会被删除，需要手动释放；</li>
<li>当先收缩再扩容时，重建后的Pod实例会绑定到对应序号的PVC上。</li>
</ol>
<h3 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h3><p>首先聊一下Service是如何被访问的呢？</p>
<ol>
<li>以service的VIP模式。比如访问10.0.23.1 这个service的IP地址时，10.0.23.1就是一个VIP，会把请求转发到该service所代理的某一个Pod上。</li>
<li>以service的DNS方式。比如访问“my-svc.my-namspace.svc.cluster.local”这条DNS记录，就可以访问到名为my-svc的service所搭理的某一个Pod。</li>
</ol>
<p>针对于第二种方式，具体还可以分为两种处理方法：</p>
<ol>
<li>Normal Service。访问“my-svc.my-namspace.svc.cluster.local” 解析到的，正是my-svc这个service的VIP，后面的流程和VIP的方式一致</li>
<li>Headless Service。访问“my-svc.my-namspace.svc.cluster.local”解析到的，直接就是my-svc代理的某一个Pod的IP地址。这里的区别在于<strong>Headless Service 不需要分配一个VIP，而是直接以DNS记录的方式解析出被代理POD的IP地址。</strong></li>
</ol>
<p>比如<code>eureka-0.register-server.test.svc.cluster.local</code>。</p>
<p>标签规则：</p>
<ol>
<li>spec.containers.name 容器的名字，如何配置基本无影响</li>
<li>template.metadata.labels 设定的label，注意和selector保持一致。并且该标签需要和headless 中的selector，以及nodePort中的selector保持一致。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>创建一个service</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    name: web</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br></pre></td></tr></table></figure>

<p>再创建一个StatefulSet</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.14.2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br></pre></td></tr></table></figure>

<h4 id="部署eureka集群"><a href="#部署eureka集群" class="headerlink" title="部署eureka集群"></a>部署eureka集群</h4><p>eureka集群部署的主要难点在于如何指定 <code>eureka.client.service-url.defaultZone</code>的值？</p>
<p>对于上述问题可以通过headless机制，不给cluster分配IP，而是通过域名访问服务来解决。在application.yaml文件中使用环境变量，传值给eueka。</p>
<blockquote>
<p>每个eureka会注册到另外的eureka上，也就是eureka.client.serviceUrl.dafaultZone；<br>通过StatefulSet，可以知道每个eureka的name；<br>通过Headless，可以访问到每个eureka；<br>所以eureka.client.serviceUrl.defaultZone的值就是<code>http://eureka-0.eureka:8000/eureka/,http://eureka-1.eureka:8000/eureka/,http://eureka-2.eureka:8000/eureka/</code></p>
</blockquote>
<p>由于三个pod在同一个命名空间内，因此可以省略.namespace.svc.cluster.local。</p>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>application.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name:  DiscoveryServer</span><br><span class="line">info:</span><br><span class="line">  version: <span class="variable">$project</span>.version$</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: <span class="variable">$&#123;POD_HOST_NAME&#125;</span>  <span class="comment">#设置eureka hostname</span></span><br><span class="line">    prefer-ip-address: <span class="literal">false</span> <span class="comment"># 使用服务名注册到eureka server</span></span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">true</span>  <span class="comment">#表示是否将自己注册在EurekaServer上，默认为true</span></span><br><span class="line">    fetch-registry: <span class="literal">true</span>  <span class="comment">#表示表示是否从EurekaServer获取注册信息，默认为true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: <span class="variable">$&#123;EUREKA_INSTANCE_LIST&#125;</span> <span class="comment">#这里在部署的时候会使用环境变量替换</span></span><br><span class="line">joy:</span><br><span class="line">    logback:</span><br><span class="line">      path: logs/EUREKA_INSTANCE_HOSTNAME</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是hostname要使用pod的主机名，否则会出现unavailable-replicas。此外还有其他可能：</p>
<ol>
<li>eureka.instance.preferIpAddress &#x3D; false</li>
<li>defaultZone 后面的eureka注册中心的地址要写成域名；</li>
<li>eureka.client.register-with-eureka的值要写为true</li>
<li>eureka.client.fetch-registry的值要写为true</li>
<li>eureka集群中多个eureka服务的spring.application.name的值要一致</li>
<li>eureka.instance.prefer-ip-address的值必须设置为false</li>
</ol>
<p>service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: eureka</span><br><span class="line">  labels:</span><br><span class="line">    service: eureka</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8761</span><br><span class="line">      targetPort: 8761</span><br><span class="line">      name: eureka</span><br><span class="line">  selector:</span><br><span class="line">    app: eureka</span><br></pre></td></tr></table></figure>

<p>StatefulSet.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: eureka</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;eureka&quot;</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: eureka-pod</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: eureka-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - <span class="built_in">env</span>:</span><br><span class="line">        name: eureka</span><br><span class="line">        image: 192.168.1.232:5000/k8s/eureka:statefull</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">          - name: APP_NAME</span><br><span class="line">            value: <span class="string">&quot;eureka&quot;</span> <span class="comment"># statefulSet name</span></span><br><span class="line">          - name: POD_NAME</span><br><span class="line">            valueFrom:</span><br><span class="line">              fieldRef:</span><br><span class="line">                fieldPath: metadata.name</span><br><span class="line">          - name: POD_HOST_NAME</span><br><span class="line">            value: <span class="string">&quot;<span class="subst">$(POD_NAME)</span>.<span class="subst">$(APP_NAME)</span>.default.svc.cluster.local&quot;</span></span><br><span class="line">          - name: EUREKA_INSTANCE_LIST</span><br><span class="line">            value: <span class="string">&quot;http://eureka-0.<span class="subst">$(APP_NAME)</span>.default.svc.cluster.local:8761/eureka/,http://eureka-1.<span class="subst">$(APP_NAME)</span>.default.svc.cluster.local:8761/eureka/,http://eureka-2.<span class="subst">$(APP_NAME)</span>.default.svc.cluster.local:8761/eureka/&quot;</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8761</span><br><span class="line">        livenessProbe:</span><br><span class="line">          failureThreshold: 10</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /health</span><br><span class="line">            port: 8761</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          periodSeconds: 60</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          timeoutSeconds: 2</span><br><span class="line">        readinessProbe:</span><br><span class="line">          failureThreshold: 1</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /health</span><br><span class="line">            port: 8761</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 10</span><br><span class="line">          periodSeconds: 3</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          timeoutSeconds: 2</span><br></pre></td></tr></table></figure>

<p>传递三个变量：</p>
<ol>
<li>APP_NAME 取值于metadata.name</li>
<li>POD_NAME 取值于metadata.name</li>
<li>POD_HOST_NAME 拼接单个Pod的主机名</li>
<li>EUREKA_INSTANCE_LIST 由Pod的域名拼接组成</li>
</ol>
<p>创建完成后会出现三个带序号的Pod和statfulSet，这个时候请求<code>eureka.default.svc.cluster.local</code>就可以使用服务了。但是如果想在集群外访问，可以使用nodeport的方式暴露。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: eureka-node-port</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 31331</span><br><span class="line">    targetPort: 8761</span><br><span class="line">    nodePort: 31331</span><br><span class="line">  selector:</span><br><span class="line">    app: eureka-pod</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.econow.cn/medivh/1649398888400.png" alt="1649398888400.png"></p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="headless-service和普通service的区别"><a href="#headless-service和普通service的区别" class="headerlink" title="headless service和普通service的区别"></a>headless service和普通service的区别</h3><ul>
<li>headless 不分配clusterIP，配置<code>clusterIP: None</code></li>
<li>headless service可以通过解析service的DNS，返回所有Pod的地址和DNS</li>
<li>普通service，只能通过解析service的DNS返回service的CLusterIP</li>
</ul>
<h3 id="statefulSet和Deployment的区别"><a href="#statefulSet和Deployment的区别" class="headerlink" title="statefulSet和Deployment的区别"></a>statefulSet和Deployment的区别</h3><ul>
<li>statefulSet 的Pod有DNS地址，通过解析Pod的DNS可以返回Pod的IP</li>
<li>Deployment下的Pod没有DNS</li>
</ul>
<h3 id="普通service解析"><a href="#普通service解析" class="headerlink" title="普通service解析"></a>普通service解析</h3><p>Service的ClusterIP原理：<br>一个service可以对应一组endpoints，client访问ClusterIP，通过iptables或ipvs转发到real server。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取svc,clusterIP为10.105.146.146</span></span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)           AGE</span><br><span class="line">eureka-node-port   NodePort    10.105.146.146   &lt;none&gt;        31331:31331/TCP   8m7s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看svc详情</span></span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl describe svc eureka-node-port</span></span><br><span class="line">Name:                     eureka-node-port</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   &lt;none&gt;</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 app=eureka</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP Families:              &lt;none&gt;</span><br><span class="line">IP:                       10.105.146.146</span><br><span class="line">IPs:                      10.105.146.146</span><br><span class="line">Port:                     &lt;<span class="built_in">unset</span>&gt;  31331/TCP</span><br><span class="line">TargetPort:               8761/TCP</span><br><span class="line">NodePort:                 &lt;<span class="built_in">unset</span>&gt;  31331/TCP</span><br><span class="line">Endpoints:                10.200.128.133:8761,10.200.128.134:8761,10.200.128.137:8761</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试解析</span></span><br><span class="line"></span><br><span class="line">/ <span class="comment"># nslookup eureka-node-port.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      eureka-node-port.default.svc.cluster.local</span><br><span class="line">Address 1: 10.105.146.146 eureka-node-port.default.svc.cluster.local</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上所述，DNS查询时只会返回service的clusterIP，具体client访问的是哪个real server，由iptabels或者ipvs决定。</p>
<h3 id="headless-service解析"><a href="#headless-service解析" class="headerlink" title="headless service解析"></a>headless service解析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取svc</span></span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)           AGE</span><br><span class="line">eureka             ClusterIP   None             &lt;none&gt;        8761/TCP          27m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情</span></span><br><span class="line">[root@uat-master ~]<span class="comment"># kubectl describe svc eureka</span></span><br><span class="line">Name:              eureka</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            service=eureka</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=eureka</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Families:       &lt;none&gt;</span><br><span class="line">IP:                None</span><br><span class="line">IPs:               None</span><br><span class="line">Port:              eureka  8761/TCP</span><br><span class="line">TargetPort:        8761/TCP</span><br><span class="line">Endpoints:         10.200.128.133:8761,10.200.128.134:8761,10.200.128.137:8761</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试解析</span></span><br><span class="line">/ <span class="comment"># nslookup eureka.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      eureka.default.svc.cluster.local</span><br><span class="line">Address 1: 10.200.128.134 eureka-1.eureka.default.svc.cluster.local</span><br><span class="line">Address 2: 10.200.128.133 eureka-0.eureka.default.svc.cluster.local</span><br><span class="line">Address 3: 10.200.128.137 eureka-2.eureka.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析单独pod的DNS记录</span></span><br><span class="line"></span><br><span class="line">/ <span class="comment"># nslookup eureka-2.eureka.default.svc.cluster.local</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      eureka-2.eureka.default.svc.cluster.local</span><br><span class="line">Address 1: 10.200.128.137 10-200-128-137.eureka-node-port.default.svc.cluster.local</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上所述，DNS查询会返回所有的endpoint，通过解析Pod的DNS记录，也能返回Pod的IP。</p>
<h3 id="headless-service使用场景"><a href="#headless-service使用场景" class="headerlink" title="headless service使用场景"></a>headless service使用场景</h3><ul>
<li>自助选择权，client可以自己决定使用哪个real server，可以通过DNS来获取real server信息。</li>
<li>headless service关联的每个pod，都会有对应的DNS域名，这样Pod直接可以互相访问。这样对于一些集训类型的应用就可以解决身份是吧的问题了。</li>
</ul>
<h3 id="为什么要用headless-statefulSet部署有状态应用"><a href="#为什么要用headless-statefulSet部署有状态应用" class="headerlink" title="为什么要用headless+statefulSet部署有状态应用"></a>为什么要用headless+statefulSet部署有状态应用</h3><ol>
<li>headless service会为关联的Pod分配一个域 <code>&lt;service name&gt;.$&lt;namespace name&gt;.svc.cluster.local</code></li>
<li>statefulSet 会为关联的Pod保持一个不变的Pod Name <code>$(statefulSet name)-$(pod序号)</code></li>
<li>statefulSet会为关联的Pod分配一个dnsName <code>$&lt;Pod Name&gt;.$&lt;service name&gt;.$&lt;namespace name&gt;.svc.cluster.local</code></li>
</ol>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>USB存储设备启动树莓派</title>
    <url>/%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8%E6%A0%91%E8%8E%93%E6%B4%BE.html</url>
    <content><![CDATA[<p>USB存储设备的系统安装<br>准备一个USB存储设备，我用的是U盘，硬盘应该也行。需要格式化，所以注意备数据的备份。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo parted /dev/sda  # 使用parted对U欧盘进行分区</span><br><span class="line"></span><br><span class="line">(parted) mktable msdos # 创建msdos格式的分区表</span><br><span class="line">Warning: The existing disk label on /dev/sda will be destroyed and all data on this disk will be lost. Do you want to continue?</span><br><span class="line">Yes/No? Yes       </span><br><span class="line">(parted) mkpart primary fat32 0% 100M # 分 100M 格式成fat32</span><br><span class="line">(parted) mkpart primary ext4 100M 100% #  剩下的全都格式成ext4</span><br></pre></td></tr></table></figure>
<p>一般都是sda,不过分不清楚的话可以用 $sudo fdisk -l | grep sd查看。</p>
<p>创建BOOT 和root 文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkfs.vfat -n BOOT -F 32 /dev/sda1</span><br><span class="line">sudo mkfs.ext4 /dev/sda2</span><br></pre></td></tr></table></figure>
<p>创建文件挂载U盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /mnt/target</span><br><span class="line">sudo mount /dev/sda2 /mnt/target/</span><br><span class="line">sudo mkdir /mnt/target/boot</span><br><span class="line">sudo mount /dev/sda1 /mnt/target/boot/</span><br></pre></td></tr></table></figure>
<p>安装rsync</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rsync</span><br></pre></td></tr></table></figure>
<p>将root和boot文件系统同步到U盘上去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rsync -ax --progress / /boot /mnt/target</span><br></pre></td></tr></table></figure>
<p>关于硬盘启动树莓派</p>
<p>系统启动主要依靠的是boot引导分区和根分区。所以在修改启动项的时候一定得修改sd目录下的cmd.txt<br>更改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=/dev/sda2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait</span><br></pre></td></tr></table></figure>
<p>这样系统在启动的时候就会根据提示找sda2,然后再修改硬盘目录下的&#x2F;etc&#x2F;fstab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc            /proc           proc    defaults          0       0</span><br><span class="line">#PARTUUID=85ce4237-01  /boot           vfat    defaults          0       2</span><br><span class="line">#PARTUUID=85ce4237-02  /               ext4    defaults,noatime  0       1</span><br><span class="line"></span><br><span class="line">/dev/sda1  /boot           vfat    defaults          0        2</span><br><span class="line">/dev/sda2  /               ext4    defaults,noatime  0       1</span><br></pre></td></tr></table></figure>
<p>编辑 cmdline.txt文件，fstab文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sed -i &quot;s,root=/dev/mmcblk0p2,root=/dev/sda2,&quot;/boot/cmdline.txt</span><br><span class="line"></span><br><span class="line">sudo sed -i &quot;s,/dev/mmcblk0p,/dev/sda,&quot; /mnt/target/etc/fstab</span><br></pre></td></tr></table></figure>
<p>不过尝试了多次后发现这种方法似乎不正常，树莓派都不能正常启动。推荐使用下列方式：</p>
<p>编辑&#x2F;boot&#x2F;cmdline.txt文件，修改被引导分区，将root后的内容由原来的树莓派的分区变为root&#x3D;&#x2F;dev&#x2F;sda1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /boot/cmdline.txt</span><br><span class="line">root=</span><br><span class="line">dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=/dev/sda2  rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ cat /etc/fstab</span><br><span class="line">proc            /proc           proc    defaults          0       0</span><br><span class="line">#PARTUUID=72707770-01  /boot           vfat    defaults          0       2</span><br><span class="line">#PARTUUID=72707770-02  /               ext4    defaults,noatime  0       1</span><br><span class="line">/dev/sda1       /boot                 vfat defaults  0 2</span><br><span class="line">/dev/sda2           /                   ext4    defaults,noatime 0      1</span><br><span class="line"># a swapfile is not a swap partition, no line here</span><br><span class="line">#   use  dphys-swapfile swap[on|off]  for that</span><br></pre></td></tr></table></figure>
<p>重启机器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>More</p>
<p>A ：是否能在pi1 pi2 上使用</p>
<p>不能，因为关于boot的代码只在BCD2837上有（也就是raspberry pi 3 这一代）。</p>
<p>Tips ：</p>
<p>最好所用的U盘比microSD卡的容量（准确来说是raspbian的文件系统容量）要大</p>
<p>因为网络原因出现过的一些问题</p>
<p>参考链接<br><a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/msd.md">https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/msd.md</a><br><a href="https://github.com/raspberrypi/documentation/blob/master/hardware/raspberrypi/bootmodes/msd.md">https://github.com/raspberrypi/documentation/blob/master/hardware/raspberrypi/bootmodes/msd.md</a><br>Youtube : <a href="https://www.youtube.com/watch?v=hxV3yrn8FK8">https://www.youtube.com/watch?v=hxV3yrn8FK8</a></p>
]]></content>
      <categories>
        <category>乐趣</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>视频技术的简单理解</title>
    <url>//%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前看到一些视频类APP可以播放VIP或者付费视频，当时很奇怪怎么做到的。只能确定一点，APP的作者肯定不是用的自己的服务器作为播放源。后来看到一些课程，才逐步明白了其中的一些道理。因此，记录一下这一历程。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="问题一、为什么不能直接使用标签？"><a href="#问题一、为什么不能直接使用标签？" class="headerlink" title="问题一、为什么不能直接使用&lt;video src=&quot;xxx.mp4&quot;&gt;&lt;/video&gt;标签？"></a>问题一、为什么不能直接使用<code>&lt;video src=&quot;xxx.mp4&quot;&gt;&lt;/video&gt;</code>标签？</h4><p>大部分懂点HTML的都会认为要想在网页上播放视频，肯定会优先直接使用<code>video</code>标签。但是大部分视频网站会直接这么用吗？</p>
<p>答案是不会，一部电影2个G，要让用户直接下载完才可以观看吗？用户肯定会骂街。此处的视频播放指在线视频，主动下载或缓存的不在讨论范围内。这时候有些人会想到流媒体，这的确是一个方向。</p>
<h4 id="问题二、一般的视频网站是怎么来优化用户体验的？"><a href="#问题二、一般的视频网站是怎么来优化用户体验的？" class="headerlink" title="问题二、一般的视频网站是怎么来优化用户体验的？"></a>问题二、一般的视频网站是怎么来优化用户体验的？</h4><p>用户上传视频后会有以下流程进行处理：</p>
<ol>
<li>转码。将视频按照不同的分辨率处理，比如360P、720、1080P和2K等等，满足在不同网络环境下的加载速度</li>
<li>切片。比如把1小时的视频按分钟拆分为60份，用户在拖动进度条的时候可以快速加载，只需要加载三五个切片就可以了。快速加载，充分利用带宽，减少服务器压力。</li>
</ol>
<p>需要文件记录：</p>
<ol>
<li>视频播放顺序</li>
<li>视频存放路径</li>
</ol>
<blockquote>
<p>知识点： M3U文件。1. 文件是否有加密 2. 文件地址<br>视频播放顺序则是从上到下。</p>
</blockquote>
<p><img data-src="https://img.econow.cn/medivh/1664160498186.png" alt="1664160498186.png"></p>
<p>M3U、text、json &#x3D;&gt; 文本</p>
<p>文件读写</p>
<h4 id="问题三、抓取视频的套路？"><a href="#问题三、抓取视频的套路？" class="headerlink" title="问题三、抓取视频的套路？"></a>问题三、抓取视频的套路？</h4><p>基本步骤；</p>
<ol>
<li>找到m3u8文件</li>
<li>通过m3u8下载ts文件</li>
<li>通过手段把ts文件合并为一个视频文件</li>
</ol>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol>
<li>拿到页面源代码</li>
<li>从源代码提前m3u8文件的URL</li>
<li>下载m3u8</li>
<li>读取m3u8文件，下载视频</li>
<li>合并视频</li>
</ol>
<h3 id="以91kanju-com为例"><a href="#以91kanju-com为例" class="headerlink" title="以91kanju.com为例"></a>以91kanju.com为例</h3><p>首先打开目标视频的URL，查看源代码，然后从源代码里找到带有<code>m3u8</code>的部分<br><img data-src="https://img.econow.cn/medivh/1664177762869.png" alt="1664177762869.png"></p>
<p><img data-src="https://img.econow.cn/medivh/1664177786615.png" alt="1664177786615.png"></p>
<p>下载m3u8文件，获取其中内容。<br><img data-src="https://img.econow.cn/medivh/1664177844442.png" alt="1664177844442.png"></p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># obj = re.compile(r&quot;url: &#x27;(?P&lt;url&gt;.*?)&#x27;,&quot;,re.S)</span></span><br><span class="line"><span class="comment"># url = &#x27;https://www.91kanju.com/vod-play/54812-1-2.html&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># resp = requests.get(url=url,headers=headers).text</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># m3u8_url = obj.search(resp).group(&quot;url&quot;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(m3u8_url)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># #下载m3u8文件</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># resp2 = requests.get(url=m3u8_url,headers=headers)</span></span><br><span class="line"><span class="comment"># with open(&quot;哲仁王后.m3u8&quot;,mode=&#x27;wb&#x27;) as fp:</span></span><br><span class="line"><span class="comment">#     fp.write(resp2.content)</span></span><br><span class="line"><span class="comment">#本地缓存到m3u8文件后将上面注释掉</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;哲仁王后.m3u8&quot;</span>,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fp:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">10</span>:</span><br><span class="line"></span><br><span class="line">            temp = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span> + <span class="built_in">str</span>(n)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">10</span>&lt;=n&lt;<span class="number">100</span>:</span><br><span class="line">            temp = <span class="string">&#x27;0&#x27;</span> + <span class="built_in">str</span>(n)</span><br><span class="line">        resp3 = requests.get(url=line,headers=headers)</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">f&quot;video/<span class="subst">&#123;temp&#125;</span>.ts&quot;</span>,mode=<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        f.write(resp3.content)</span><br><span class="line">        f.close()</span><br><span class="line">        resp3.close()</span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>

<p>最后一步合并视频的方式就各显神通吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事实证明和最初预想的完全不一样。</p>
]]></content>
  </entry>
  <entry>
    <title>详解Kubernetes中Pod的创建和删除过程</title>
    <url>//%E8%AF%A6%E8%A7%A3Kubernetes%E4%B8%ADPod%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前简单了解了Pod的创建过程，也遇到过Pod无法删除的问题，但大部分都是强制删除。因此，此篇文档记录一下对这两个过程的细致理解。</p>
<blockquote>
<p>对go语言不够熟悉，暂时无法达到阅读代码的能力，以下信息均来源于网络总结和自己的思考。</p>
</blockquote>
<h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><p><img data-src="https://img.econow.cn/medivh/1660112505748.png" alt="1660112505748.png"></p>
<ol>
<li>kubectl 将创建Pod的yaml文件提交给APIServer；</li>
<li>APIServer 收到指令通知给controller-manager创建一个资源对象；</li>
<li>controller-manager通过APIServer将Pod的配置信息存储到ETCD中；</li>
<li>scheduler通过 watch机制监听到ETCD中有要创建Pod但未调度的请求后开始调度预选，<ol>
<li>首先过滤掉不符合资源配置的要求的node；</li>
<li>然后开始调度选优，计算出更适合运行的节点。将Pod和节点绑定信息交给APIServer。</li>
</ol>
</li>
<li>APIServer将信息写入ETCD中，</li>
<li>kubelet根据调度结果执行pod创建操作，运行成功后将创建结果返回给APIServer。</li>
</ol>
<h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><p>所谓删除Pod的过程，主要指用户通过<code>kubectl delete pod</code>命令，或者利用HTTP调用接口去执行。</p>
<h3 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h3><h4 id="DeleteResource"><a href="#DeleteResource" class="headerlink" title="DeleteResource"></a>DeleteResource</h4><p>首先调用BeforeDelete方法，查看要删除的Resource瑞祥是否支持优雅删除，如果支持，则优雅变量为TRUE。还执行两个设定，设置删除的时间戳为now，以及优雅删除的时间限制，由用户来决定。</p>
<p>优雅变量如果未TRUE，那么就会调用updateForGracefulDeletionAndFinalizers方法，该方法用于改变Pod的两个字段，DeletionTimestamp和DeletionGracePeriodSeconds。</p>
<p>调用完该方法后会返回deleteImmediately字段，表示是否需要立刻删除，也就是不支持优雅删除。如果支持优雅删除，则delete方法不删除ETCD中的Resource数据，直接返回，APIServer处理逻辑到此结束。</p>
<h4 id="kubelet删除Pod"><a href="#kubelet删除Pod" class="headerlink" title="kubelet删除Pod"></a>kubelet删除Pod</h4><p>kubelet使用syncLoopIteration监听APIServer，一旦出现删除时间，则调用HandlePodUpdates方法处理。</p>
<ol>
<li>首先调用pod manager的updatePod方法来更新Pod信息；</li>
<li>然后判断pod是否为mirror pod，如果是则调用handleMirrorPod方法处理该Pod；</li>
<li>否则利用GetMirrorPodByPod方法得到该Pod的mirror pod，接着调用dispatchWork将pod删除分配给具体的worker处理；</li>
<li>dispatchwork方法调用UpdatePod方法对Pod进行删除；<ol>
<li>该方法会调用其他方法进行判断，进行删除；</li>
<li>杀掉Pod中的容器；</li>
<li>删除pod的pause容器。</li>
</ol>
</li>
<li>kubelet 判断Pod是否已经优雅的停止，资源是否删除干净。<ol>
<li>如果删除干净则返回TRUE，向APIServer发送delete，再次删除Pod。优雅时间设置为0，表示强制删除Pod。因此APIServer会再次收到delete请求，继续执行delete的流程。与第一次不同的是，这次强制删除会执行完整的流程，操作ETCD删除最终的Pod信息。</li>
</ol>
</li>
<li>kubelete 接收到事件变化后，转为remove事件，完成Pod的最终清理工作。</li>
</ol>
<p>以上内容可能描述的并不是很清晰，先占位，以后再补。</p>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>以上流程中还有很多未细致拆分的事件，不再赘述，下面概况总结一下：</p>
<ol>
<li>客户端发出请求删除Pod（可选传递优雅删除参数，时间秒为单位）；</li>
<li>APIServer 做优雅删除的检查，并更新Pod信息，设置删除时间戳和优雅删除时间，默认30s；</li>
<li>kubelet优雅释放Pod资源；</li>
<li>kubelet向APIServer请求删除Pod；</li>
<li>APIServer删除etcd中Pod信息；</li>
<li>Kubelet 完成最终Pod的资源清理。</li>
</ol>
<h3 id="如何删除Pod"><a href="#如何删除Pod" class="headerlink" title="如何删除Pod"></a>如何删除Pod</h3><h4 id="强制删除"><a href="#强制删除" class="headerlink" title="强制删除"></a>强制删除</h4><p><code>kubectl delete pod xxx -n xxx --force --grace-period=0</code> 使用<code>--force</code>命令。</p>
<h4 id="finalizers-删除"><a href="#finalizers-删除" class="headerlink" title="finalizers 删除"></a>finalizers 删除</h4><p><code>kubectl patch pod xxx -n xxx -p &#39;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:null&#125;&#125;&#39;</code></p>
<p>如果一个容器已经在运行，这时需要对一些容器属性进行修改，又不想删除容器，或不方便通过replace的方式进行更新。kubernetes还提供了一种在容器运行时，直接对容器进行修改的方式，就是patch命令。这时就需要edit该资源，将字段finalizers设置为null，之后Kubernetes资源就正常删除了。</p>
<p>APIServer在检查Finalizers并结合是否需要优雅删除来决定是否立刻删除对象。如果对象不需要进行优雅删除:<code>metadata.Finalizers</code>为空，则直接删除。</p>
<h5 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h5><p>Finalizers属于kubernetes GC垃圾收集器，是一种删除拦截机制，能够让控制权实现异步的删除前回调。其存在任何一个资源对象的meta中。</p>
<h5 id="Graceful-Deletion"><a href="#Graceful-Deletion" class="headerlink" title="Graceful Deletion"></a>Graceful Deletion</h5><p>APIServer在处理Pod删除请求时，会根据pod 的 pod.Spec.TerminationGracePeriodSeconds 和 deleteOptions.GracefulPeriodSeconds 综合判断，是否进行 Graceful 删除：</p>
<ol>
<li>当删除请求选项中有设置 GracefulPeriodSeconds，以选项中为准。若没有，使用 pod.Spec.TerminationGracePeriodSeconds 。若 pod.Spec.TerminationGracePeriodSeconds 也没有设置，使用默认值 0 。</li>
<li>当 Pod 没有调度，或者已经结束（无论成功还是失败）。GracePeriodSeconds 都重置为 0.GracePeriodSeconds 为 0 表示不进行优雅删除。非 0 表示进行优雅删除。Pod 的默认优雅删除时间为 30 s ，在对象创建时配置在 pod.Spec.TerminationGracePeriodSeconds 字段。</li>
</ol>
<p>优雅删除的目的是给予 Kubelet 一定时间对 Pod 实行优雅退出。在用户对 Pod 执行 Delete 操作时，Pod 对象不会立即从 API Server 删除，而只是进入 Termination 阶段。Kubelet 会对运行中的 Pod 的容器发送 TERM 信号，通知其退出。并执行用户配置的 preStop hooks 逻辑。当优雅时间过了之后，再开始使用 KILL 信号尝试强制杀容器。</p>
<p>当 kubelet 将 Pod 清理干净后，就会使用 GracefulPeriodSeconds&#x3D;&#x3D;0 的参数执行删除操作。</p>
<p>因为 Pod 实现优雅删除目的是为了给予 Kubelet 时间做资源清理操作，所以这也是为什么在设置 GracePeriodSeconds 阶段，若 Pod 没有被调度或者已经退出，也就可以直接允许立即删除 (GracePeriodSeconds &#x3D; 0)。</p>
<h4 id="无法删除的原因"><a href="#无法删除的原因" class="headerlink" title="无法删除的原因"></a>无法删除的原因</h4><p>了解上述机制后，对象无法删除的原因无外乎以下两个方面：</p>
<ol>
<li>对象存在finalizers，关联的控制权故障未能执行或执行finalizer函数卡主</li>
<li>对象需要优雅删除，但是执行者不能完成删除，比如以下情况：<ol>
<li>kubelet 无法通过container runtime杀死进程。比如进程进入Uninterruptible状态。</li>
<li>kubelet进程停止或者node离线。这种情况下没有kubelet运行或运行中的kubelet与APIServer已经端口，无法收到Pod需要删除的消息。所以没有执行者来进行优雅删除。这种情况下恢复节点以及kubelet即可。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Kubenetes</tag>
      </tags>
  </entry>
</search>
